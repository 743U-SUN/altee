
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model NotificationSettings
 * 
 */
export type NotificationSettings = $Result.DefaultSelection<Prisma.$NotificationSettingsPayload>
/**
 * Model UserLink
 * 
 */
export type UserLink = $Result.DefaultSelection<Prisma.$UserLinkPayload>
/**
 * Model UserYoutubeSettings
 * 
 */
export type UserYoutubeSettings = $Result.DefaultSelection<Prisma.$UserYoutubeSettingsPayload>
/**
 * Model UserImageBanner
 * 
 */
export type UserImageBanner = $Result.DefaultSelection<Prisma.$UserImageBannerPayload>
/**
 * Model UserYoutubeVideo
 * 
 */
export type UserYoutubeVideo = $Result.DefaultSelection<Prisma.$UserYoutubeVideoPayload>
/**
 * Model UserRecommendYoutube
 * 
 */
export type UserRecommendYoutube = $Result.DefaultSelection<Prisma.$UserRecommendYoutubePayload>
/**
 * Model UserPopupSettings
 * 
 */
export type UserPopupSettings = $Result.DefaultSelection<Prisma.$UserPopupSettingsPayload>
/**
 * Model UserOGP
 * 
 */
export type UserOGP = $Result.DefaultSelection<Prisma.$UserOGPPayload>
/**
 * Model UserCustomQuestion
 * 
 */
export type UserCustomQuestion = $Result.DefaultSelection<Prisma.$UserCustomQuestionPayload>
/**
 * Model UserImageCarousel
 * 
 */
export type UserImageCarousel = $Result.DefaultSelection<Prisma.$UserImageCarouselPayload>
/**
 * Model UserImageSidebar
 * 
 */
export type UserImageSidebar = $Result.DefaultSelection<Prisma.$UserImageSidebarPayload>
/**
 * Model UserDisplaySettings
 * 
 */
export type UserDisplaySettings = $Result.DefaultSelection<Prisma.$UserDisplaySettingsPayload>
/**
 * Model LinkService
 * 
 */
export type LinkService = $Result.DefaultSelection<Prisma.$LinkServicePayload>
/**
 * Model ServiceIcon
 * 
 */
export type ServiceIcon = $Result.DefaultSelection<Prisma.$ServiceIconPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model Author
 * 
 */
export type Author = $Result.DefaultSelection<Prisma.$AuthorPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model Article
 * 
 */
export type Article = $Result.DefaultSelection<Prisma.$ArticlePayload>
/**
 * Model ArticleCategory
 * 
 */
export type ArticleCategory = $Result.DefaultSelection<Prisma.$ArticleCategoryPayload>
/**
 * Model ArticleTag
 * 
 */
export type ArticleTag = $Result.DefaultSelection<Prisma.$ArticleTagPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ArticleStatus: {
  DRAFT: 'DRAFT',
  PUBLISHED: 'PUBLISHED',
  ARCHIVED: 'ARCHIVED'
};

export type ArticleStatus = (typeof ArticleStatus)[keyof typeof ArticleStatus]


export const IconStyle: {
  FILLED: 'FILLED',
  OUTLINE: 'OUTLINE',
  MINIMAL: 'MINIMAL',
  GRADIENT: 'GRADIENT',
  THREE_D: 'THREE_D'
};

export type IconStyle = (typeof IconStyle)[keyof typeof IconStyle]


export const IconColor: {
  ORIGINAL: 'ORIGINAL',
  MONOCHROME: 'MONOCHROME',
  WHITE: 'WHITE',
  BLACK: 'BLACK',
  CUSTOM: 'CUSTOM'
};

export type IconColor = (typeof IconColor)[keyof typeof IconColor]

}

export type ArticleStatus = $Enums.ArticleStatus

export const ArticleStatus: typeof $Enums.ArticleStatus

export type IconStyle = $Enums.IconStyle

export const IconStyle: typeof $Enums.IconStyle

export type IconColor = $Enums.IconColor

export const IconColor: typeof $Enums.IconColor

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationSettings`: Exposes CRUD operations for the **NotificationSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationSettings
    * const notificationSettings = await prisma.notificationSettings.findMany()
    * ```
    */
  get notificationSettings(): Prisma.NotificationSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userLink`: Exposes CRUD operations for the **UserLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserLinks
    * const userLinks = await prisma.userLink.findMany()
    * ```
    */
  get userLink(): Prisma.UserLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userYoutubeSettings`: Exposes CRUD operations for the **UserYoutubeSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserYoutubeSettings
    * const userYoutubeSettings = await prisma.userYoutubeSettings.findMany()
    * ```
    */
  get userYoutubeSettings(): Prisma.UserYoutubeSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userImageBanner`: Exposes CRUD operations for the **UserImageBanner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserImageBanners
    * const userImageBanners = await prisma.userImageBanner.findMany()
    * ```
    */
  get userImageBanner(): Prisma.UserImageBannerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userYoutubeVideo`: Exposes CRUD operations for the **UserYoutubeVideo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserYoutubeVideos
    * const userYoutubeVideos = await prisma.userYoutubeVideo.findMany()
    * ```
    */
  get userYoutubeVideo(): Prisma.UserYoutubeVideoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userRecommendYoutube`: Exposes CRUD operations for the **UserRecommendYoutube** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRecommendYoutubes
    * const userRecommendYoutubes = await prisma.userRecommendYoutube.findMany()
    * ```
    */
  get userRecommendYoutube(): Prisma.UserRecommendYoutubeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPopupSettings`: Exposes CRUD operations for the **UserPopupSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPopupSettings
    * const userPopupSettings = await prisma.userPopupSettings.findMany()
    * ```
    */
  get userPopupSettings(): Prisma.UserPopupSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userOGP`: Exposes CRUD operations for the **UserOGP** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserOGPS
    * const userOGPS = await prisma.userOGP.findMany()
    * ```
    */
  get userOGP(): Prisma.UserOGPDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userCustomQuestion`: Exposes CRUD operations for the **UserCustomQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserCustomQuestions
    * const userCustomQuestions = await prisma.userCustomQuestion.findMany()
    * ```
    */
  get userCustomQuestion(): Prisma.UserCustomQuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userImageCarousel`: Exposes CRUD operations for the **UserImageCarousel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserImageCarousels
    * const userImageCarousels = await prisma.userImageCarousel.findMany()
    * ```
    */
  get userImageCarousel(): Prisma.UserImageCarouselDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userImageSidebar`: Exposes CRUD operations for the **UserImageSidebar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserImageSidebars
    * const userImageSidebars = await prisma.userImageSidebar.findMany()
    * ```
    */
  get userImageSidebar(): Prisma.UserImageSidebarDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userDisplaySettings`: Exposes CRUD operations for the **UserDisplaySettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserDisplaySettings
    * const userDisplaySettings = await prisma.userDisplaySettings.findMany()
    * ```
    */
  get userDisplaySettings(): Prisma.UserDisplaySettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.linkService`: Exposes CRUD operations for the **LinkService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LinkServices
    * const linkServices = await prisma.linkService.findMany()
    * ```
    */
  get linkService(): Prisma.LinkServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceIcon`: Exposes CRUD operations for the **ServiceIcon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceIcons
    * const serviceIcons = await prisma.serviceIcon.findMany()
    * ```
    */
  get serviceIcon(): Prisma.ServiceIconDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.author`: Exposes CRUD operations for the **Author** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Authors
    * const authors = await prisma.author.findMany()
    * ```
    */
  get author(): Prisma.AuthorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.article`: Exposes CRUD operations for the **Article** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Articles
    * const articles = await prisma.article.findMany()
    * ```
    */
  get article(): Prisma.ArticleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.articleCategory`: Exposes CRUD operations for the **ArticleCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ArticleCategories
    * const articleCategories = await prisma.articleCategory.findMany()
    * ```
    */
  get articleCategory(): Prisma.ArticleCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.articleTag`: Exposes CRUD operations for the **ArticleTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ArticleTags
    * const articleTags = await prisma.articleTag.findMany()
    * ```
    */
  get articleTag(): Prisma.ArticleTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Account: 'Account',
    Session: 'Session',
    NotificationSettings: 'NotificationSettings',
    UserLink: 'UserLink',
    UserYoutubeSettings: 'UserYoutubeSettings',
    UserImageBanner: 'UserImageBanner',
    UserYoutubeVideo: 'UserYoutubeVideo',
    UserRecommendYoutube: 'UserRecommendYoutube',
    UserPopupSettings: 'UserPopupSettings',
    UserOGP: 'UserOGP',
    UserCustomQuestion: 'UserCustomQuestion',
    UserImageCarousel: 'UserImageCarousel',
    UserImageSidebar: 'UserImageSidebar',
    UserDisplaySettings: 'UserDisplaySettings',
    LinkService: 'LinkService',
    ServiceIcon: 'ServiceIcon',
    VerificationToken: 'VerificationToken',
    Author: 'Author',
    Category: 'Category',
    Tag: 'Tag',
    Article: 'Article',
    ArticleCategory: 'ArticleCategory',
    ArticleTag: 'ArticleTag',
    Comment: 'Comment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "account" | "session" | "notificationSettings" | "userLink" | "userYoutubeSettings" | "userImageBanner" | "userYoutubeVideo" | "userRecommendYoutube" | "userPopupSettings" | "userOGP" | "userCustomQuestion" | "userImageCarousel" | "userImageSidebar" | "userDisplaySettings" | "linkService" | "serviceIcon" | "verificationToken" | "author" | "category" | "tag" | "article" | "articleCategory" | "articleTag" | "comment"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      NotificationSettings: {
        payload: Prisma.$NotificationSettingsPayload<ExtArgs>
        fields: Prisma.NotificationSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          findFirst: {
            args: Prisma.NotificationSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          findMany: {
            args: Prisma.NotificationSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>[]
          }
          create: {
            args: Prisma.NotificationSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          createMany: {
            args: Prisma.NotificationSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>[]
          }
          delete: {
            args: Prisma.NotificationSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          update: {
            args: Prisma.NotificationSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          deleteMany: {
            args: Prisma.NotificationSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>[]
          }
          upsert: {
            args: Prisma.NotificationSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          aggregate: {
            args: Prisma.NotificationSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationSettings>
          }
          groupBy: {
            args: Prisma.NotificationSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationSettingsCountAggregateOutputType> | number
          }
        }
      }
      UserLink: {
        payload: Prisma.$UserLinkPayload<ExtArgs>
        fields: Prisma.UserLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLinkPayload>
          }
          findFirst: {
            args: Prisma.UserLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLinkPayload>
          }
          findMany: {
            args: Prisma.UserLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLinkPayload>[]
          }
          create: {
            args: Prisma.UserLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLinkPayload>
          }
          createMany: {
            args: Prisma.UserLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLinkPayload>[]
          }
          delete: {
            args: Prisma.UserLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLinkPayload>
          }
          update: {
            args: Prisma.UserLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLinkPayload>
          }
          deleteMany: {
            args: Prisma.UserLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserLinkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLinkPayload>[]
          }
          upsert: {
            args: Prisma.UserLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLinkPayload>
          }
          aggregate: {
            args: Prisma.UserLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserLink>
          }
          groupBy: {
            args: Prisma.UserLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserLinkCountArgs<ExtArgs>
            result: $Utils.Optional<UserLinkCountAggregateOutputType> | number
          }
        }
      }
      UserYoutubeSettings: {
        payload: Prisma.$UserYoutubeSettingsPayload<ExtArgs>
        fields: Prisma.UserYoutubeSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserYoutubeSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserYoutubeSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserYoutubeSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserYoutubeSettingsPayload>
          }
          findFirst: {
            args: Prisma.UserYoutubeSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserYoutubeSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserYoutubeSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserYoutubeSettingsPayload>
          }
          findMany: {
            args: Prisma.UserYoutubeSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserYoutubeSettingsPayload>[]
          }
          create: {
            args: Prisma.UserYoutubeSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserYoutubeSettingsPayload>
          }
          createMany: {
            args: Prisma.UserYoutubeSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserYoutubeSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserYoutubeSettingsPayload>[]
          }
          delete: {
            args: Prisma.UserYoutubeSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserYoutubeSettingsPayload>
          }
          update: {
            args: Prisma.UserYoutubeSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserYoutubeSettingsPayload>
          }
          deleteMany: {
            args: Prisma.UserYoutubeSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserYoutubeSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserYoutubeSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserYoutubeSettingsPayload>[]
          }
          upsert: {
            args: Prisma.UserYoutubeSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserYoutubeSettingsPayload>
          }
          aggregate: {
            args: Prisma.UserYoutubeSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserYoutubeSettings>
          }
          groupBy: {
            args: Prisma.UserYoutubeSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserYoutubeSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserYoutubeSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<UserYoutubeSettingsCountAggregateOutputType> | number
          }
        }
      }
      UserImageBanner: {
        payload: Prisma.$UserImageBannerPayload<ExtArgs>
        fields: Prisma.UserImageBannerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserImageBannerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserImageBannerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserImageBannerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserImageBannerPayload>
          }
          findFirst: {
            args: Prisma.UserImageBannerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserImageBannerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserImageBannerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserImageBannerPayload>
          }
          findMany: {
            args: Prisma.UserImageBannerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserImageBannerPayload>[]
          }
          create: {
            args: Prisma.UserImageBannerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserImageBannerPayload>
          }
          createMany: {
            args: Prisma.UserImageBannerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserImageBannerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserImageBannerPayload>[]
          }
          delete: {
            args: Prisma.UserImageBannerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserImageBannerPayload>
          }
          update: {
            args: Prisma.UserImageBannerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserImageBannerPayload>
          }
          deleteMany: {
            args: Prisma.UserImageBannerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserImageBannerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserImageBannerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserImageBannerPayload>[]
          }
          upsert: {
            args: Prisma.UserImageBannerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserImageBannerPayload>
          }
          aggregate: {
            args: Prisma.UserImageBannerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserImageBanner>
          }
          groupBy: {
            args: Prisma.UserImageBannerGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserImageBannerGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserImageBannerCountArgs<ExtArgs>
            result: $Utils.Optional<UserImageBannerCountAggregateOutputType> | number
          }
        }
      }
      UserYoutubeVideo: {
        payload: Prisma.$UserYoutubeVideoPayload<ExtArgs>
        fields: Prisma.UserYoutubeVideoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserYoutubeVideoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserYoutubeVideoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserYoutubeVideoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserYoutubeVideoPayload>
          }
          findFirst: {
            args: Prisma.UserYoutubeVideoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserYoutubeVideoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserYoutubeVideoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserYoutubeVideoPayload>
          }
          findMany: {
            args: Prisma.UserYoutubeVideoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserYoutubeVideoPayload>[]
          }
          create: {
            args: Prisma.UserYoutubeVideoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserYoutubeVideoPayload>
          }
          createMany: {
            args: Prisma.UserYoutubeVideoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserYoutubeVideoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserYoutubeVideoPayload>[]
          }
          delete: {
            args: Prisma.UserYoutubeVideoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserYoutubeVideoPayload>
          }
          update: {
            args: Prisma.UserYoutubeVideoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserYoutubeVideoPayload>
          }
          deleteMany: {
            args: Prisma.UserYoutubeVideoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserYoutubeVideoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserYoutubeVideoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserYoutubeVideoPayload>[]
          }
          upsert: {
            args: Prisma.UserYoutubeVideoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserYoutubeVideoPayload>
          }
          aggregate: {
            args: Prisma.UserYoutubeVideoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserYoutubeVideo>
          }
          groupBy: {
            args: Prisma.UserYoutubeVideoGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserYoutubeVideoGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserYoutubeVideoCountArgs<ExtArgs>
            result: $Utils.Optional<UserYoutubeVideoCountAggregateOutputType> | number
          }
        }
      }
      UserRecommendYoutube: {
        payload: Prisma.$UserRecommendYoutubePayload<ExtArgs>
        fields: Prisma.UserRecommendYoutubeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRecommendYoutubeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRecommendYoutubePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRecommendYoutubeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRecommendYoutubePayload>
          }
          findFirst: {
            args: Prisma.UserRecommendYoutubeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRecommendYoutubePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRecommendYoutubeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRecommendYoutubePayload>
          }
          findMany: {
            args: Prisma.UserRecommendYoutubeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRecommendYoutubePayload>[]
          }
          create: {
            args: Prisma.UserRecommendYoutubeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRecommendYoutubePayload>
          }
          createMany: {
            args: Prisma.UserRecommendYoutubeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRecommendYoutubeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRecommendYoutubePayload>[]
          }
          delete: {
            args: Prisma.UserRecommendYoutubeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRecommendYoutubePayload>
          }
          update: {
            args: Prisma.UserRecommendYoutubeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRecommendYoutubePayload>
          }
          deleteMany: {
            args: Prisma.UserRecommendYoutubeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRecommendYoutubeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserRecommendYoutubeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRecommendYoutubePayload>[]
          }
          upsert: {
            args: Prisma.UserRecommendYoutubeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRecommendYoutubePayload>
          }
          aggregate: {
            args: Prisma.UserRecommendYoutubeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRecommendYoutube>
          }
          groupBy: {
            args: Prisma.UserRecommendYoutubeGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRecommendYoutubeGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRecommendYoutubeCountArgs<ExtArgs>
            result: $Utils.Optional<UserRecommendYoutubeCountAggregateOutputType> | number
          }
        }
      }
      UserPopupSettings: {
        payload: Prisma.$UserPopupSettingsPayload<ExtArgs>
        fields: Prisma.UserPopupSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPopupSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPopupSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPopupSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPopupSettingsPayload>
          }
          findFirst: {
            args: Prisma.UserPopupSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPopupSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPopupSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPopupSettingsPayload>
          }
          findMany: {
            args: Prisma.UserPopupSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPopupSettingsPayload>[]
          }
          create: {
            args: Prisma.UserPopupSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPopupSettingsPayload>
          }
          createMany: {
            args: Prisma.UserPopupSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPopupSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPopupSettingsPayload>[]
          }
          delete: {
            args: Prisma.UserPopupSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPopupSettingsPayload>
          }
          update: {
            args: Prisma.UserPopupSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPopupSettingsPayload>
          }
          deleteMany: {
            args: Prisma.UserPopupSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPopupSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPopupSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPopupSettingsPayload>[]
          }
          upsert: {
            args: Prisma.UserPopupSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPopupSettingsPayload>
          }
          aggregate: {
            args: Prisma.UserPopupSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPopupSettings>
          }
          groupBy: {
            args: Prisma.UserPopupSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPopupSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPopupSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<UserPopupSettingsCountAggregateOutputType> | number
          }
        }
      }
      UserOGP: {
        payload: Prisma.$UserOGPPayload<ExtArgs>
        fields: Prisma.UserOGPFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserOGPFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOGPPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserOGPFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOGPPayload>
          }
          findFirst: {
            args: Prisma.UserOGPFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOGPPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserOGPFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOGPPayload>
          }
          findMany: {
            args: Prisma.UserOGPFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOGPPayload>[]
          }
          create: {
            args: Prisma.UserOGPCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOGPPayload>
          }
          createMany: {
            args: Prisma.UserOGPCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserOGPCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOGPPayload>[]
          }
          delete: {
            args: Prisma.UserOGPDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOGPPayload>
          }
          update: {
            args: Prisma.UserOGPUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOGPPayload>
          }
          deleteMany: {
            args: Prisma.UserOGPDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserOGPUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserOGPUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOGPPayload>[]
          }
          upsert: {
            args: Prisma.UserOGPUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOGPPayload>
          }
          aggregate: {
            args: Prisma.UserOGPAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserOGP>
          }
          groupBy: {
            args: Prisma.UserOGPGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserOGPGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserOGPCountArgs<ExtArgs>
            result: $Utils.Optional<UserOGPCountAggregateOutputType> | number
          }
        }
      }
      UserCustomQuestion: {
        payload: Prisma.$UserCustomQuestionPayload<ExtArgs>
        fields: Prisma.UserCustomQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserCustomQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCustomQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserCustomQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCustomQuestionPayload>
          }
          findFirst: {
            args: Prisma.UserCustomQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCustomQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserCustomQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCustomQuestionPayload>
          }
          findMany: {
            args: Prisma.UserCustomQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCustomQuestionPayload>[]
          }
          create: {
            args: Prisma.UserCustomQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCustomQuestionPayload>
          }
          createMany: {
            args: Prisma.UserCustomQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCustomQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCustomQuestionPayload>[]
          }
          delete: {
            args: Prisma.UserCustomQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCustomQuestionPayload>
          }
          update: {
            args: Prisma.UserCustomQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCustomQuestionPayload>
          }
          deleteMany: {
            args: Prisma.UserCustomQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserCustomQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserCustomQuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCustomQuestionPayload>[]
          }
          upsert: {
            args: Prisma.UserCustomQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCustomQuestionPayload>
          }
          aggregate: {
            args: Prisma.UserCustomQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserCustomQuestion>
          }
          groupBy: {
            args: Prisma.UserCustomQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserCustomQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCustomQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<UserCustomQuestionCountAggregateOutputType> | number
          }
        }
      }
      UserImageCarousel: {
        payload: Prisma.$UserImageCarouselPayload<ExtArgs>
        fields: Prisma.UserImageCarouselFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserImageCarouselFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserImageCarouselPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserImageCarouselFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserImageCarouselPayload>
          }
          findFirst: {
            args: Prisma.UserImageCarouselFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserImageCarouselPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserImageCarouselFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserImageCarouselPayload>
          }
          findMany: {
            args: Prisma.UserImageCarouselFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserImageCarouselPayload>[]
          }
          create: {
            args: Prisma.UserImageCarouselCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserImageCarouselPayload>
          }
          createMany: {
            args: Prisma.UserImageCarouselCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserImageCarouselCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserImageCarouselPayload>[]
          }
          delete: {
            args: Prisma.UserImageCarouselDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserImageCarouselPayload>
          }
          update: {
            args: Prisma.UserImageCarouselUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserImageCarouselPayload>
          }
          deleteMany: {
            args: Prisma.UserImageCarouselDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserImageCarouselUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserImageCarouselUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserImageCarouselPayload>[]
          }
          upsert: {
            args: Prisma.UserImageCarouselUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserImageCarouselPayload>
          }
          aggregate: {
            args: Prisma.UserImageCarouselAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserImageCarousel>
          }
          groupBy: {
            args: Prisma.UserImageCarouselGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserImageCarouselGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserImageCarouselCountArgs<ExtArgs>
            result: $Utils.Optional<UserImageCarouselCountAggregateOutputType> | number
          }
        }
      }
      UserImageSidebar: {
        payload: Prisma.$UserImageSidebarPayload<ExtArgs>
        fields: Prisma.UserImageSidebarFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserImageSidebarFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserImageSidebarPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserImageSidebarFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserImageSidebarPayload>
          }
          findFirst: {
            args: Prisma.UserImageSidebarFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserImageSidebarPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserImageSidebarFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserImageSidebarPayload>
          }
          findMany: {
            args: Prisma.UserImageSidebarFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserImageSidebarPayload>[]
          }
          create: {
            args: Prisma.UserImageSidebarCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserImageSidebarPayload>
          }
          createMany: {
            args: Prisma.UserImageSidebarCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserImageSidebarCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserImageSidebarPayload>[]
          }
          delete: {
            args: Prisma.UserImageSidebarDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserImageSidebarPayload>
          }
          update: {
            args: Prisma.UserImageSidebarUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserImageSidebarPayload>
          }
          deleteMany: {
            args: Prisma.UserImageSidebarDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserImageSidebarUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserImageSidebarUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserImageSidebarPayload>[]
          }
          upsert: {
            args: Prisma.UserImageSidebarUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserImageSidebarPayload>
          }
          aggregate: {
            args: Prisma.UserImageSidebarAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserImageSidebar>
          }
          groupBy: {
            args: Prisma.UserImageSidebarGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserImageSidebarGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserImageSidebarCountArgs<ExtArgs>
            result: $Utils.Optional<UserImageSidebarCountAggregateOutputType> | number
          }
        }
      }
      UserDisplaySettings: {
        payload: Prisma.$UserDisplaySettingsPayload<ExtArgs>
        fields: Prisma.UserDisplaySettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserDisplaySettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDisplaySettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserDisplaySettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDisplaySettingsPayload>
          }
          findFirst: {
            args: Prisma.UserDisplaySettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDisplaySettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserDisplaySettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDisplaySettingsPayload>
          }
          findMany: {
            args: Prisma.UserDisplaySettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDisplaySettingsPayload>[]
          }
          create: {
            args: Prisma.UserDisplaySettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDisplaySettingsPayload>
          }
          createMany: {
            args: Prisma.UserDisplaySettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserDisplaySettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDisplaySettingsPayload>[]
          }
          delete: {
            args: Prisma.UserDisplaySettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDisplaySettingsPayload>
          }
          update: {
            args: Prisma.UserDisplaySettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDisplaySettingsPayload>
          }
          deleteMany: {
            args: Prisma.UserDisplaySettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserDisplaySettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserDisplaySettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDisplaySettingsPayload>[]
          }
          upsert: {
            args: Prisma.UserDisplaySettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDisplaySettingsPayload>
          }
          aggregate: {
            args: Prisma.UserDisplaySettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserDisplaySettings>
          }
          groupBy: {
            args: Prisma.UserDisplaySettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserDisplaySettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserDisplaySettingsCountArgs<ExtArgs>
            result: $Utils.Optional<UserDisplaySettingsCountAggregateOutputType> | number
          }
        }
      }
      LinkService: {
        payload: Prisma.$LinkServicePayload<ExtArgs>
        fields: Prisma.LinkServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LinkServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LinkServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkServicePayload>
          }
          findFirst: {
            args: Prisma.LinkServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LinkServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkServicePayload>
          }
          findMany: {
            args: Prisma.LinkServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkServicePayload>[]
          }
          create: {
            args: Prisma.LinkServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkServicePayload>
          }
          createMany: {
            args: Prisma.LinkServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LinkServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkServicePayload>[]
          }
          delete: {
            args: Prisma.LinkServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkServicePayload>
          }
          update: {
            args: Prisma.LinkServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkServicePayload>
          }
          deleteMany: {
            args: Prisma.LinkServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LinkServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LinkServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkServicePayload>[]
          }
          upsert: {
            args: Prisma.LinkServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkServicePayload>
          }
          aggregate: {
            args: Prisma.LinkServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLinkService>
          }
          groupBy: {
            args: Prisma.LinkServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<LinkServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.LinkServiceCountArgs<ExtArgs>
            result: $Utils.Optional<LinkServiceCountAggregateOutputType> | number
          }
        }
      }
      ServiceIcon: {
        payload: Prisma.$ServiceIconPayload<ExtArgs>
        fields: Prisma.ServiceIconFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceIconFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceIconPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceIconFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceIconPayload>
          }
          findFirst: {
            args: Prisma.ServiceIconFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceIconPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceIconFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceIconPayload>
          }
          findMany: {
            args: Prisma.ServiceIconFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceIconPayload>[]
          }
          create: {
            args: Prisma.ServiceIconCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceIconPayload>
          }
          createMany: {
            args: Prisma.ServiceIconCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceIconCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceIconPayload>[]
          }
          delete: {
            args: Prisma.ServiceIconDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceIconPayload>
          }
          update: {
            args: Prisma.ServiceIconUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceIconPayload>
          }
          deleteMany: {
            args: Prisma.ServiceIconDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceIconUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceIconUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceIconPayload>[]
          }
          upsert: {
            args: Prisma.ServiceIconUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceIconPayload>
          }
          aggregate: {
            args: Prisma.ServiceIconAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceIcon>
          }
          groupBy: {
            args: Prisma.ServiceIconGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceIconGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceIconCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceIconCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      Author: {
        payload: Prisma.$AuthorPayload<ExtArgs>
        fields: Prisma.AuthorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuthorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuthorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>
          }
          findFirst: {
            args: Prisma.AuthorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuthorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>
          }
          findMany: {
            args: Prisma.AuthorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>[]
          }
          create: {
            args: Prisma.AuthorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>
          }
          createMany: {
            args: Prisma.AuthorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuthorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>[]
          }
          delete: {
            args: Prisma.AuthorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>
          }
          update: {
            args: Prisma.AuthorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>
          }
          deleteMany: {
            args: Prisma.AuthorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuthorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuthorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>[]
          }
          upsert: {
            args: Prisma.AuthorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>
          }
          aggregate: {
            args: Prisma.AuthorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuthor>
          }
          groupBy: {
            args: Prisma.AuthorGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuthorGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuthorCountArgs<ExtArgs>
            result: $Utils.Optional<AuthorCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      Article: {
        payload: Prisma.$ArticlePayload<ExtArgs>
        fields: Prisma.ArticleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArticleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArticleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          findFirst: {
            args: Prisma.ArticleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArticleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          findMany: {
            args: Prisma.ArticleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>[]
          }
          create: {
            args: Prisma.ArticleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          createMany: {
            args: Prisma.ArticleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArticleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>[]
          }
          delete: {
            args: Prisma.ArticleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          update: {
            args: Prisma.ArticleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          deleteMany: {
            args: Prisma.ArticleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArticleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ArticleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>[]
          }
          upsert: {
            args: Prisma.ArticleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticlePayload>
          }
          aggregate: {
            args: Prisma.ArticleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArticle>
          }
          groupBy: {
            args: Prisma.ArticleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArticleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArticleCountArgs<ExtArgs>
            result: $Utils.Optional<ArticleCountAggregateOutputType> | number
          }
        }
      }
      ArticleCategory: {
        payload: Prisma.$ArticleCategoryPayload<ExtArgs>
        fields: Prisma.ArticleCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArticleCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArticleCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleCategoryPayload>
          }
          findFirst: {
            args: Prisma.ArticleCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArticleCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleCategoryPayload>
          }
          findMany: {
            args: Prisma.ArticleCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleCategoryPayload>[]
          }
          create: {
            args: Prisma.ArticleCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleCategoryPayload>
          }
          createMany: {
            args: Prisma.ArticleCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArticleCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleCategoryPayload>[]
          }
          delete: {
            args: Prisma.ArticleCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleCategoryPayload>
          }
          update: {
            args: Prisma.ArticleCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ArticleCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArticleCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ArticleCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ArticleCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleCategoryPayload>
          }
          aggregate: {
            args: Prisma.ArticleCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArticleCategory>
          }
          groupBy: {
            args: Prisma.ArticleCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArticleCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArticleCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ArticleCategoryCountAggregateOutputType> | number
          }
        }
      }
      ArticleTag: {
        payload: Prisma.$ArticleTagPayload<ExtArgs>
        fields: Prisma.ArticleTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArticleTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArticleTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleTagPayload>
          }
          findFirst: {
            args: Prisma.ArticleTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArticleTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleTagPayload>
          }
          findMany: {
            args: Prisma.ArticleTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleTagPayload>[]
          }
          create: {
            args: Prisma.ArticleTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleTagPayload>
          }
          createMany: {
            args: Prisma.ArticleTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArticleTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleTagPayload>[]
          }
          delete: {
            args: Prisma.ArticleTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleTagPayload>
          }
          update: {
            args: Prisma.ArticleTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleTagPayload>
          }
          deleteMany: {
            args: Prisma.ArticleTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArticleTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ArticleTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleTagPayload>[]
          }
          upsert: {
            args: Prisma.ArticleTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleTagPayload>
          }
          aggregate: {
            args: Prisma.ArticleTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArticleTag>
          }
          groupBy: {
            args: Prisma.ArticleTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArticleTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArticleTagCountArgs<ExtArgs>
            result: $Utils.Optional<ArticleTagCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    account?: AccountOmit
    session?: SessionOmit
    notificationSettings?: NotificationSettingsOmit
    userLink?: UserLinkOmit
    userYoutubeSettings?: UserYoutubeSettingsOmit
    userImageBanner?: UserImageBannerOmit
    userYoutubeVideo?: UserYoutubeVideoOmit
    userRecommendYoutube?: UserRecommendYoutubeOmit
    userPopupSettings?: UserPopupSettingsOmit
    userOGP?: UserOGPOmit
    userCustomQuestion?: UserCustomQuestionOmit
    userImageCarousel?: UserImageCarouselOmit
    userImageSidebar?: UserImageSidebarOmit
    userDisplaySettings?: UserDisplaySettingsOmit
    linkService?: LinkServiceOmit
    serviceIcon?: ServiceIconOmit
    verificationToken?: VerificationTokenOmit
    author?: AuthorOmit
    category?: CategoryOmit
    tag?: TagOmit
    article?: ArticleOmit
    articleCategory?: ArticleCategoryOmit
    articleTag?: ArticleTagOmit
    comment?: CommentOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
    links: number
    imageBanners: number
    imageCarousels: number
    imageSidebars: number
    customQuestions: number
    recommendYoutubes: number
    comments: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    links?: boolean | UserCountOutputTypeCountLinksArgs
    imageBanners?: boolean | UserCountOutputTypeCountImageBannersArgs
    imageCarousels?: boolean | UserCountOutputTypeCountImageCarouselsArgs
    imageSidebars?: boolean | UserCountOutputTypeCountImageSidebarsArgs
    customQuestions?: boolean | UserCountOutputTypeCountCustomQuestionsArgs
    recommendYoutubes?: boolean | UserCountOutputTypeCountRecommendYoutubesArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLinkWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountImageBannersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserImageBannerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountImageCarouselsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserImageCarouselWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountImageSidebarsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserImageSidebarWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCustomQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCustomQuestionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRecommendYoutubesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRecommendYoutubeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type UserYoutubeSettingsCountOutputType
   */

  export type UserYoutubeSettingsCountOutputType = {
    videos: number
  }

  export type UserYoutubeSettingsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    videos?: boolean | UserYoutubeSettingsCountOutputTypeCountVideosArgs
  }

  // Custom InputTypes
  /**
   * UserYoutubeSettingsCountOutputType without action
   */
  export type UserYoutubeSettingsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserYoutubeSettingsCountOutputType
     */
    select?: UserYoutubeSettingsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserYoutubeSettingsCountOutputType without action
   */
  export type UserYoutubeSettingsCountOutputTypeCountVideosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserYoutubeVideoWhereInput
  }


  /**
   * Count Type LinkServiceCountOutputType
   */

  export type LinkServiceCountOutputType = {
    icons: number
    links: number
  }

  export type LinkServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    icons?: boolean | LinkServiceCountOutputTypeCountIconsArgs
    links?: boolean | LinkServiceCountOutputTypeCountLinksArgs
  }

  // Custom InputTypes
  /**
   * LinkServiceCountOutputType without action
   */
  export type LinkServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkServiceCountOutputType
     */
    select?: LinkServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LinkServiceCountOutputType without action
   */
  export type LinkServiceCountOutputTypeCountIconsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceIconWhereInput
  }

  /**
   * LinkServiceCountOutputType without action
   */
  export type LinkServiceCountOutputTypeCountLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLinkWhereInput
  }


  /**
   * Count Type ServiceIconCountOutputType
   */

  export type ServiceIconCountOutputType = {
    links: number
  }

  export type ServiceIconCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    links?: boolean | ServiceIconCountOutputTypeCountLinksArgs
  }

  // Custom InputTypes
  /**
   * ServiceIconCountOutputType without action
   */
  export type ServiceIconCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceIconCountOutputType
     */
    select?: ServiceIconCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceIconCountOutputType without action
   */
  export type ServiceIconCountOutputTypeCountLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLinkWhereInput
  }


  /**
   * Count Type AuthorCountOutputType
   */

  export type AuthorCountOutputType = {
    articles: number
  }

  export type AuthorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    articles?: boolean | AuthorCountOutputTypeCountArticlesArgs
  }

  // Custom InputTypes
  /**
   * AuthorCountOutputType without action
   */
  export type AuthorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorCountOutputType
     */
    select?: AuthorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AuthorCountOutputType without action
   */
  export type AuthorCountOutputTypeCountArticlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArticleWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    children: number
    articles: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | CategoryCountOutputTypeCountChildrenArgs
    articles?: boolean | CategoryCountOutputTypeCountArticlesArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountArticlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArticleCategoryWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    articles: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    articles?: boolean | TagCountOutputTypeCountArticlesArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountArticlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArticleTagWhereInput
  }


  /**
   * Count Type ArticleCountOutputType
   */

  export type ArticleCountOutputType = {
    categories: number
    tags: number
    comments: number
  }

  export type ArticleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | ArticleCountOutputTypeCountCategoriesArgs
    tags?: boolean | ArticleCountOutputTypeCountTagsArgs
    comments?: boolean | ArticleCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * ArticleCountOutputType without action
   */
  export type ArticleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleCountOutputType
     */
    select?: ArticleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ArticleCountOutputType without action
   */
  export type ArticleCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArticleCategoryWhereInput
  }

  /**
   * ArticleCountOutputType without action
   */
  export type ArticleCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArticleTagWhereInput
  }

  /**
   * ArticleCountOutputType without action
   */
  export type ArticleCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    children: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | CommentCountOutputTypeCountChildrenArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    handleChangeCount: number | null
    handleChangeTokens: number | null
  }

  export type UserSumAggregateOutputType = {
    handleChangeCount: number | null
    handleChangeTokens: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    characterName: string | null
    subname: string | null
    bio: string | null
    birthday: Date | null
    gender: string | null
    iconUrl: string | null
    bannerUrl: string | null
    handle: string | null
    handleChangeCount: number | null
    handleChangeTokens: number | null
    isPremiumUser: boolean | null
    role: string | null
    subscriptionStatus: string | null
    emailVerified: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    characterName: string | null
    subname: string | null
    bio: string | null
    birthday: Date | null
    gender: string | null
    iconUrl: string | null
    bannerUrl: string | null
    handle: string | null
    handleChangeCount: number | null
    handleChangeTokens: number | null
    isPremiumUser: boolean | null
    role: string | null
    subscriptionStatus: string | null
    emailVerified: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    characterName: number
    subname: number
    bio: number
    birthday: number
    gender: number
    iconUrl: number
    bannerUrl: number
    handle: number
    handleChangeCount: number
    handleChangeTokens: number
    isPremiumUser: number
    role: number
    subscriptionStatus: number
    emailVerified: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    handleChangeCount?: true
    handleChangeTokens?: true
  }

  export type UserSumAggregateInputType = {
    handleChangeCount?: true
    handleChangeTokens?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    characterName?: true
    subname?: true
    bio?: true
    birthday?: true
    gender?: true
    iconUrl?: true
    bannerUrl?: true
    handle?: true
    handleChangeCount?: true
    handleChangeTokens?: true
    isPremiumUser?: true
    role?: true
    subscriptionStatus?: true
    emailVerified?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    characterName?: true
    subname?: true
    bio?: true
    birthday?: true
    gender?: true
    iconUrl?: true
    bannerUrl?: true
    handle?: true
    handleChangeCount?: true
    handleChangeTokens?: true
    isPremiumUser?: true
    role?: true
    subscriptionStatus?: true
    emailVerified?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    characterName?: true
    subname?: true
    bio?: true
    birthday?: true
    gender?: true
    iconUrl?: true
    bannerUrl?: true
    handle?: true
    handleChangeCount?: true
    handleChangeTokens?: true
    isPremiumUser?: true
    role?: true
    subscriptionStatus?: true
    emailVerified?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string | null
    characterName: string | null
    subname: string | null
    bio: string | null
    birthday: Date | null
    gender: string | null
    iconUrl: string | null
    bannerUrl: string | null
    handle: string | null
    handleChangeCount: number
    handleChangeTokens: number
    isPremiumUser: boolean
    role: string
    subscriptionStatus: string | null
    emailVerified: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    characterName?: boolean
    subname?: boolean
    bio?: boolean
    birthday?: boolean
    gender?: boolean
    iconUrl?: boolean
    bannerUrl?: boolean
    handle?: boolean
    handleChangeCount?: boolean
    handleChangeTokens?: boolean
    isPremiumUser?: boolean
    role?: boolean
    subscriptionStatus?: boolean
    emailVerified?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    ogp?: boolean | User$ogpArgs<ExtArgs>
    links?: boolean | User$linksArgs<ExtArgs>
    imageBanners?: boolean | User$imageBannersArgs<ExtArgs>
    imageCarousels?: boolean | User$imageCarouselsArgs<ExtArgs>
    imageSidebars?: boolean | User$imageSidebarsArgs<ExtArgs>
    customQuestions?: boolean | User$customQuestionsArgs<ExtArgs>
    youtubeSettings?: boolean | User$youtubeSettingsArgs<ExtArgs>
    recommendYoutubes?: boolean | User$recommendYoutubesArgs<ExtArgs>
    popupSettings?: boolean | User$popupSettingsArgs<ExtArgs>
    displaySettings?: boolean | User$displaySettingsArgs<ExtArgs>
    notificationSettings?: boolean | User$notificationSettingsArgs<ExtArgs>
    author?: boolean | User$authorArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    characterName?: boolean
    subname?: boolean
    bio?: boolean
    birthday?: boolean
    gender?: boolean
    iconUrl?: boolean
    bannerUrl?: boolean
    handle?: boolean
    handleChangeCount?: boolean
    handleChangeTokens?: boolean
    isPremiumUser?: boolean
    role?: boolean
    subscriptionStatus?: boolean
    emailVerified?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    characterName?: boolean
    subname?: boolean
    bio?: boolean
    birthday?: boolean
    gender?: boolean
    iconUrl?: boolean
    bannerUrl?: boolean
    handle?: boolean
    handleChangeCount?: boolean
    handleChangeTokens?: boolean
    isPremiumUser?: boolean
    role?: boolean
    subscriptionStatus?: boolean
    emailVerified?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    characterName?: boolean
    subname?: boolean
    bio?: boolean
    birthday?: boolean
    gender?: boolean
    iconUrl?: boolean
    bannerUrl?: boolean
    handle?: boolean
    handleChangeCount?: boolean
    handleChangeTokens?: boolean
    isPremiumUser?: boolean
    role?: boolean
    subscriptionStatus?: boolean
    emailVerified?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "characterName" | "subname" | "bio" | "birthday" | "gender" | "iconUrl" | "bannerUrl" | "handle" | "handleChangeCount" | "handleChangeTokens" | "isPremiumUser" | "role" | "subscriptionStatus" | "emailVerified" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    ogp?: boolean | User$ogpArgs<ExtArgs>
    links?: boolean | User$linksArgs<ExtArgs>
    imageBanners?: boolean | User$imageBannersArgs<ExtArgs>
    imageCarousels?: boolean | User$imageCarouselsArgs<ExtArgs>
    imageSidebars?: boolean | User$imageSidebarsArgs<ExtArgs>
    customQuestions?: boolean | User$customQuestionsArgs<ExtArgs>
    youtubeSettings?: boolean | User$youtubeSettingsArgs<ExtArgs>
    recommendYoutubes?: boolean | User$recommendYoutubesArgs<ExtArgs>
    popupSettings?: boolean | User$popupSettingsArgs<ExtArgs>
    displaySettings?: boolean | User$displaySettingsArgs<ExtArgs>
    notificationSettings?: boolean | User$notificationSettingsArgs<ExtArgs>
    author?: boolean | User$authorArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      ogp: Prisma.$UserOGPPayload<ExtArgs> | null
      links: Prisma.$UserLinkPayload<ExtArgs>[]
      imageBanners: Prisma.$UserImageBannerPayload<ExtArgs>[]
      imageCarousels: Prisma.$UserImageCarouselPayload<ExtArgs>[]
      imageSidebars: Prisma.$UserImageSidebarPayload<ExtArgs>[]
      customQuestions: Prisma.$UserCustomQuestionPayload<ExtArgs>[]
      youtubeSettings: Prisma.$UserYoutubeSettingsPayload<ExtArgs> | null
      recommendYoutubes: Prisma.$UserRecommendYoutubePayload<ExtArgs>[]
      popupSettings: Prisma.$UserPopupSettingsPayload<ExtArgs> | null
      displaySettings: Prisma.$UserDisplaySettingsPayload<ExtArgs> | null
      notificationSettings: Prisma.$NotificationSettingsPayload<ExtArgs> | null
      author: Prisma.$AuthorPayload<ExtArgs> | null
      comments: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      characterName: string | null
      subname: string | null
      bio: string | null
      birthday: Date | null
      gender: string | null
      iconUrl: string | null
      bannerUrl: string | null
      handle: string | null
      handleChangeCount: number
      handleChangeTokens: number
      isPremiumUser: boolean
      role: string
      subscriptionStatus: string | null
      emailVerified: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ogp<T extends User$ogpArgs<ExtArgs> = {}>(args?: Subset<T, User$ogpArgs<ExtArgs>>): Prisma__UserOGPClient<$Result.GetResult<Prisma.$UserOGPPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    links<T extends User$linksArgs<ExtArgs> = {}>(args?: Subset<T, User$linksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    imageBanners<T extends User$imageBannersArgs<ExtArgs> = {}>(args?: Subset<T, User$imageBannersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserImageBannerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    imageCarousels<T extends User$imageCarouselsArgs<ExtArgs> = {}>(args?: Subset<T, User$imageCarouselsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserImageCarouselPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    imageSidebars<T extends User$imageSidebarsArgs<ExtArgs> = {}>(args?: Subset<T, User$imageSidebarsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserImageSidebarPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customQuestions<T extends User$customQuestionsArgs<ExtArgs> = {}>(args?: Subset<T, User$customQuestionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCustomQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    youtubeSettings<T extends User$youtubeSettingsArgs<ExtArgs> = {}>(args?: Subset<T, User$youtubeSettingsArgs<ExtArgs>>): Prisma__UserYoutubeSettingsClient<$Result.GetResult<Prisma.$UserYoutubeSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    recommendYoutubes<T extends User$recommendYoutubesArgs<ExtArgs> = {}>(args?: Subset<T, User$recommendYoutubesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRecommendYoutubePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    popupSettings<T extends User$popupSettingsArgs<ExtArgs> = {}>(args?: Subset<T, User$popupSettingsArgs<ExtArgs>>): Prisma__UserPopupSettingsClient<$Result.GetResult<Prisma.$UserPopupSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    displaySettings<T extends User$displaySettingsArgs<ExtArgs> = {}>(args?: Subset<T, User$displaySettingsArgs<ExtArgs>>): Prisma__UserDisplaySettingsClient<$Result.GetResult<Prisma.$UserDisplaySettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    notificationSettings<T extends User$notificationSettingsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationSettingsArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    author<T extends User$authorArgs<ExtArgs> = {}>(args?: Subset<T, User$authorArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly characterName: FieldRef<"User", 'String'>
    readonly subname: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
    readonly birthday: FieldRef<"User", 'DateTime'>
    readonly gender: FieldRef<"User", 'String'>
    readonly iconUrl: FieldRef<"User", 'String'>
    readonly bannerUrl: FieldRef<"User", 'String'>
    readonly handle: FieldRef<"User", 'String'>
    readonly handleChangeCount: FieldRef<"User", 'Int'>
    readonly handleChangeTokens: FieldRef<"User", 'Int'>
    readonly isPremiumUser: FieldRef<"User", 'Boolean'>
    readonly role: FieldRef<"User", 'String'>
    readonly subscriptionStatus: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.ogp
   */
  export type User$ogpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOGP
     */
    select?: UserOGPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOGP
     */
    omit?: UserOGPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOGPInclude<ExtArgs> | null
    where?: UserOGPWhereInput
  }

  /**
   * User.links
   */
  export type User$linksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLink
     */
    select?: UserLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLink
     */
    omit?: UserLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLinkInclude<ExtArgs> | null
    where?: UserLinkWhereInput
    orderBy?: UserLinkOrderByWithRelationInput | UserLinkOrderByWithRelationInput[]
    cursor?: UserLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLinkScalarFieldEnum | UserLinkScalarFieldEnum[]
  }

  /**
   * User.imageBanners
   */
  export type User$imageBannersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageBanner
     */
    select?: UserImageBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageBanner
     */
    omit?: UserImageBannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageBannerInclude<ExtArgs> | null
    where?: UserImageBannerWhereInput
    orderBy?: UserImageBannerOrderByWithRelationInput | UserImageBannerOrderByWithRelationInput[]
    cursor?: UserImageBannerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserImageBannerScalarFieldEnum | UserImageBannerScalarFieldEnum[]
  }

  /**
   * User.imageCarousels
   */
  export type User$imageCarouselsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageCarousel
     */
    select?: UserImageCarouselSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageCarousel
     */
    omit?: UserImageCarouselOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageCarouselInclude<ExtArgs> | null
    where?: UserImageCarouselWhereInput
    orderBy?: UserImageCarouselOrderByWithRelationInput | UserImageCarouselOrderByWithRelationInput[]
    cursor?: UserImageCarouselWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserImageCarouselScalarFieldEnum | UserImageCarouselScalarFieldEnum[]
  }

  /**
   * User.imageSidebars
   */
  export type User$imageSidebarsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageSidebar
     */
    select?: UserImageSidebarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageSidebar
     */
    omit?: UserImageSidebarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageSidebarInclude<ExtArgs> | null
    where?: UserImageSidebarWhereInput
    orderBy?: UserImageSidebarOrderByWithRelationInput | UserImageSidebarOrderByWithRelationInput[]
    cursor?: UserImageSidebarWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserImageSidebarScalarFieldEnum | UserImageSidebarScalarFieldEnum[]
  }

  /**
   * User.customQuestions
   */
  export type User$customQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCustomQuestion
     */
    select?: UserCustomQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCustomQuestion
     */
    omit?: UserCustomQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCustomQuestionInclude<ExtArgs> | null
    where?: UserCustomQuestionWhereInput
    orderBy?: UserCustomQuestionOrderByWithRelationInput | UserCustomQuestionOrderByWithRelationInput[]
    cursor?: UserCustomQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCustomQuestionScalarFieldEnum | UserCustomQuestionScalarFieldEnum[]
  }

  /**
   * User.youtubeSettings
   */
  export type User$youtubeSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserYoutubeSettings
     */
    select?: UserYoutubeSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserYoutubeSettings
     */
    omit?: UserYoutubeSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserYoutubeSettingsInclude<ExtArgs> | null
    where?: UserYoutubeSettingsWhereInput
  }

  /**
   * User.recommendYoutubes
   */
  export type User$recommendYoutubesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecommendYoutube
     */
    select?: UserRecommendYoutubeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecommendYoutube
     */
    omit?: UserRecommendYoutubeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRecommendYoutubeInclude<ExtArgs> | null
    where?: UserRecommendYoutubeWhereInput
    orderBy?: UserRecommendYoutubeOrderByWithRelationInput | UserRecommendYoutubeOrderByWithRelationInput[]
    cursor?: UserRecommendYoutubeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRecommendYoutubeScalarFieldEnum | UserRecommendYoutubeScalarFieldEnum[]
  }

  /**
   * User.popupSettings
   */
  export type User$popupSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPopupSettings
     */
    select?: UserPopupSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPopupSettings
     */
    omit?: UserPopupSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPopupSettingsInclude<ExtArgs> | null
    where?: UserPopupSettingsWhereInput
  }

  /**
   * User.displaySettings
   */
  export type User$displaySettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDisplaySettings
     */
    select?: UserDisplaySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDisplaySettings
     */
    omit?: UserDisplaySettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDisplaySettingsInclude<ExtArgs> | null
    where?: UserDisplaySettingsWhereInput
  }

  /**
   * User.notificationSettings
   */
  export type User$notificationSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    where?: NotificationSettingsWhereInput
  }

  /**
   * User.author
   */
  export type User$authorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    where?: AuthorWhereInput
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model NotificationSettings
   */

  export type AggregateNotificationSettings = {
    _count: NotificationSettingsCountAggregateOutputType | null
    _min: NotificationSettingsMinAggregateOutputType | null
    _max: NotificationSettingsMaxAggregateOutputType | null
  }

  export type NotificationSettingsMinAggregateOutputType = {
    id: string | null
    pushNotifications: boolean | null
    userId: string | null
  }

  export type NotificationSettingsMaxAggregateOutputType = {
    id: string | null
    pushNotifications: boolean | null
    userId: string | null
  }

  export type NotificationSettingsCountAggregateOutputType = {
    id: number
    pushNotifications: number
    userId: number
    _all: number
  }


  export type NotificationSettingsMinAggregateInputType = {
    id?: true
    pushNotifications?: true
    userId?: true
  }

  export type NotificationSettingsMaxAggregateInputType = {
    id?: true
    pushNotifications?: true
    userId?: true
  }

  export type NotificationSettingsCountAggregateInputType = {
    id?: true
    pushNotifications?: true
    userId?: true
    _all?: true
  }

  export type NotificationSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationSettings to aggregate.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationSettings
    **/
    _count?: true | NotificationSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationSettingsMaxAggregateInputType
  }

  export type GetNotificationSettingsAggregateType<T extends NotificationSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationSettings[P]>
      : GetScalarType<T[P], AggregateNotificationSettings[P]>
  }




  export type NotificationSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationSettingsWhereInput
    orderBy?: NotificationSettingsOrderByWithAggregationInput | NotificationSettingsOrderByWithAggregationInput[]
    by: NotificationSettingsScalarFieldEnum[] | NotificationSettingsScalarFieldEnum
    having?: NotificationSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationSettingsCountAggregateInputType | true
    _min?: NotificationSettingsMinAggregateInputType
    _max?: NotificationSettingsMaxAggregateInputType
  }

  export type NotificationSettingsGroupByOutputType = {
    id: string
    pushNotifications: boolean
    userId: string
    _count: NotificationSettingsCountAggregateOutputType | null
    _min: NotificationSettingsMinAggregateOutputType | null
    _max: NotificationSettingsMaxAggregateOutputType | null
  }

  type GetNotificationSettingsGroupByPayload<T extends NotificationSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationSettingsGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pushNotifications?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationSettings"]>

  export type NotificationSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pushNotifications?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationSettings"]>

  export type NotificationSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pushNotifications?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationSettings"]>

  export type NotificationSettingsSelectScalar = {
    id?: boolean
    pushNotifications?: boolean
    userId?: boolean
  }

  export type NotificationSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pushNotifications" | "userId", ExtArgs["result"]["notificationSettings"]>
  export type NotificationSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationSettings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      pushNotifications: boolean
      userId: string
    }, ExtArgs["result"]["notificationSettings"]>
    composites: {}
  }

  type NotificationSettingsGetPayload<S extends boolean | null | undefined | NotificationSettingsDefaultArgs> = $Result.GetResult<Prisma.$NotificationSettingsPayload, S>

  type NotificationSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationSettingsCountAggregateInputType | true
    }

  export interface NotificationSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationSettings'], meta: { name: 'NotificationSettings' } }
    /**
     * Find zero or one NotificationSettings that matches the filter.
     * @param {NotificationSettingsFindUniqueArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationSettingsFindUniqueArgs>(args: SelectSubset<T, NotificationSettingsFindUniqueArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationSettingsFindUniqueOrThrowArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsFindFirstArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationSettingsFindFirstArgs>(args?: SelectSubset<T, NotificationSettingsFindFirstArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsFindFirstOrThrowArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findMany()
     * 
     * // Get first 10 NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationSettingsWithIdOnly = await prisma.notificationSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationSettingsFindManyArgs>(args?: SelectSubset<T, NotificationSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationSettings.
     * @param {NotificationSettingsCreateArgs} args - Arguments to create a NotificationSettings.
     * @example
     * // Create one NotificationSettings
     * const NotificationSettings = await prisma.notificationSettings.create({
     *   data: {
     *     // ... data to create a NotificationSettings
     *   }
     * })
     * 
     */
    create<T extends NotificationSettingsCreateArgs>(args: SelectSubset<T, NotificationSettingsCreateArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationSettings.
     * @param {NotificationSettingsCreateManyArgs} args - Arguments to create many NotificationSettings.
     * @example
     * // Create many NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationSettingsCreateManyArgs>(args?: SelectSubset<T, NotificationSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationSettings and returns the data saved in the database.
     * @param {NotificationSettingsCreateManyAndReturnArgs} args - Arguments to create many NotificationSettings.
     * @example
     * // Create many NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationSettings and only return the `id`
     * const notificationSettingsWithIdOnly = await prisma.notificationSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationSettings.
     * @param {NotificationSettingsDeleteArgs} args - Arguments to delete one NotificationSettings.
     * @example
     * // Delete one NotificationSettings
     * const NotificationSettings = await prisma.notificationSettings.delete({
     *   where: {
     *     // ... filter to delete one NotificationSettings
     *   }
     * })
     * 
     */
    delete<T extends NotificationSettingsDeleteArgs>(args: SelectSubset<T, NotificationSettingsDeleteArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationSettings.
     * @param {NotificationSettingsUpdateArgs} args - Arguments to update one NotificationSettings.
     * @example
     * // Update one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationSettingsUpdateArgs>(args: SelectSubset<T, NotificationSettingsUpdateArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationSettings.
     * @param {NotificationSettingsDeleteManyArgs} args - Arguments to filter NotificationSettings to delete.
     * @example
     * // Delete a few NotificationSettings
     * const { count } = await prisma.notificationSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationSettingsDeleteManyArgs>(args?: SelectSubset<T, NotificationSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationSettingsUpdateManyArgs>(args: SelectSubset<T, NotificationSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationSettings and returns the data updated in the database.
     * @param {NotificationSettingsUpdateManyAndReturnArgs} args - Arguments to update many NotificationSettings.
     * @example
     * // Update many NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationSettings and only return the `id`
     * const notificationSettingsWithIdOnly = await prisma.notificationSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationSettings.
     * @param {NotificationSettingsUpsertArgs} args - Arguments to update or create a NotificationSettings.
     * @example
     * // Update or create a NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.upsert({
     *   create: {
     *     // ... data to create a NotificationSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationSettings we want to update
     *   }
     * })
     */
    upsert<T extends NotificationSettingsUpsertArgs>(args: SelectSubset<T, NotificationSettingsUpsertArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsCountArgs} args - Arguments to filter NotificationSettings to count.
     * @example
     * // Count the number of NotificationSettings
     * const count = await prisma.notificationSettings.count({
     *   where: {
     *     // ... the filter for the NotificationSettings we want to count
     *   }
     * })
    **/
    count<T extends NotificationSettingsCountArgs>(
      args?: Subset<T, NotificationSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationSettingsAggregateArgs>(args: Subset<T, NotificationSettingsAggregateArgs>): Prisma.PrismaPromise<GetNotificationSettingsAggregateType<T>>

    /**
     * Group by NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationSettingsGroupByArgs['orderBy'] }
        : { orderBy?: NotificationSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationSettings model
   */
  readonly fields: NotificationSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationSettings model
   */
  interface NotificationSettingsFieldRefs {
    readonly id: FieldRef<"NotificationSettings", 'String'>
    readonly pushNotifications: FieldRef<"NotificationSettings", 'Boolean'>
    readonly userId: FieldRef<"NotificationSettings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * NotificationSettings findUnique
   */
  export type NotificationSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings findUniqueOrThrow
   */
  export type NotificationSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings findFirst
   */
  export type NotificationSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationSettings.
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationSettings.
     */
    distinct?: NotificationSettingsScalarFieldEnum | NotificationSettingsScalarFieldEnum[]
  }

  /**
   * NotificationSettings findFirstOrThrow
   */
  export type NotificationSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationSettings.
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationSettings.
     */
    distinct?: NotificationSettingsScalarFieldEnum | NotificationSettingsScalarFieldEnum[]
  }

  /**
   * NotificationSettings findMany
   */
  export type NotificationSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationSettings.
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    distinct?: NotificationSettingsScalarFieldEnum | NotificationSettingsScalarFieldEnum[]
  }

  /**
   * NotificationSettings create
   */
  export type NotificationSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationSettings.
     */
    data: XOR<NotificationSettingsCreateInput, NotificationSettingsUncheckedCreateInput>
  }

  /**
   * NotificationSettings createMany
   */
  export type NotificationSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationSettings.
     */
    data: NotificationSettingsCreateManyInput | NotificationSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationSettings createManyAndReturn
   */
  export type NotificationSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationSettings.
     */
    data: NotificationSettingsCreateManyInput | NotificationSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationSettings update
   */
  export type NotificationSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationSettings.
     */
    data: XOR<NotificationSettingsUpdateInput, NotificationSettingsUncheckedUpdateInput>
    /**
     * Choose, which NotificationSettings to update.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings updateMany
   */
  export type NotificationSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationSettings.
     */
    data: XOR<NotificationSettingsUpdateManyMutationInput, NotificationSettingsUncheckedUpdateManyInput>
    /**
     * Filter which NotificationSettings to update
     */
    where?: NotificationSettingsWhereInput
    /**
     * Limit how many NotificationSettings to update.
     */
    limit?: number
  }

  /**
   * NotificationSettings updateManyAndReturn
   */
  export type NotificationSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * The data used to update NotificationSettings.
     */
    data: XOR<NotificationSettingsUpdateManyMutationInput, NotificationSettingsUncheckedUpdateManyInput>
    /**
     * Filter which NotificationSettings to update
     */
    where?: NotificationSettingsWhereInput
    /**
     * Limit how many NotificationSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationSettings upsert
   */
  export type NotificationSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationSettings to update in case it exists.
     */
    where: NotificationSettingsWhereUniqueInput
    /**
     * In case the NotificationSettings found by the `where` argument doesn't exist, create a new NotificationSettings with this data.
     */
    create: XOR<NotificationSettingsCreateInput, NotificationSettingsUncheckedCreateInput>
    /**
     * In case the NotificationSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationSettingsUpdateInput, NotificationSettingsUncheckedUpdateInput>
  }

  /**
   * NotificationSettings delete
   */
  export type NotificationSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter which NotificationSettings to delete.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings deleteMany
   */
  export type NotificationSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationSettings to delete
     */
    where?: NotificationSettingsWhereInput
    /**
     * Limit how many NotificationSettings to delete.
     */
    limit?: number
  }

  /**
   * NotificationSettings without action
   */
  export type NotificationSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
  }


  /**
   * Model UserLink
   */

  export type AggregateUserLink = {
    _count: UserLinkCountAggregateOutputType | null
    _avg: UserLinkAvgAggregateOutputType | null
    _sum: UserLinkSumAggregateOutputType | null
    _min: UserLinkMinAggregateOutputType | null
    _max: UserLinkMaxAggregateOutputType | null
  }

  export type UserLinkAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type UserLinkSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type UserLinkMinAggregateOutputType = {
    id: string | null
    url: string | null
    title: string | null
    description: string | null
    sortOrder: number | null
    isActive: boolean | null
    useOriginalIcon: boolean | null
    originalIconUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    serviceId: string | null
    iconId: string | null
  }

  export type UserLinkMaxAggregateOutputType = {
    id: string | null
    url: string | null
    title: string | null
    description: string | null
    sortOrder: number | null
    isActive: boolean | null
    useOriginalIcon: boolean | null
    originalIconUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    serviceId: string | null
    iconId: string | null
  }

  export type UserLinkCountAggregateOutputType = {
    id: number
    url: number
    title: number
    description: number
    sortOrder: number
    isActive: number
    useOriginalIcon: number
    originalIconUrl: number
    createdAt: number
    updatedAt: number
    userId: number
    serviceId: number
    iconId: number
    _all: number
  }


  export type UserLinkAvgAggregateInputType = {
    sortOrder?: true
  }

  export type UserLinkSumAggregateInputType = {
    sortOrder?: true
  }

  export type UserLinkMinAggregateInputType = {
    id?: true
    url?: true
    title?: true
    description?: true
    sortOrder?: true
    isActive?: true
    useOriginalIcon?: true
    originalIconUrl?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    serviceId?: true
    iconId?: true
  }

  export type UserLinkMaxAggregateInputType = {
    id?: true
    url?: true
    title?: true
    description?: true
    sortOrder?: true
    isActive?: true
    useOriginalIcon?: true
    originalIconUrl?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    serviceId?: true
    iconId?: true
  }

  export type UserLinkCountAggregateInputType = {
    id?: true
    url?: true
    title?: true
    description?: true
    sortOrder?: true
    isActive?: true
    useOriginalIcon?: true
    originalIconUrl?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    serviceId?: true
    iconId?: true
    _all?: true
  }

  export type UserLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLink to aggregate.
     */
    where?: UserLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLinks to fetch.
     */
    orderBy?: UserLinkOrderByWithRelationInput | UserLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserLinks
    **/
    _count?: true | UserLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserLinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserLinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserLinkMaxAggregateInputType
  }

  export type GetUserLinkAggregateType<T extends UserLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateUserLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserLink[P]>
      : GetScalarType<T[P], AggregateUserLink[P]>
  }




  export type UserLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLinkWhereInput
    orderBy?: UserLinkOrderByWithAggregationInput | UserLinkOrderByWithAggregationInput[]
    by: UserLinkScalarFieldEnum[] | UserLinkScalarFieldEnum
    having?: UserLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserLinkCountAggregateInputType | true
    _avg?: UserLinkAvgAggregateInputType
    _sum?: UserLinkSumAggregateInputType
    _min?: UserLinkMinAggregateInputType
    _max?: UserLinkMaxAggregateInputType
  }

  export type UserLinkGroupByOutputType = {
    id: string
    url: string
    title: string | null
    description: string | null
    sortOrder: number
    isActive: boolean
    useOriginalIcon: boolean
    originalIconUrl: string | null
    createdAt: Date
    updatedAt: Date
    userId: string
    serviceId: string
    iconId: string | null
    _count: UserLinkCountAggregateOutputType | null
    _avg: UserLinkAvgAggregateOutputType | null
    _sum: UserLinkSumAggregateOutputType | null
    _min: UserLinkMinAggregateOutputType | null
    _max: UserLinkMaxAggregateOutputType | null
  }

  type GetUserLinkGroupByPayload<T extends UserLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserLinkGroupByOutputType[P]>
            : GetScalarType<T[P], UserLinkGroupByOutputType[P]>
        }
      >
    >


  export type UserLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    title?: boolean
    description?: boolean
    sortOrder?: boolean
    isActive?: boolean
    useOriginalIcon?: boolean
    originalIconUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    serviceId?: boolean
    iconId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | LinkServiceDefaultArgs<ExtArgs>
    icon?: boolean | UserLink$iconArgs<ExtArgs>
  }, ExtArgs["result"]["userLink"]>

  export type UserLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    title?: boolean
    description?: boolean
    sortOrder?: boolean
    isActive?: boolean
    useOriginalIcon?: boolean
    originalIconUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    serviceId?: boolean
    iconId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | LinkServiceDefaultArgs<ExtArgs>
    icon?: boolean | UserLink$iconArgs<ExtArgs>
  }, ExtArgs["result"]["userLink"]>

  export type UserLinkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    title?: boolean
    description?: boolean
    sortOrder?: boolean
    isActive?: boolean
    useOriginalIcon?: boolean
    originalIconUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    serviceId?: boolean
    iconId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | LinkServiceDefaultArgs<ExtArgs>
    icon?: boolean | UserLink$iconArgs<ExtArgs>
  }, ExtArgs["result"]["userLink"]>

  export type UserLinkSelectScalar = {
    id?: boolean
    url?: boolean
    title?: boolean
    description?: boolean
    sortOrder?: boolean
    isActive?: boolean
    useOriginalIcon?: boolean
    originalIconUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    serviceId?: boolean
    iconId?: boolean
  }

  export type UserLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "title" | "description" | "sortOrder" | "isActive" | "useOriginalIcon" | "originalIconUrl" | "createdAt" | "updatedAt" | "userId" | "serviceId" | "iconId", ExtArgs["result"]["userLink"]>
  export type UserLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | LinkServiceDefaultArgs<ExtArgs>
    icon?: boolean | UserLink$iconArgs<ExtArgs>
  }
  export type UserLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | LinkServiceDefaultArgs<ExtArgs>
    icon?: boolean | UserLink$iconArgs<ExtArgs>
  }
  export type UserLinkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | LinkServiceDefaultArgs<ExtArgs>
    icon?: boolean | UserLink$iconArgs<ExtArgs>
  }

  export type $UserLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserLink"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      service: Prisma.$LinkServicePayload<ExtArgs>
      icon: Prisma.$ServiceIconPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      title: string | null
      description: string | null
      sortOrder: number
      isActive: boolean
      useOriginalIcon: boolean
      originalIconUrl: string | null
      createdAt: Date
      updatedAt: Date
      userId: string
      serviceId: string
      iconId: string | null
    }, ExtArgs["result"]["userLink"]>
    composites: {}
  }

  type UserLinkGetPayload<S extends boolean | null | undefined | UserLinkDefaultArgs> = $Result.GetResult<Prisma.$UserLinkPayload, S>

  type UserLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserLinkCountAggregateInputType | true
    }

  export interface UserLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserLink'], meta: { name: 'UserLink' } }
    /**
     * Find zero or one UserLink that matches the filter.
     * @param {UserLinkFindUniqueArgs} args - Arguments to find a UserLink
     * @example
     * // Get one UserLink
     * const userLink = await prisma.userLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserLinkFindUniqueArgs>(args: SelectSubset<T, UserLinkFindUniqueArgs<ExtArgs>>): Prisma__UserLinkClient<$Result.GetResult<Prisma.$UserLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserLinkFindUniqueOrThrowArgs} args - Arguments to find a UserLink
     * @example
     * // Get one UserLink
     * const userLink = await prisma.userLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, UserLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserLinkClient<$Result.GetResult<Prisma.$UserLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLinkFindFirstArgs} args - Arguments to find a UserLink
     * @example
     * // Get one UserLink
     * const userLink = await prisma.userLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserLinkFindFirstArgs>(args?: SelectSubset<T, UserLinkFindFirstArgs<ExtArgs>>): Prisma__UserLinkClient<$Result.GetResult<Prisma.$UserLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLinkFindFirstOrThrowArgs} args - Arguments to find a UserLink
     * @example
     * // Get one UserLink
     * const userLink = await prisma.userLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, UserLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserLinkClient<$Result.GetResult<Prisma.$UserLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserLinks
     * const userLinks = await prisma.userLink.findMany()
     * 
     * // Get first 10 UserLinks
     * const userLinks = await prisma.userLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userLinkWithIdOnly = await prisma.userLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserLinkFindManyArgs>(args?: SelectSubset<T, UserLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserLink.
     * @param {UserLinkCreateArgs} args - Arguments to create a UserLink.
     * @example
     * // Create one UserLink
     * const UserLink = await prisma.userLink.create({
     *   data: {
     *     // ... data to create a UserLink
     *   }
     * })
     * 
     */
    create<T extends UserLinkCreateArgs>(args: SelectSubset<T, UserLinkCreateArgs<ExtArgs>>): Prisma__UserLinkClient<$Result.GetResult<Prisma.$UserLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserLinks.
     * @param {UserLinkCreateManyArgs} args - Arguments to create many UserLinks.
     * @example
     * // Create many UserLinks
     * const userLink = await prisma.userLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserLinkCreateManyArgs>(args?: SelectSubset<T, UserLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserLinks and returns the data saved in the database.
     * @param {UserLinkCreateManyAndReturnArgs} args - Arguments to create many UserLinks.
     * @example
     * // Create many UserLinks
     * const userLink = await prisma.userLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserLinks and only return the `id`
     * const userLinkWithIdOnly = await prisma.userLink.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, UserLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLinkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserLink.
     * @param {UserLinkDeleteArgs} args - Arguments to delete one UserLink.
     * @example
     * // Delete one UserLink
     * const UserLink = await prisma.userLink.delete({
     *   where: {
     *     // ... filter to delete one UserLink
     *   }
     * })
     * 
     */
    delete<T extends UserLinkDeleteArgs>(args: SelectSubset<T, UserLinkDeleteArgs<ExtArgs>>): Prisma__UserLinkClient<$Result.GetResult<Prisma.$UserLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserLink.
     * @param {UserLinkUpdateArgs} args - Arguments to update one UserLink.
     * @example
     * // Update one UserLink
     * const userLink = await prisma.userLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserLinkUpdateArgs>(args: SelectSubset<T, UserLinkUpdateArgs<ExtArgs>>): Prisma__UserLinkClient<$Result.GetResult<Prisma.$UserLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserLinks.
     * @param {UserLinkDeleteManyArgs} args - Arguments to filter UserLinks to delete.
     * @example
     * // Delete a few UserLinks
     * const { count } = await prisma.userLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserLinkDeleteManyArgs>(args?: SelectSubset<T, UserLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserLinks
     * const userLink = await prisma.userLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserLinkUpdateManyArgs>(args: SelectSubset<T, UserLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLinks and returns the data updated in the database.
     * @param {UserLinkUpdateManyAndReturnArgs} args - Arguments to update many UserLinks.
     * @example
     * // Update many UserLinks
     * const userLink = await prisma.userLink.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserLinks and only return the `id`
     * const userLinkWithIdOnly = await prisma.userLink.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserLinkUpdateManyAndReturnArgs>(args: SelectSubset<T, UserLinkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLinkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserLink.
     * @param {UserLinkUpsertArgs} args - Arguments to update or create a UserLink.
     * @example
     * // Update or create a UserLink
     * const userLink = await prisma.userLink.upsert({
     *   create: {
     *     // ... data to create a UserLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserLink we want to update
     *   }
     * })
     */
    upsert<T extends UserLinkUpsertArgs>(args: SelectSubset<T, UserLinkUpsertArgs<ExtArgs>>): Prisma__UserLinkClient<$Result.GetResult<Prisma.$UserLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLinkCountArgs} args - Arguments to filter UserLinks to count.
     * @example
     * // Count the number of UserLinks
     * const count = await prisma.userLink.count({
     *   where: {
     *     // ... the filter for the UserLinks we want to count
     *   }
     * })
    **/
    count<T extends UserLinkCountArgs>(
      args?: Subset<T, UserLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserLinkAggregateArgs>(args: Subset<T, UserLinkAggregateArgs>): Prisma.PrismaPromise<GetUserLinkAggregateType<T>>

    /**
     * Group by UserLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserLinkGroupByArgs['orderBy'] }
        : { orderBy?: UserLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserLink model
   */
  readonly fields: UserLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends LinkServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LinkServiceDefaultArgs<ExtArgs>>): Prisma__LinkServiceClient<$Result.GetResult<Prisma.$LinkServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    icon<T extends UserLink$iconArgs<ExtArgs> = {}>(args?: Subset<T, UserLink$iconArgs<ExtArgs>>): Prisma__ServiceIconClient<$Result.GetResult<Prisma.$ServiceIconPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserLink model
   */
  interface UserLinkFieldRefs {
    readonly id: FieldRef<"UserLink", 'String'>
    readonly url: FieldRef<"UserLink", 'String'>
    readonly title: FieldRef<"UserLink", 'String'>
    readonly description: FieldRef<"UserLink", 'String'>
    readonly sortOrder: FieldRef<"UserLink", 'Int'>
    readonly isActive: FieldRef<"UserLink", 'Boolean'>
    readonly useOriginalIcon: FieldRef<"UserLink", 'Boolean'>
    readonly originalIconUrl: FieldRef<"UserLink", 'String'>
    readonly createdAt: FieldRef<"UserLink", 'DateTime'>
    readonly updatedAt: FieldRef<"UserLink", 'DateTime'>
    readonly userId: FieldRef<"UserLink", 'String'>
    readonly serviceId: FieldRef<"UserLink", 'String'>
    readonly iconId: FieldRef<"UserLink", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserLink findUnique
   */
  export type UserLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLink
     */
    select?: UserLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLink
     */
    omit?: UserLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLinkInclude<ExtArgs> | null
    /**
     * Filter, which UserLink to fetch.
     */
    where: UserLinkWhereUniqueInput
  }

  /**
   * UserLink findUniqueOrThrow
   */
  export type UserLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLink
     */
    select?: UserLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLink
     */
    omit?: UserLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLinkInclude<ExtArgs> | null
    /**
     * Filter, which UserLink to fetch.
     */
    where: UserLinkWhereUniqueInput
  }

  /**
   * UserLink findFirst
   */
  export type UserLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLink
     */
    select?: UserLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLink
     */
    omit?: UserLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLinkInclude<ExtArgs> | null
    /**
     * Filter, which UserLink to fetch.
     */
    where?: UserLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLinks to fetch.
     */
    orderBy?: UserLinkOrderByWithRelationInput | UserLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLinks.
     */
    cursor?: UserLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLinks.
     */
    distinct?: UserLinkScalarFieldEnum | UserLinkScalarFieldEnum[]
  }

  /**
   * UserLink findFirstOrThrow
   */
  export type UserLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLink
     */
    select?: UserLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLink
     */
    omit?: UserLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLinkInclude<ExtArgs> | null
    /**
     * Filter, which UserLink to fetch.
     */
    where?: UserLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLinks to fetch.
     */
    orderBy?: UserLinkOrderByWithRelationInput | UserLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLinks.
     */
    cursor?: UserLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLinks.
     */
    distinct?: UserLinkScalarFieldEnum | UserLinkScalarFieldEnum[]
  }

  /**
   * UserLink findMany
   */
  export type UserLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLink
     */
    select?: UserLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLink
     */
    omit?: UserLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLinkInclude<ExtArgs> | null
    /**
     * Filter, which UserLinks to fetch.
     */
    where?: UserLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLinks to fetch.
     */
    orderBy?: UserLinkOrderByWithRelationInput | UserLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserLinks.
     */
    cursor?: UserLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLinks.
     */
    skip?: number
    distinct?: UserLinkScalarFieldEnum | UserLinkScalarFieldEnum[]
  }

  /**
   * UserLink create
   */
  export type UserLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLink
     */
    select?: UserLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLink
     */
    omit?: UserLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a UserLink.
     */
    data: XOR<UserLinkCreateInput, UserLinkUncheckedCreateInput>
  }

  /**
   * UserLink createMany
   */
  export type UserLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserLinks.
     */
    data: UserLinkCreateManyInput | UserLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserLink createManyAndReturn
   */
  export type UserLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLink
     */
    select?: UserLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLink
     */
    omit?: UserLinkOmit<ExtArgs> | null
    /**
     * The data used to create many UserLinks.
     */
    data: UserLinkCreateManyInput | UserLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLink update
   */
  export type UserLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLink
     */
    select?: UserLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLink
     */
    omit?: UserLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a UserLink.
     */
    data: XOR<UserLinkUpdateInput, UserLinkUncheckedUpdateInput>
    /**
     * Choose, which UserLink to update.
     */
    where: UserLinkWhereUniqueInput
  }

  /**
   * UserLink updateMany
   */
  export type UserLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserLinks.
     */
    data: XOR<UserLinkUpdateManyMutationInput, UserLinkUncheckedUpdateManyInput>
    /**
     * Filter which UserLinks to update
     */
    where?: UserLinkWhereInput
    /**
     * Limit how many UserLinks to update.
     */
    limit?: number
  }

  /**
   * UserLink updateManyAndReturn
   */
  export type UserLinkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLink
     */
    select?: UserLinkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserLink
     */
    omit?: UserLinkOmit<ExtArgs> | null
    /**
     * The data used to update UserLinks.
     */
    data: XOR<UserLinkUpdateManyMutationInput, UserLinkUncheckedUpdateManyInput>
    /**
     * Filter which UserLinks to update
     */
    where?: UserLinkWhereInput
    /**
     * Limit how many UserLinks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLinkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserLink upsert
   */
  export type UserLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLink
     */
    select?: UserLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLink
     */
    omit?: UserLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the UserLink to update in case it exists.
     */
    where: UserLinkWhereUniqueInput
    /**
     * In case the UserLink found by the `where` argument doesn't exist, create a new UserLink with this data.
     */
    create: XOR<UserLinkCreateInput, UserLinkUncheckedCreateInput>
    /**
     * In case the UserLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserLinkUpdateInput, UserLinkUncheckedUpdateInput>
  }

  /**
   * UserLink delete
   */
  export type UserLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLink
     */
    select?: UserLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLink
     */
    omit?: UserLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLinkInclude<ExtArgs> | null
    /**
     * Filter which UserLink to delete.
     */
    where: UserLinkWhereUniqueInput
  }

  /**
   * UserLink deleteMany
   */
  export type UserLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLinks to delete
     */
    where?: UserLinkWhereInput
    /**
     * Limit how many UserLinks to delete.
     */
    limit?: number
  }

  /**
   * UserLink.icon
   */
  export type UserLink$iconArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceIcon
     */
    select?: ServiceIconSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceIcon
     */
    omit?: ServiceIconOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIconInclude<ExtArgs> | null
    where?: ServiceIconWhereInput
  }

  /**
   * UserLink without action
   */
  export type UserLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLink
     */
    select?: UserLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLink
     */
    omit?: UserLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLinkInclude<ExtArgs> | null
  }


  /**
   * Model UserYoutubeSettings
   */

  export type AggregateUserYoutubeSettings = {
    _count: UserYoutubeSettingsCountAggregateOutputType | null
    _avg: UserYoutubeSettingsAvgAggregateOutputType | null
    _sum: UserYoutubeSettingsSumAggregateOutputType | null
    _min: UserYoutubeSettingsMinAggregateOutputType | null
    _max: UserYoutubeSettingsMaxAggregateOutputType | null
  }

  export type UserYoutubeSettingsAvgAggregateOutputType = {
    displayCount: number | null
  }

  export type UserYoutubeSettingsSumAggregateOutputType = {
    displayCount: number | null
  }

  export type UserYoutubeSettingsMinAggregateOutputType = {
    id: string | null
    channelId: string | null
    displayCount: number | null
    lastFetchedAt: Date | null
    pickupVideo: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type UserYoutubeSettingsMaxAggregateOutputType = {
    id: string | null
    channelId: string | null
    displayCount: number | null
    lastFetchedAt: Date | null
    pickupVideo: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type UserYoutubeSettingsCountAggregateOutputType = {
    id: number
    channelId: number
    displayCount: number
    lastFetchedAt: number
    pickupVideo: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type UserYoutubeSettingsAvgAggregateInputType = {
    displayCount?: true
  }

  export type UserYoutubeSettingsSumAggregateInputType = {
    displayCount?: true
  }

  export type UserYoutubeSettingsMinAggregateInputType = {
    id?: true
    channelId?: true
    displayCount?: true
    lastFetchedAt?: true
    pickupVideo?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type UserYoutubeSettingsMaxAggregateInputType = {
    id?: true
    channelId?: true
    displayCount?: true
    lastFetchedAt?: true
    pickupVideo?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type UserYoutubeSettingsCountAggregateInputType = {
    id?: true
    channelId?: true
    displayCount?: true
    lastFetchedAt?: true
    pickupVideo?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type UserYoutubeSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserYoutubeSettings to aggregate.
     */
    where?: UserYoutubeSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserYoutubeSettings to fetch.
     */
    orderBy?: UserYoutubeSettingsOrderByWithRelationInput | UserYoutubeSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserYoutubeSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserYoutubeSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserYoutubeSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserYoutubeSettings
    **/
    _count?: true | UserYoutubeSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserYoutubeSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserYoutubeSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserYoutubeSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserYoutubeSettingsMaxAggregateInputType
  }

  export type GetUserYoutubeSettingsAggregateType<T extends UserYoutubeSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserYoutubeSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserYoutubeSettings[P]>
      : GetScalarType<T[P], AggregateUserYoutubeSettings[P]>
  }




  export type UserYoutubeSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserYoutubeSettingsWhereInput
    orderBy?: UserYoutubeSettingsOrderByWithAggregationInput | UserYoutubeSettingsOrderByWithAggregationInput[]
    by: UserYoutubeSettingsScalarFieldEnum[] | UserYoutubeSettingsScalarFieldEnum
    having?: UserYoutubeSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserYoutubeSettingsCountAggregateInputType | true
    _avg?: UserYoutubeSettingsAvgAggregateInputType
    _sum?: UserYoutubeSettingsSumAggregateInputType
    _min?: UserYoutubeSettingsMinAggregateInputType
    _max?: UserYoutubeSettingsMaxAggregateInputType
  }

  export type UserYoutubeSettingsGroupByOutputType = {
    id: string
    channelId: string | null
    displayCount: number
    lastFetchedAt: Date | null
    pickupVideo: string | null
    createdAt: Date
    updatedAt: Date
    userId: string
    _count: UserYoutubeSettingsCountAggregateOutputType | null
    _avg: UserYoutubeSettingsAvgAggregateOutputType | null
    _sum: UserYoutubeSettingsSumAggregateOutputType | null
    _min: UserYoutubeSettingsMinAggregateOutputType | null
    _max: UserYoutubeSettingsMaxAggregateOutputType | null
  }

  type GetUserYoutubeSettingsGroupByPayload<T extends UserYoutubeSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserYoutubeSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserYoutubeSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserYoutubeSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], UserYoutubeSettingsGroupByOutputType[P]>
        }
      >
    >


  export type UserYoutubeSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    channelId?: boolean
    displayCount?: boolean
    lastFetchedAt?: boolean
    pickupVideo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    videos?: boolean | UserYoutubeSettings$videosArgs<ExtArgs>
    _count?: boolean | UserYoutubeSettingsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userYoutubeSettings"]>

  export type UserYoutubeSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    channelId?: boolean
    displayCount?: boolean
    lastFetchedAt?: boolean
    pickupVideo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userYoutubeSettings"]>

  export type UserYoutubeSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    channelId?: boolean
    displayCount?: boolean
    lastFetchedAt?: boolean
    pickupVideo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userYoutubeSettings"]>

  export type UserYoutubeSettingsSelectScalar = {
    id?: boolean
    channelId?: boolean
    displayCount?: boolean
    lastFetchedAt?: boolean
    pickupVideo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type UserYoutubeSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "channelId" | "displayCount" | "lastFetchedAt" | "pickupVideo" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["userYoutubeSettings"]>
  export type UserYoutubeSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    videos?: boolean | UserYoutubeSettings$videosArgs<ExtArgs>
    _count?: boolean | UserYoutubeSettingsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserYoutubeSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserYoutubeSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserYoutubeSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserYoutubeSettings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      videos: Prisma.$UserYoutubeVideoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      channelId: string | null
      displayCount: number
      lastFetchedAt: Date | null
      pickupVideo: string | null
      createdAt: Date
      updatedAt: Date
      userId: string
    }, ExtArgs["result"]["userYoutubeSettings"]>
    composites: {}
  }

  type UserYoutubeSettingsGetPayload<S extends boolean | null | undefined | UserYoutubeSettingsDefaultArgs> = $Result.GetResult<Prisma.$UserYoutubeSettingsPayload, S>

  type UserYoutubeSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserYoutubeSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserYoutubeSettingsCountAggregateInputType | true
    }

  export interface UserYoutubeSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserYoutubeSettings'], meta: { name: 'UserYoutubeSettings' } }
    /**
     * Find zero or one UserYoutubeSettings that matches the filter.
     * @param {UserYoutubeSettingsFindUniqueArgs} args - Arguments to find a UserYoutubeSettings
     * @example
     * // Get one UserYoutubeSettings
     * const userYoutubeSettings = await prisma.userYoutubeSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserYoutubeSettingsFindUniqueArgs>(args: SelectSubset<T, UserYoutubeSettingsFindUniqueArgs<ExtArgs>>): Prisma__UserYoutubeSettingsClient<$Result.GetResult<Prisma.$UserYoutubeSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserYoutubeSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserYoutubeSettingsFindUniqueOrThrowArgs} args - Arguments to find a UserYoutubeSettings
     * @example
     * // Get one UserYoutubeSettings
     * const userYoutubeSettings = await prisma.userYoutubeSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserYoutubeSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserYoutubeSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserYoutubeSettingsClient<$Result.GetResult<Prisma.$UserYoutubeSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserYoutubeSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserYoutubeSettingsFindFirstArgs} args - Arguments to find a UserYoutubeSettings
     * @example
     * // Get one UserYoutubeSettings
     * const userYoutubeSettings = await prisma.userYoutubeSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserYoutubeSettingsFindFirstArgs>(args?: SelectSubset<T, UserYoutubeSettingsFindFirstArgs<ExtArgs>>): Prisma__UserYoutubeSettingsClient<$Result.GetResult<Prisma.$UserYoutubeSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserYoutubeSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserYoutubeSettingsFindFirstOrThrowArgs} args - Arguments to find a UserYoutubeSettings
     * @example
     * // Get one UserYoutubeSettings
     * const userYoutubeSettings = await prisma.userYoutubeSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserYoutubeSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserYoutubeSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserYoutubeSettingsClient<$Result.GetResult<Prisma.$UserYoutubeSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserYoutubeSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserYoutubeSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserYoutubeSettings
     * const userYoutubeSettings = await prisma.userYoutubeSettings.findMany()
     * 
     * // Get first 10 UserYoutubeSettings
     * const userYoutubeSettings = await prisma.userYoutubeSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userYoutubeSettingsWithIdOnly = await prisma.userYoutubeSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserYoutubeSettingsFindManyArgs>(args?: SelectSubset<T, UserYoutubeSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserYoutubeSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserYoutubeSettings.
     * @param {UserYoutubeSettingsCreateArgs} args - Arguments to create a UserYoutubeSettings.
     * @example
     * // Create one UserYoutubeSettings
     * const UserYoutubeSettings = await prisma.userYoutubeSettings.create({
     *   data: {
     *     // ... data to create a UserYoutubeSettings
     *   }
     * })
     * 
     */
    create<T extends UserYoutubeSettingsCreateArgs>(args: SelectSubset<T, UserYoutubeSettingsCreateArgs<ExtArgs>>): Prisma__UserYoutubeSettingsClient<$Result.GetResult<Prisma.$UserYoutubeSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserYoutubeSettings.
     * @param {UserYoutubeSettingsCreateManyArgs} args - Arguments to create many UserYoutubeSettings.
     * @example
     * // Create many UserYoutubeSettings
     * const userYoutubeSettings = await prisma.userYoutubeSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserYoutubeSettingsCreateManyArgs>(args?: SelectSubset<T, UserYoutubeSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserYoutubeSettings and returns the data saved in the database.
     * @param {UserYoutubeSettingsCreateManyAndReturnArgs} args - Arguments to create many UserYoutubeSettings.
     * @example
     * // Create many UserYoutubeSettings
     * const userYoutubeSettings = await prisma.userYoutubeSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserYoutubeSettings and only return the `id`
     * const userYoutubeSettingsWithIdOnly = await prisma.userYoutubeSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserYoutubeSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserYoutubeSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserYoutubeSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserYoutubeSettings.
     * @param {UserYoutubeSettingsDeleteArgs} args - Arguments to delete one UserYoutubeSettings.
     * @example
     * // Delete one UserYoutubeSettings
     * const UserYoutubeSettings = await prisma.userYoutubeSettings.delete({
     *   where: {
     *     // ... filter to delete one UserYoutubeSettings
     *   }
     * })
     * 
     */
    delete<T extends UserYoutubeSettingsDeleteArgs>(args: SelectSubset<T, UserYoutubeSettingsDeleteArgs<ExtArgs>>): Prisma__UserYoutubeSettingsClient<$Result.GetResult<Prisma.$UserYoutubeSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserYoutubeSettings.
     * @param {UserYoutubeSettingsUpdateArgs} args - Arguments to update one UserYoutubeSettings.
     * @example
     * // Update one UserYoutubeSettings
     * const userYoutubeSettings = await prisma.userYoutubeSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserYoutubeSettingsUpdateArgs>(args: SelectSubset<T, UserYoutubeSettingsUpdateArgs<ExtArgs>>): Prisma__UserYoutubeSettingsClient<$Result.GetResult<Prisma.$UserYoutubeSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserYoutubeSettings.
     * @param {UserYoutubeSettingsDeleteManyArgs} args - Arguments to filter UserYoutubeSettings to delete.
     * @example
     * // Delete a few UserYoutubeSettings
     * const { count } = await prisma.userYoutubeSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserYoutubeSettingsDeleteManyArgs>(args?: SelectSubset<T, UserYoutubeSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserYoutubeSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserYoutubeSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserYoutubeSettings
     * const userYoutubeSettings = await prisma.userYoutubeSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserYoutubeSettingsUpdateManyArgs>(args: SelectSubset<T, UserYoutubeSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserYoutubeSettings and returns the data updated in the database.
     * @param {UserYoutubeSettingsUpdateManyAndReturnArgs} args - Arguments to update many UserYoutubeSettings.
     * @example
     * // Update many UserYoutubeSettings
     * const userYoutubeSettings = await prisma.userYoutubeSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserYoutubeSettings and only return the `id`
     * const userYoutubeSettingsWithIdOnly = await prisma.userYoutubeSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserYoutubeSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, UserYoutubeSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserYoutubeSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserYoutubeSettings.
     * @param {UserYoutubeSettingsUpsertArgs} args - Arguments to update or create a UserYoutubeSettings.
     * @example
     * // Update or create a UserYoutubeSettings
     * const userYoutubeSettings = await prisma.userYoutubeSettings.upsert({
     *   create: {
     *     // ... data to create a UserYoutubeSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserYoutubeSettings we want to update
     *   }
     * })
     */
    upsert<T extends UserYoutubeSettingsUpsertArgs>(args: SelectSubset<T, UserYoutubeSettingsUpsertArgs<ExtArgs>>): Prisma__UserYoutubeSettingsClient<$Result.GetResult<Prisma.$UserYoutubeSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserYoutubeSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserYoutubeSettingsCountArgs} args - Arguments to filter UserYoutubeSettings to count.
     * @example
     * // Count the number of UserYoutubeSettings
     * const count = await prisma.userYoutubeSettings.count({
     *   where: {
     *     // ... the filter for the UserYoutubeSettings we want to count
     *   }
     * })
    **/
    count<T extends UserYoutubeSettingsCountArgs>(
      args?: Subset<T, UserYoutubeSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserYoutubeSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserYoutubeSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserYoutubeSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserYoutubeSettingsAggregateArgs>(args: Subset<T, UserYoutubeSettingsAggregateArgs>): Prisma.PrismaPromise<GetUserYoutubeSettingsAggregateType<T>>

    /**
     * Group by UserYoutubeSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserYoutubeSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserYoutubeSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserYoutubeSettingsGroupByArgs['orderBy'] }
        : { orderBy?: UserYoutubeSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserYoutubeSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserYoutubeSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserYoutubeSettings model
   */
  readonly fields: UserYoutubeSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserYoutubeSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserYoutubeSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    videos<T extends UserYoutubeSettings$videosArgs<ExtArgs> = {}>(args?: Subset<T, UserYoutubeSettings$videosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserYoutubeVideoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserYoutubeSettings model
   */
  interface UserYoutubeSettingsFieldRefs {
    readonly id: FieldRef<"UserYoutubeSettings", 'String'>
    readonly channelId: FieldRef<"UserYoutubeSettings", 'String'>
    readonly displayCount: FieldRef<"UserYoutubeSettings", 'Int'>
    readonly lastFetchedAt: FieldRef<"UserYoutubeSettings", 'DateTime'>
    readonly pickupVideo: FieldRef<"UserYoutubeSettings", 'String'>
    readonly createdAt: FieldRef<"UserYoutubeSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"UserYoutubeSettings", 'DateTime'>
    readonly userId: FieldRef<"UserYoutubeSettings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserYoutubeSettings findUnique
   */
  export type UserYoutubeSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserYoutubeSettings
     */
    select?: UserYoutubeSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserYoutubeSettings
     */
    omit?: UserYoutubeSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserYoutubeSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserYoutubeSettings to fetch.
     */
    where: UserYoutubeSettingsWhereUniqueInput
  }

  /**
   * UserYoutubeSettings findUniqueOrThrow
   */
  export type UserYoutubeSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserYoutubeSettings
     */
    select?: UserYoutubeSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserYoutubeSettings
     */
    omit?: UserYoutubeSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserYoutubeSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserYoutubeSettings to fetch.
     */
    where: UserYoutubeSettingsWhereUniqueInput
  }

  /**
   * UserYoutubeSettings findFirst
   */
  export type UserYoutubeSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserYoutubeSettings
     */
    select?: UserYoutubeSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserYoutubeSettings
     */
    omit?: UserYoutubeSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserYoutubeSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserYoutubeSettings to fetch.
     */
    where?: UserYoutubeSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserYoutubeSettings to fetch.
     */
    orderBy?: UserYoutubeSettingsOrderByWithRelationInput | UserYoutubeSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserYoutubeSettings.
     */
    cursor?: UserYoutubeSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserYoutubeSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserYoutubeSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserYoutubeSettings.
     */
    distinct?: UserYoutubeSettingsScalarFieldEnum | UserYoutubeSettingsScalarFieldEnum[]
  }

  /**
   * UserYoutubeSettings findFirstOrThrow
   */
  export type UserYoutubeSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserYoutubeSettings
     */
    select?: UserYoutubeSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserYoutubeSettings
     */
    omit?: UserYoutubeSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserYoutubeSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserYoutubeSettings to fetch.
     */
    where?: UserYoutubeSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserYoutubeSettings to fetch.
     */
    orderBy?: UserYoutubeSettingsOrderByWithRelationInput | UserYoutubeSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserYoutubeSettings.
     */
    cursor?: UserYoutubeSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserYoutubeSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserYoutubeSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserYoutubeSettings.
     */
    distinct?: UserYoutubeSettingsScalarFieldEnum | UserYoutubeSettingsScalarFieldEnum[]
  }

  /**
   * UserYoutubeSettings findMany
   */
  export type UserYoutubeSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserYoutubeSettings
     */
    select?: UserYoutubeSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserYoutubeSettings
     */
    omit?: UserYoutubeSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserYoutubeSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserYoutubeSettings to fetch.
     */
    where?: UserYoutubeSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserYoutubeSettings to fetch.
     */
    orderBy?: UserYoutubeSettingsOrderByWithRelationInput | UserYoutubeSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserYoutubeSettings.
     */
    cursor?: UserYoutubeSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserYoutubeSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserYoutubeSettings.
     */
    skip?: number
    distinct?: UserYoutubeSettingsScalarFieldEnum | UserYoutubeSettingsScalarFieldEnum[]
  }

  /**
   * UserYoutubeSettings create
   */
  export type UserYoutubeSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserYoutubeSettings
     */
    select?: UserYoutubeSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserYoutubeSettings
     */
    omit?: UserYoutubeSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserYoutubeSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserYoutubeSettings.
     */
    data: XOR<UserYoutubeSettingsCreateInput, UserYoutubeSettingsUncheckedCreateInput>
  }

  /**
   * UserYoutubeSettings createMany
   */
  export type UserYoutubeSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserYoutubeSettings.
     */
    data: UserYoutubeSettingsCreateManyInput | UserYoutubeSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserYoutubeSettings createManyAndReturn
   */
  export type UserYoutubeSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserYoutubeSettings
     */
    select?: UserYoutubeSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserYoutubeSettings
     */
    omit?: UserYoutubeSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many UserYoutubeSettings.
     */
    data: UserYoutubeSettingsCreateManyInput | UserYoutubeSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserYoutubeSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserYoutubeSettings update
   */
  export type UserYoutubeSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserYoutubeSettings
     */
    select?: UserYoutubeSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserYoutubeSettings
     */
    omit?: UserYoutubeSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserYoutubeSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserYoutubeSettings.
     */
    data: XOR<UserYoutubeSettingsUpdateInput, UserYoutubeSettingsUncheckedUpdateInput>
    /**
     * Choose, which UserYoutubeSettings to update.
     */
    where: UserYoutubeSettingsWhereUniqueInput
  }

  /**
   * UserYoutubeSettings updateMany
   */
  export type UserYoutubeSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserYoutubeSettings.
     */
    data: XOR<UserYoutubeSettingsUpdateManyMutationInput, UserYoutubeSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserYoutubeSettings to update
     */
    where?: UserYoutubeSettingsWhereInput
    /**
     * Limit how many UserYoutubeSettings to update.
     */
    limit?: number
  }

  /**
   * UserYoutubeSettings updateManyAndReturn
   */
  export type UserYoutubeSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserYoutubeSettings
     */
    select?: UserYoutubeSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserYoutubeSettings
     */
    omit?: UserYoutubeSettingsOmit<ExtArgs> | null
    /**
     * The data used to update UserYoutubeSettings.
     */
    data: XOR<UserYoutubeSettingsUpdateManyMutationInput, UserYoutubeSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserYoutubeSettings to update
     */
    where?: UserYoutubeSettingsWhereInput
    /**
     * Limit how many UserYoutubeSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserYoutubeSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserYoutubeSettings upsert
   */
  export type UserYoutubeSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserYoutubeSettings
     */
    select?: UserYoutubeSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserYoutubeSettings
     */
    omit?: UserYoutubeSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserYoutubeSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserYoutubeSettings to update in case it exists.
     */
    where: UserYoutubeSettingsWhereUniqueInput
    /**
     * In case the UserYoutubeSettings found by the `where` argument doesn't exist, create a new UserYoutubeSettings with this data.
     */
    create: XOR<UserYoutubeSettingsCreateInput, UserYoutubeSettingsUncheckedCreateInput>
    /**
     * In case the UserYoutubeSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserYoutubeSettingsUpdateInput, UserYoutubeSettingsUncheckedUpdateInput>
  }

  /**
   * UserYoutubeSettings delete
   */
  export type UserYoutubeSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserYoutubeSettings
     */
    select?: UserYoutubeSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserYoutubeSettings
     */
    omit?: UserYoutubeSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserYoutubeSettingsInclude<ExtArgs> | null
    /**
     * Filter which UserYoutubeSettings to delete.
     */
    where: UserYoutubeSettingsWhereUniqueInput
  }

  /**
   * UserYoutubeSettings deleteMany
   */
  export type UserYoutubeSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserYoutubeSettings to delete
     */
    where?: UserYoutubeSettingsWhereInput
    /**
     * Limit how many UserYoutubeSettings to delete.
     */
    limit?: number
  }

  /**
   * UserYoutubeSettings.videos
   */
  export type UserYoutubeSettings$videosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserYoutubeVideo
     */
    select?: UserYoutubeVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserYoutubeVideo
     */
    omit?: UserYoutubeVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserYoutubeVideoInclude<ExtArgs> | null
    where?: UserYoutubeVideoWhereInput
    orderBy?: UserYoutubeVideoOrderByWithRelationInput | UserYoutubeVideoOrderByWithRelationInput[]
    cursor?: UserYoutubeVideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserYoutubeVideoScalarFieldEnum | UserYoutubeVideoScalarFieldEnum[]
  }

  /**
   * UserYoutubeSettings without action
   */
  export type UserYoutubeSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserYoutubeSettings
     */
    select?: UserYoutubeSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserYoutubeSettings
     */
    omit?: UserYoutubeSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserYoutubeSettingsInclude<ExtArgs> | null
  }


  /**
   * Model UserImageBanner
   */

  export type AggregateUserImageBanner = {
    _count: UserImageBannerCountAggregateOutputType | null
    _avg: UserImageBannerAvgAggregateOutputType | null
    _sum: UserImageBannerSumAggregateOutputType | null
    _min: UserImageBannerMinAggregateOutputType | null
    _max: UserImageBannerMaxAggregateOutputType | null
  }

  export type UserImageBannerAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type UserImageBannerSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type UserImageBannerMinAggregateOutputType = {
    id: string | null
    url: string | null
    imgUrl: string | null
    alt: string | null
    sortOrder: number | null
    userId: string | null
  }

  export type UserImageBannerMaxAggregateOutputType = {
    id: string | null
    url: string | null
    imgUrl: string | null
    alt: string | null
    sortOrder: number | null
    userId: string | null
  }

  export type UserImageBannerCountAggregateOutputType = {
    id: number
    url: number
    imgUrl: number
    alt: number
    sortOrder: number
    userId: number
    _all: number
  }


  export type UserImageBannerAvgAggregateInputType = {
    sortOrder?: true
  }

  export type UserImageBannerSumAggregateInputType = {
    sortOrder?: true
  }

  export type UserImageBannerMinAggregateInputType = {
    id?: true
    url?: true
    imgUrl?: true
    alt?: true
    sortOrder?: true
    userId?: true
  }

  export type UserImageBannerMaxAggregateInputType = {
    id?: true
    url?: true
    imgUrl?: true
    alt?: true
    sortOrder?: true
    userId?: true
  }

  export type UserImageBannerCountAggregateInputType = {
    id?: true
    url?: true
    imgUrl?: true
    alt?: true
    sortOrder?: true
    userId?: true
    _all?: true
  }

  export type UserImageBannerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserImageBanner to aggregate.
     */
    where?: UserImageBannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserImageBanners to fetch.
     */
    orderBy?: UserImageBannerOrderByWithRelationInput | UserImageBannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserImageBannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserImageBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserImageBanners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserImageBanners
    **/
    _count?: true | UserImageBannerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserImageBannerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserImageBannerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserImageBannerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserImageBannerMaxAggregateInputType
  }

  export type GetUserImageBannerAggregateType<T extends UserImageBannerAggregateArgs> = {
        [P in keyof T & keyof AggregateUserImageBanner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserImageBanner[P]>
      : GetScalarType<T[P], AggregateUserImageBanner[P]>
  }




  export type UserImageBannerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserImageBannerWhereInput
    orderBy?: UserImageBannerOrderByWithAggregationInput | UserImageBannerOrderByWithAggregationInput[]
    by: UserImageBannerScalarFieldEnum[] | UserImageBannerScalarFieldEnum
    having?: UserImageBannerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserImageBannerCountAggregateInputType | true
    _avg?: UserImageBannerAvgAggregateInputType
    _sum?: UserImageBannerSumAggregateInputType
    _min?: UserImageBannerMinAggregateInputType
    _max?: UserImageBannerMaxAggregateInputType
  }

  export type UserImageBannerGroupByOutputType = {
    id: string
    url: string | null
    imgUrl: string
    alt: string | null
    sortOrder: number
    userId: string
    _count: UserImageBannerCountAggregateOutputType | null
    _avg: UserImageBannerAvgAggregateOutputType | null
    _sum: UserImageBannerSumAggregateOutputType | null
    _min: UserImageBannerMinAggregateOutputType | null
    _max: UserImageBannerMaxAggregateOutputType | null
  }

  type GetUserImageBannerGroupByPayload<T extends UserImageBannerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserImageBannerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserImageBannerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserImageBannerGroupByOutputType[P]>
            : GetScalarType<T[P], UserImageBannerGroupByOutputType[P]>
        }
      >
    >


  export type UserImageBannerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    imgUrl?: boolean
    alt?: boolean
    sortOrder?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userImageBanner"]>

  export type UserImageBannerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    imgUrl?: boolean
    alt?: boolean
    sortOrder?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userImageBanner"]>

  export type UserImageBannerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    imgUrl?: boolean
    alt?: boolean
    sortOrder?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userImageBanner"]>

  export type UserImageBannerSelectScalar = {
    id?: boolean
    url?: boolean
    imgUrl?: boolean
    alt?: boolean
    sortOrder?: boolean
    userId?: boolean
  }

  export type UserImageBannerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "imgUrl" | "alt" | "sortOrder" | "userId", ExtArgs["result"]["userImageBanner"]>
  export type UserImageBannerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserImageBannerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserImageBannerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserImageBannerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserImageBanner"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string | null
      imgUrl: string
      alt: string | null
      sortOrder: number
      userId: string
    }, ExtArgs["result"]["userImageBanner"]>
    composites: {}
  }

  type UserImageBannerGetPayload<S extends boolean | null | undefined | UserImageBannerDefaultArgs> = $Result.GetResult<Prisma.$UserImageBannerPayload, S>

  type UserImageBannerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserImageBannerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserImageBannerCountAggregateInputType | true
    }

  export interface UserImageBannerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserImageBanner'], meta: { name: 'UserImageBanner' } }
    /**
     * Find zero or one UserImageBanner that matches the filter.
     * @param {UserImageBannerFindUniqueArgs} args - Arguments to find a UserImageBanner
     * @example
     * // Get one UserImageBanner
     * const userImageBanner = await prisma.userImageBanner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserImageBannerFindUniqueArgs>(args: SelectSubset<T, UserImageBannerFindUniqueArgs<ExtArgs>>): Prisma__UserImageBannerClient<$Result.GetResult<Prisma.$UserImageBannerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserImageBanner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserImageBannerFindUniqueOrThrowArgs} args - Arguments to find a UserImageBanner
     * @example
     * // Get one UserImageBanner
     * const userImageBanner = await prisma.userImageBanner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserImageBannerFindUniqueOrThrowArgs>(args: SelectSubset<T, UserImageBannerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserImageBannerClient<$Result.GetResult<Prisma.$UserImageBannerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserImageBanner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserImageBannerFindFirstArgs} args - Arguments to find a UserImageBanner
     * @example
     * // Get one UserImageBanner
     * const userImageBanner = await prisma.userImageBanner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserImageBannerFindFirstArgs>(args?: SelectSubset<T, UserImageBannerFindFirstArgs<ExtArgs>>): Prisma__UserImageBannerClient<$Result.GetResult<Prisma.$UserImageBannerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserImageBanner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserImageBannerFindFirstOrThrowArgs} args - Arguments to find a UserImageBanner
     * @example
     * // Get one UserImageBanner
     * const userImageBanner = await prisma.userImageBanner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserImageBannerFindFirstOrThrowArgs>(args?: SelectSubset<T, UserImageBannerFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserImageBannerClient<$Result.GetResult<Prisma.$UserImageBannerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserImageBanners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserImageBannerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserImageBanners
     * const userImageBanners = await prisma.userImageBanner.findMany()
     * 
     * // Get first 10 UserImageBanners
     * const userImageBanners = await prisma.userImageBanner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userImageBannerWithIdOnly = await prisma.userImageBanner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserImageBannerFindManyArgs>(args?: SelectSubset<T, UserImageBannerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserImageBannerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserImageBanner.
     * @param {UserImageBannerCreateArgs} args - Arguments to create a UserImageBanner.
     * @example
     * // Create one UserImageBanner
     * const UserImageBanner = await prisma.userImageBanner.create({
     *   data: {
     *     // ... data to create a UserImageBanner
     *   }
     * })
     * 
     */
    create<T extends UserImageBannerCreateArgs>(args: SelectSubset<T, UserImageBannerCreateArgs<ExtArgs>>): Prisma__UserImageBannerClient<$Result.GetResult<Prisma.$UserImageBannerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserImageBanners.
     * @param {UserImageBannerCreateManyArgs} args - Arguments to create many UserImageBanners.
     * @example
     * // Create many UserImageBanners
     * const userImageBanner = await prisma.userImageBanner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserImageBannerCreateManyArgs>(args?: SelectSubset<T, UserImageBannerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserImageBanners and returns the data saved in the database.
     * @param {UserImageBannerCreateManyAndReturnArgs} args - Arguments to create many UserImageBanners.
     * @example
     * // Create many UserImageBanners
     * const userImageBanner = await prisma.userImageBanner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserImageBanners and only return the `id`
     * const userImageBannerWithIdOnly = await prisma.userImageBanner.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserImageBannerCreateManyAndReturnArgs>(args?: SelectSubset<T, UserImageBannerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserImageBannerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserImageBanner.
     * @param {UserImageBannerDeleteArgs} args - Arguments to delete one UserImageBanner.
     * @example
     * // Delete one UserImageBanner
     * const UserImageBanner = await prisma.userImageBanner.delete({
     *   where: {
     *     // ... filter to delete one UserImageBanner
     *   }
     * })
     * 
     */
    delete<T extends UserImageBannerDeleteArgs>(args: SelectSubset<T, UserImageBannerDeleteArgs<ExtArgs>>): Prisma__UserImageBannerClient<$Result.GetResult<Prisma.$UserImageBannerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserImageBanner.
     * @param {UserImageBannerUpdateArgs} args - Arguments to update one UserImageBanner.
     * @example
     * // Update one UserImageBanner
     * const userImageBanner = await prisma.userImageBanner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserImageBannerUpdateArgs>(args: SelectSubset<T, UserImageBannerUpdateArgs<ExtArgs>>): Prisma__UserImageBannerClient<$Result.GetResult<Prisma.$UserImageBannerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserImageBanners.
     * @param {UserImageBannerDeleteManyArgs} args - Arguments to filter UserImageBanners to delete.
     * @example
     * // Delete a few UserImageBanners
     * const { count } = await prisma.userImageBanner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserImageBannerDeleteManyArgs>(args?: SelectSubset<T, UserImageBannerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserImageBanners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserImageBannerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserImageBanners
     * const userImageBanner = await prisma.userImageBanner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserImageBannerUpdateManyArgs>(args: SelectSubset<T, UserImageBannerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserImageBanners and returns the data updated in the database.
     * @param {UserImageBannerUpdateManyAndReturnArgs} args - Arguments to update many UserImageBanners.
     * @example
     * // Update many UserImageBanners
     * const userImageBanner = await prisma.userImageBanner.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserImageBanners and only return the `id`
     * const userImageBannerWithIdOnly = await prisma.userImageBanner.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserImageBannerUpdateManyAndReturnArgs>(args: SelectSubset<T, UserImageBannerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserImageBannerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserImageBanner.
     * @param {UserImageBannerUpsertArgs} args - Arguments to update or create a UserImageBanner.
     * @example
     * // Update or create a UserImageBanner
     * const userImageBanner = await prisma.userImageBanner.upsert({
     *   create: {
     *     // ... data to create a UserImageBanner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserImageBanner we want to update
     *   }
     * })
     */
    upsert<T extends UserImageBannerUpsertArgs>(args: SelectSubset<T, UserImageBannerUpsertArgs<ExtArgs>>): Prisma__UserImageBannerClient<$Result.GetResult<Prisma.$UserImageBannerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserImageBanners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserImageBannerCountArgs} args - Arguments to filter UserImageBanners to count.
     * @example
     * // Count the number of UserImageBanners
     * const count = await prisma.userImageBanner.count({
     *   where: {
     *     // ... the filter for the UserImageBanners we want to count
     *   }
     * })
    **/
    count<T extends UserImageBannerCountArgs>(
      args?: Subset<T, UserImageBannerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserImageBannerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserImageBanner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserImageBannerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserImageBannerAggregateArgs>(args: Subset<T, UserImageBannerAggregateArgs>): Prisma.PrismaPromise<GetUserImageBannerAggregateType<T>>

    /**
     * Group by UserImageBanner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserImageBannerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserImageBannerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserImageBannerGroupByArgs['orderBy'] }
        : { orderBy?: UserImageBannerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserImageBannerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserImageBannerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserImageBanner model
   */
  readonly fields: UserImageBannerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserImageBanner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserImageBannerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserImageBanner model
   */
  interface UserImageBannerFieldRefs {
    readonly id: FieldRef<"UserImageBanner", 'String'>
    readonly url: FieldRef<"UserImageBanner", 'String'>
    readonly imgUrl: FieldRef<"UserImageBanner", 'String'>
    readonly alt: FieldRef<"UserImageBanner", 'String'>
    readonly sortOrder: FieldRef<"UserImageBanner", 'Int'>
    readonly userId: FieldRef<"UserImageBanner", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserImageBanner findUnique
   */
  export type UserImageBannerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageBanner
     */
    select?: UserImageBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageBanner
     */
    omit?: UserImageBannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageBannerInclude<ExtArgs> | null
    /**
     * Filter, which UserImageBanner to fetch.
     */
    where: UserImageBannerWhereUniqueInput
  }

  /**
   * UserImageBanner findUniqueOrThrow
   */
  export type UserImageBannerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageBanner
     */
    select?: UserImageBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageBanner
     */
    omit?: UserImageBannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageBannerInclude<ExtArgs> | null
    /**
     * Filter, which UserImageBanner to fetch.
     */
    where: UserImageBannerWhereUniqueInput
  }

  /**
   * UserImageBanner findFirst
   */
  export type UserImageBannerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageBanner
     */
    select?: UserImageBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageBanner
     */
    omit?: UserImageBannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageBannerInclude<ExtArgs> | null
    /**
     * Filter, which UserImageBanner to fetch.
     */
    where?: UserImageBannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserImageBanners to fetch.
     */
    orderBy?: UserImageBannerOrderByWithRelationInput | UserImageBannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserImageBanners.
     */
    cursor?: UserImageBannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserImageBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserImageBanners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserImageBanners.
     */
    distinct?: UserImageBannerScalarFieldEnum | UserImageBannerScalarFieldEnum[]
  }

  /**
   * UserImageBanner findFirstOrThrow
   */
  export type UserImageBannerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageBanner
     */
    select?: UserImageBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageBanner
     */
    omit?: UserImageBannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageBannerInclude<ExtArgs> | null
    /**
     * Filter, which UserImageBanner to fetch.
     */
    where?: UserImageBannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserImageBanners to fetch.
     */
    orderBy?: UserImageBannerOrderByWithRelationInput | UserImageBannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserImageBanners.
     */
    cursor?: UserImageBannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserImageBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserImageBanners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserImageBanners.
     */
    distinct?: UserImageBannerScalarFieldEnum | UserImageBannerScalarFieldEnum[]
  }

  /**
   * UserImageBanner findMany
   */
  export type UserImageBannerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageBanner
     */
    select?: UserImageBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageBanner
     */
    omit?: UserImageBannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageBannerInclude<ExtArgs> | null
    /**
     * Filter, which UserImageBanners to fetch.
     */
    where?: UserImageBannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserImageBanners to fetch.
     */
    orderBy?: UserImageBannerOrderByWithRelationInput | UserImageBannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserImageBanners.
     */
    cursor?: UserImageBannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserImageBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserImageBanners.
     */
    skip?: number
    distinct?: UserImageBannerScalarFieldEnum | UserImageBannerScalarFieldEnum[]
  }

  /**
   * UserImageBanner create
   */
  export type UserImageBannerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageBanner
     */
    select?: UserImageBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageBanner
     */
    omit?: UserImageBannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageBannerInclude<ExtArgs> | null
    /**
     * The data needed to create a UserImageBanner.
     */
    data: XOR<UserImageBannerCreateInput, UserImageBannerUncheckedCreateInput>
  }

  /**
   * UserImageBanner createMany
   */
  export type UserImageBannerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserImageBanners.
     */
    data: UserImageBannerCreateManyInput | UserImageBannerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserImageBanner createManyAndReturn
   */
  export type UserImageBannerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageBanner
     */
    select?: UserImageBannerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageBanner
     */
    omit?: UserImageBannerOmit<ExtArgs> | null
    /**
     * The data used to create many UserImageBanners.
     */
    data: UserImageBannerCreateManyInput | UserImageBannerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageBannerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserImageBanner update
   */
  export type UserImageBannerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageBanner
     */
    select?: UserImageBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageBanner
     */
    omit?: UserImageBannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageBannerInclude<ExtArgs> | null
    /**
     * The data needed to update a UserImageBanner.
     */
    data: XOR<UserImageBannerUpdateInput, UserImageBannerUncheckedUpdateInput>
    /**
     * Choose, which UserImageBanner to update.
     */
    where: UserImageBannerWhereUniqueInput
  }

  /**
   * UserImageBanner updateMany
   */
  export type UserImageBannerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserImageBanners.
     */
    data: XOR<UserImageBannerUpdateManyMutationInput, UserImageBannerUncheckedUpdateManyInput>
    /**
     * Filter which UserImageBanners to update
     */
    where?: UserImageBannerWhereInput
    /**
     * Limit how many UserImageBanners to update.
     */
    limit?: number
  }

  /**
   * UserImageBanner updateManyAndReturn
   */
  export type UserImageBannerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageBanner
     */
    select?: UserImageBannerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageBanner
     */
    omit?: UserImageBannerOmit<ExtArgs> | null
    /**
     * The data used to update UserImageBanners.
     */
    data: XOR<UserImageBannerUpdateManyMutationInput, UserImageBannerUncheckedUpdateManyInput>
    /**
     * Filter which UserImageBanners to update
     */
    where?: UserImageBannerWhereInput
    /**
     * Limit how many UserImageBanners to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageBannerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserImageBanner upsert
   */
  export type UserImageBannerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageBanner
     */
    select?: UserImageBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageBanner
     */
    omit?: UserImageBannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageBannerInclude<ExtArgs> | null
    /**
     * The filter to search for the UserImageBanner to update in case it exists.
     */
    where: UserImageBannerWhereUniqueInput
    /**
     * In case the UserImageBanner found by the `where` argument doesn't exist, create a new UserImageBanner with this data.
     */
    create: XOR<UserImageBannerCreateInput, UserImageBannerUncheckedCreateInput>
    /**
     * In case the UserImageBanner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserImageBannerUpdateInput, UserImageBannerUncheckedUpdateInput>
  }

  /**
   * UserImageBanner delete
   */
  export type UserImageBannerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageBanner
     */
    select?: UserImageBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageBanner
     */
    omit?: UserImageBannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageBannerInclude<ExtArgs> | null
    /**
     * Filter which UserImageBanner to delete.
     */
    where: UserImageBannerWhereUniqueInput
  }

  /**
   * UserImageBanner deleteMany
   */
  export type UserImageBannerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserImageBanners to delete
     */
    where?: UserImageBannerWhereInput
    /**
     * Limit how many UserImageBanners to delete.
     */
    limit?: number
  }

  /**
   * UserImageBanner without action
   */
  export type UserImageBannerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageBanner
     */
    select?: UserImageBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageBanner
     */
    omit?: UserImageBannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageBannerInclude<ExtArgs> | null
  }


  /**
   * Model UserYoutubeVideo
   */

  export type AggregateUserYoutubeVideo = {
    _count: UserYoutubeVideoCountAggregateOutputType | null
    _min: UserYoutubeVideoMinAggregateOutputType | null
    _max: UserYoutubeVideoMaxAggregateOutputType | null
  }

  export type UserYoutubeVideoMinAggregateOutputType = {
    id: string | null
    url: string | null
    thumbnailUrl: string | null
    title: string | null
    description: string | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    settingsId: string | null
  }

  export type UserYoutubeVideoMaxAggregateOutputType = {
    id: string | null
    url: string | null
    thumbnailUrl: string | null
    title: string | null
    description: string | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    settingsId: string | null
  }

  export type UserYoutubeVideoCountAggregateOutputType = {
    id: number
    url: number
    thumbnailUrl: number
    title: number
    description: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    settingsId: number
    _all: number
  }


  export type UserYoutubeVideoMinAggregateInputType = {
    id?: true
    url?: true
    thumbnailUrl?: true
    title?: true
    description?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    settingsId?: true
  }

  export type UserYoutubeVideoMaxAggregateInputType = {
    id?: true
    url?: true
    thumbnailUrl?: true
    title?: true
    description?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    settingsId?: true
  }

  export type UserYoutubeVideoCountAggregateInputType = {
    id?: true
    url?: true
    thumbnailUrl?: true
    title?: true
    description?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    settingsId?: true
    _all?: true
  }

  export type UserYoutubeVideoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserYoutubeVideo to aggregate.
     */
    where?: UserYoutubeVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserYoutubeVideos to fetch.
     */
    orderBy?: UserYoutubeVideoOrderByWithRelationInput | UserYoutubeVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserYoutubeVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserYoutubeVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserYoutubeVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserYoutubeVideos
    **/
    _count?: true | UserYoutubeVideoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserYoutubeVideoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserYoutubeVideoMaxAggregateInputType
  }

  export type GetUserYoutubeVideoAggregateType<T extends UserYoutubeVideoAggregateArgs> = {
        [P in keyof T & keyof AggregateUserYoutubeVideo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserYoutubeVideo[P]>
      : GetScalarType<T[P], AggregateUserYoutubeVideo[P]>
  }




  export type UserYoutubeVideoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserYoutubeVideoWhereInput
    orderBy?: UserYoutubeVideoOrderByWithAggregationInput | UserYoutubeVideoOrderByWithAggregationInput[]
    by: UserYoutubeVideoScalarFieldEnum[] | UserYoutubeVideoScalarFieldEnum
    having?: UserYoutubeVideoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserYoutubeVideoCountAggregateInputType | true
    _min?: UserYoutubeVideoMinAggregateInputType
    _max?: UserYoutubeVideoMaxAggregateInputType
  }

  export type UserYoutubeVideoGroupByOutputType = {
    id: string
    url: string
    thumbnailUrl: string | null
    title: string | null
    description: string | null
    publishedAt: Date | null
    createdAt: Date
    updatedAt: Date
    settingsId: string
    _count: UserYoutubeVideoCountAggregateOutputType | null
    _min: UserYoutubeVideoMinAggregateOutputType | null
    _max: UserYoutubeVideoMaxAggregateOutputType | null
  }

  type GetUserYoutubeVideoGroupByPayload<T extends UserYoutubeVideoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserYoutubeVideoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserYoutubeVideoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserYoutubeVideoGroupByOutputType[P]>
            : GetScalarType<T[P], UserYoutubeVideoGroupByOutputType[P]>
        }
      >
    >


  export type UserYoutubeVideoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    title?: boolean
    description?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    settingsId?: boolean
    settings?: boolean | UserYoutubeSettingsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userYoutubeVideo"]>

  export type UserYoutubeVideoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    title?: boolean
    description?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    settingsId?: boolean
    settings?: boolean | UserYoutubeSettingsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userYoutubeVideo"]>

  export type UserYoutubeVideoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    title?: boolean
    description?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    settingsId?: boolean
    settings?: boolean | UserYoutubeSettingsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userYoutubeVideo"]>

  export type UserYoutubeVideoSelectScalar = {
    id?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    title?: boolean
    description?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    settingsId?: boolean
  }

  export type UserYoutubeVideoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "thumbnailUrl" | "title" | "description" | "publishedAt" | "createdAt" | "updatedAt" | "settingsId", ExtArgs["result"]["userYoutubeVideo"]>
  export type UserYoutubeVideoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    settings?: boolean | UserYoutubeSettingsDefaultArgs<ExtArgs>
  }
  export type UserYoutubeVideoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    settings?: boolean | UserYoutubeSettingsDefaultArgs<ExtArgs>
  }
  export type UserYoutubeVideoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    settings?: boolean | UserYoutubeSettingsDefaultArgs<ExtArgs>
  }

  export type $UserYoutubeVideoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserYoutubeVideo"
    objects: {
      settings: Prisma.$UserYoutubeSettingsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      thumbnailUrl: string | null
      title: string | null
      description: string | null
      publishedAt: Date | null
      createdAt: Date
      updatedAt: Date
      settingsId: string
    }, ExtArgs["result"]["userYoutubeVideo"]>
    composites: {}
  }

  type UserYoutubeVideoGetPayload<S extends boolean | null | undefined | UserYoutubeVideoDefaultArgs> = $Result.GetResult<Prisma.$UserYoutubeVideoPayload, S>

  type UserYoutubeVideoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserYoutubeVideoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserYoutubeVideoCountAggregateInputType | true
    }

  export interface UserYoutubeVideoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserYoutubeVideo'], meta: { name: 'UserYoutubeVideo' } }
    /**
     * Find zero or one UserYoutubeVideo that matches the filter.
     * @param {UserYoutubeVideoFindUniqueArgs} args - Arguments to find a UserYoutubeVideo
     * @example
     * // Get one UserYoutubeVideo
     * const userYoutubeVideo = await prisma.userYoutubeVideo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserYoutubeVideoFindUniqueArgs>(args: SelectSubset<T, UserYoutubeVideoFindUniqueArgs<ExtArgs>>): Prisma__UserYoutubeVideoClient<$Result.GetResult<Prisma.$UserYoutubeVideoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserYoutubeVideo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserYoutubeVideoFindUniqueOrThrowArgs} args - Arguments to find a UserYoutubeVideo
     * @example
     * // Get one UserYoutubeVideo
     * const userYoutubeVideo = await prisma.userYoutubeVideo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserYoutubeVideoFindUniqueOrThrowArgs>(args: SelectSubset<T, UserYoutubeVideoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserYoutubeVideoClient<$Result.GetResult<Prisma.$UserYoutubeVideoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserYoutubeVideo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserYoutubeVideoFindFirstArgs} args - Arguments to find a UserYoutubeVideo
     * @example
     * // Get one UserYoutubeVideo
     * const userYoutubeVideo = await prisma.userYoutubeVideo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserYoutubeVideoFindFirstArgs>(args?: SelectSubset<T, UserYoutubeVideoFindFirstArgs<ExtArgs>>): Prisma__UserYoutubeVideoClient<$Result.GetResult<Prisma.$UserYoutubeVideoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserYoutubeVideo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserYoutubeVideoFindFirstOrThrowArgs} args - Arguments to find a UserYoutubeVideo
     * @example
     * // Get one UserYoutubeVideo
     * const userYoutubeVideo = await prisma.userYoutubeVideo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserYoutubeVideoFindFirstOrThrowArgs>(args?: SelectSubset<T, UserYoutubeVideoFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserYoutubeVideoClient<$Result.GetResult<Prisma.$UserYoutubeVideoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserYoutubeVideos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserYoutubeVideoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserYoutubeVideos
     * const userYoutubeVideos = await prisma.userYoutubeVideo.findMany()
     * 
     * // Get first 10 UserYoutubeVideos
     * const userYoutubeVideos = await prisma.userYoutubeVideo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userYoutubeVideoWithIdOnly = await prisma.userYoutubeVideo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserYoutubeVideoFindManyArgs>(args?: SelectSubset<T, UserYoutubeVideoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserYoutubeVideoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserYoutubeVideo.
     * @param {UserYoutubeVideoCreateArgs} args - Arguments to create a UserYoutubeVideo.
     * @example
     * // Create one UserYoutubeVideo
     * const UserYoutubeVideo = await prisma.userYoutubeVideo.create({
     *   data: {
     *     // ... data to create a UserYoutubeVideo
     *   }
     * })
     * 
     */
    create<T extends UserYoutubeVideoCreateArgs>(args: SelectSubset<T, UserYoutubeVideoCreateArgs<ExtArgs>>): Prisma__UserYoutubeVideoClient<$Result.GetResult<Prisma.$UserYoutubeVideoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserYoutubeVideos.
     * @param {UserYoutubeVideoCreateManyArgs} args - Arguments to create many UserYoutubeVideos.
     * @example
     * // Create many UserYoutubeVideos
     * const userYoutubeVideo = await prisma.userYoutubeVideo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserYoutubeVideoCreateManyArgs>(args?: SelectSubset<T, UserYoutubeVideoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserYoutubeVideos and returns the data saved in the database.
     * @param {UserYoutubeVideoCreateManyAndReturnArgs} args - Arguments to create many UserYoutubeVideos.
     * @example
     * // Create many UserYoutubeVideos
     * const userYoutubeVideo = await prisma.userYoutubeVideo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserYoutubeVideos and only return the `id`
     * const userYoutubeVideoWithIdOnly = await prisma.userYoutubeVideo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserYoutubeVideoCreateManyAndReturnArgs>(args?: SelectSubset<T, UserYoutubeVideoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserYoutubeVideoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserYoutubeVideo.
     * @param {UserYoutubeVideoDeleteArgs} args - Arguments to delete one UserYoutubeVideo.
     * @example
     * // Delete one UserYoutubeVideo
     * const UserYoutubeVideo = await prisma.userYoutubeVideo.delete({
     *   where: {
     *     // ... filter to delete one UserYoutubeVideo
     *   }
     * })
     * 
     */
    delete<T extends UserYoutubeVideoDeleteArgs>(args: SelectSubset<T, UserYoutubeVideoDeleteArgs<ExtArgs>>): Prisma__UserYoutubeVideoClient<$Result.GetResult<Prisma.$UserYoutubeVideoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserYoutubeVideo.
     * @param {UserYoutubeVideoUpdateArgs} args - Arguments to update one UserYoutubeVideo.
     * @example
     * // Update one UserYoutubeVideo
     * const userYoutubeVideo = await prisma.userYoutubeVideo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserYoutubeVideoUpdateArgs>(args: SelectSubset<T, UserYoutubeVideoUpdateArgs<ExtArgs>>): Prisma__UserYoutubeVideoClient<$Result.GetResult<Prisma.$UserYoutubeVideoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserYoutubeVideos.
     * @param {UserYoutubeVideoDeleteManyArgs} args - Arguments to filter UserYoutubeVideos to delete.
     * @example
     * // Delete a few UserYoutubeVideos
     * const { count } = await prisma.userYoutubeVideo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserYoutubeVideoDeleteManyArgs>(args?: SelectSubset<T, UserYoutubeVideoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserYoutubeVideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserYoutubeVideoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserYoutubeVideos
     * const userYoutubeVideo = await prisma.userYoutubeVideo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserYoutubeVideoUpdateManyArgs>(args: SelectSubset<T, UserYoutubeVideoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserYoutubeVideos and returns the data updated in the database.
     * @param {UserYoutubeVideoUpdateManyAndReturnArgs} args - Arguments to update many UserYoutubeVideos.
     * @example
     * // Update many UserYoutubeVideos
     * const userYoutubeVideo = await prisma.userYoutubeVideo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserYoutubeVideos and only return the `id`
     * const userYoutubeVideoWithIdOnly = await prisma.userYoutubeVideo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserYoutubeVideoUpdateManyAndReturnArgs>(args: SelectSubset<T, UserYoutubeVideoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserYoutubeVideoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserYoutubeVideo.
     * @param {UserYoutubeVideoUpsertArgs} args - Arguments to update or create a UserYoutubeVideo.
     * @example
     * // Update or create a UserYoutubeVideo
     * const userYoutubeVideo = await prisma.userYoutubeVideo.upsert({
     *   create: {
     *     // ... data to create a UserYoutubeVideo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserYoutubeVideo we want to update
     *   }
     * })
     */
    upsert<T extends UserYoutubeVideoUpsertArgs>(args: SelectSubset<T, UserYoutubeVideoUpsertArgs<ExtArgs>>): Prisma__UserYoutubeVideoClient<$Result.GetResult<Prisma.$UserYoutubeVideoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserYoutubeVideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserYoutubeVideoCountArgs} args - Arguments to filter UserYoutubeVideos to count.
     * @example
     * // Count the number of UserYoutubeVideos
     * const count = await prisma.userYoutubeVideo.count({
     *   where: {
     *     // ... the filter for the UserYoutubeVideos we want to count
     *   }
     * })
    **/
    count<T extends UserYoutubeVideoCountArgs>(
      args?: Subset<T, UserYoutubeVideoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserYoutubeVideoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserYoutubeVideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserYoutubeVideoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserYoutubeVideoAggregateArgs>(args: Subset<T, UserYoutubeVideoAggregateArgs>): Prisma.PrismaPromise<GetUserYoutubeVideoAggregateType<T>>

    /**
     * Group by UserYoutubeVideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserYoutubeVideoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserYoutubeVideoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserYoutubeVideoGroupByArgs['orderBy'] }
        : { orderBy?: UserYoutubeVideoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserYoutubeVideoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserYoutubeVideoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserYoutubeVideo model
   */
  readonly fields: UserYoutubeVideoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserYoutubeVideo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserYoutubeVideoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    settings<T extends UserYoutubeSettingsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserYoutubeSettingsDefaultArgs<ExtArgs>>): Prisma__UserYoutubeSettingsClient<$Result.GetResult<Prisma.$UserYoutubeSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserYoutubeVideo model
   */
  interface UserYoutubeVideoFieldRefs {
    readonly id: FieldRef<"UserYoutubeVideo", 'String'>
    readonly url: FieldRef<"UserYoutubeVideo", 'String'>
    readonly thumbnailUrl: FieldRef<"UserYoutubeVideo", 'String'>
    readonly title: FieldRef<"UserYoutubeVideo", 'String'>
    readonly description: FieldRef<"UserYoutubeVideo", 'String'>
    readonly publishedAt: FieldRef<"UserYoutubeVideo", 'DateTime'>
    readonly createdAt: FieldRef<"UserYoutubeVideo", 'DateTime'>
    readonly updatedAt: FieldRef<"UserYoutubeVideo", 'DateTime'>
    readonly settingsId: FieldRef<"UserYoutubeVideo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserYoutubeVideo findUnique
   */
  export type UserYoutubeVideoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserYoutubeVideo
     */
    select?: UserYoutubeVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserYoutubeVideo
     */
    omit?: UserYoutubeVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserYoutubeVideoInclude<ExtArgs> | null
    /**
     * Filter, which UserYoutubeVideo to fetch.
     */
    where: UserYoutubeVideoWhereUniqueInput
  }

  /**
   * UserYoutubeVideo findUniqueOrThrow
   */
  export type UserYoutubeVideoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserYoutubeVideo
     */
    select?: UserYoutubeVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserYoutubeVideo
     */
    omit?: UserYoutubeVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserYoutubeVideoInclude<ExtArgs> | null
    /**
     * Filter, which UserYoutubeVideo to fetch.
     */
    where: UserYoutubeVideoWhereUniqueInput
  }

  /**
   * UserYoutubeVideo findFirst
   */
  export type UserYoutubeVideoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserYoutubeVideo
     */
    select?: UserYoutubeVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserYoutubeVideo
     */
    omit?: UserYoutubeVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserYoutubeVideoInclude<ExtArgs> | null
    /**
     * Filter, which UserYoutubeVideo to fetch.
     */
    where?: UserYoutubeVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserYoutubeVideos to fetch.
     */
    orderBy?: UserYoutubeVideoOrderByWithRelationInput | UserYoutubeVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserYoutubeVideos.
     */
    cursor?: UserYoutubeVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserYoutubeVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserYoutubeVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserYoutubeVideos.
     */
    distinct?: UserYoutubeVideoScalarFieldEnum | UserYoutubeVideoScalarFieldEnum[]
  }

  /**
   * UserYoutubeVideo findFirstOrThrow
   */
  export type UserYoutubeVideoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserYoutubeVideo
     */
    select?: UserYoutubeVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserYoutubeVideo
     */
    omit?: UserYoutubeVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserYoutubeVideoInclude<ExtArgs> | null
    /**
     * Filter, which UserYoutubeVideo to fetch.
     */
    where?: UserYoutubeVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserYoutubeVideos to fetch.
     */
    orderBy?: UserYoutubeVideoOrderByWithRelationInput | UserYoutubeVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserYoutubeVideos.
     */
    cursor?: UserYoutubeVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserYoutubeVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserYoutubeVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserYoutubeVideos.
     */
    distinct?: UserYoutubeVideoScalarFieldEnum | UserYoutubeVideoScalarFieldEnum[]
  }

  /**
   * UserYoutubeVideo findMany
   */
  export type UserYoutubeVideoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserYoutubeVideo
     */
    select?: UserYoutubeVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserYoutubeVideo
     */
    omit?: UserYoutubeVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserYoutubeVideoInclude<ExtArgs> | null
    /**
     * Filter, which UserYoutubeVideos to fetch.
     */
    where?: UserYoutubeVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserYoutubeVideos to fetch.
     */
    orderBy?: UserYoutubeVideoOrderByWithRelationInput | UserYoutubeVideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserYoutubeVideos.
     */
    cursor?: UserYoutubeVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserYoutubeVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserYoutubeVideos.
     */
    skip?: number
    distinct?: UserYoutubeVideoScalarFieldEnum | UserYoutubeVideoScalarFieldEnum[]
  }

  /**
   * UserYoutubeVideo create
   */
  export type UserYoutubeVideoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserYoutubeVideo
     */
    select?: UserYoutubeVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserYoutubeVideo
     */
    omit?: UserYoutubeVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserYoutubeVideoInclude<ExtArgs> | null
    /**
     * The data needed to create a UserYoutubeVideo.
     */
    data: XOR<UserYoutubeVideoCreateInput, UserYoutubeVideoUncheckedCreateInput>
  }

  /**
   * UserYoutubeVideo createMany
   */
  export type UserYoutubeVideoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserYoutubeVideos.
     */
    data: UserYoutubeVideoCreateManyInput | UserYoutubeVideoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserYoutubeVideo createManyAndReturn
   */
  export type UserYoutubeVideoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserYoutubeVideo
     */
    select?: UserYoutubeVideoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserYoutubeVideo
     */
    omit?: UserYoutubeVideoOmit<ExtArgs> | null
    /**
     * The data used to create many UserYoutubeVideos.
     */
    data: UserYoutubeVideoCreateManyInput | UserYoutubeVideoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserYoutubeVideoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserYoutubeVideo update
   */
  export type UserYoutubeVideoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserYoutubeVideo
     */
    select?: UserYoutubeVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserYoutubeVideo
     */
    omit?: UserYoutubeVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserYoutubeVideoInclude<ExtArgs> | null
    /**
     * The data needed to update a UserYoutubeVideo.
     */
    data: XOR<UserYoutubeVideoUpdateInput, UserYoutubeVideoUncheckedUpdateInput>
    /**
     * Choose, which UserYoutubeVideo to update.
     */
    where: UserYoutubeVideoWhereUniqueInput
  }

  /**
   * UserYoutubeVideo updateMany
   */
  export type UserYoutubeVideoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserYoutubeVideos.
     */
    data: XOR<UserYoutubeVideoUpdateManyMutationInput, UserYoutubeVideoUncheckedUpdateManyInput>
    /**
     * Filter which UserYoutubeVideos to update
     */
    where?: UserYoutubeVideoWhereInput
    /**
     * Limit how many UserYoutubeVideos to update.
     */
    limit?: number
  }

  /**
   * UserYoutubeVideo updateManyAndReturn
   */
  export type UserYoutubeVideoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserYoutubeVideo
     */
    select?: UserYoutubeVideoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserYoutubeVideo
     */
    omit?: UserYoutubeVideoOmit<ExtArgs> | null
    /**
     * The data used to update UserYoutubeVideos.
     */
    data: XOR<UserYoutubeVideoUpdateManyMutationInput, UserYoutubeVideoUncheckedUpdateManyInput>
    /**
     * Filter which UserYoutubeVideos to update
     */
    where?: UserYoutubeVideoWhereInput
    /**
     * Limit how many UserYoutubeVideos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserYoutubeVideoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserYoutubeVideo upsert
   */
  export type UserYoutubeVideoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserYoutubeVideo
     */
    select?: UserYoutubeVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserYoutubeVideo
     */
    omit?: UserYoutubeVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserYoutubeVideoInclude<ExtArgs> | null
    /**
     * The filter to search for the UserYoutubeVideo to update in case it exists.
     */
    where: UserYoutubeVideoWhereUniqueInput
    /**
     * In case the UserYoutubeVideo found by the `where` argument doesn't exist, create a new UserYoutubeVideo with this data.
     */
    create: XOR<UserYoutubeVideoCreateInput, UserYoutubeVideoUncheckedCreateInput>
    /**
     * In case the UserYoutubeVideo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserYoutubeVideoUpdateInput, UserYoutubeVideoUncheckedUpdateInput>
  }

  /**
   * UserYoutubeVideo delete
   */
  export type UserYoutubeVideoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserYoutubeVideo
     */
    select?: UserYoutubeVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserYoutubeVideo
     */
    omit?: UserYoutubeVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserYoutubeVideoInclude<ExtArgs> | null
    /**
     * Filter which UserYoutubeVideo to delete.
     */
    where: UserYoutubeVideoWhereUniqueInput
  }

  /**
   * UserYoutubeVideo deleteMany
   */
  export type UserYoutubeVideoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserYoutubeVideos to delete
     */
    where?: UserYoutubeVideoWhereInput
    /**
     * Limit how many UserYoutubeVideos to delete.
     */
    limit?: number
  }

  /**
   * UserYoutubeVideo without action
   */
  export type UserYoutubeVideoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserYoutubeVideo
     */
    select?: UserYoutubeVideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserYoutubeVideo
     */
    omit?: UserYoutubeVideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserYoutubeVideoInclude<ExtArgs> | null
  }


  /**
   * Model UserRecommendYoutube
   */

  export type AggregateUserRecommendYoutube = {
    _count: UserRecommendYoutubeCountAggregateOutputType | null
    _avg: UserRecommendYoutubeAvgAggregateOutputType | null
    _sum: UserRecommendYoutubeSumAggregateOutputType | null
    _min: UserRecommendYoutubeMinAggregateOutputType | null
    _max: UserRecommendYoutubeMaxAggregateOutputType | null
  }

  export type UserRecommendYoutubeAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type UserRecommendYoutubeSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type UserRecommendYoutubeMinAggregateOutputType = {
    id: string | null
    url: string | null
    thumbnailUrl: string | null
    title: string | null
    description: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type UserRecommendYoutubeMaxAggregateOutputType = {
    id: string | null
    url: string | null
    thumbnailUrl: string | null
    title: string | null
    description: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type UserRecommendYoutubeCountAggregateOutputType = {
    id: number
    url: number
    thumbnailUrl: number
    title: number
    description: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type UserRecommendYoutubeAvgAggregateInputType = {
    sortOrder?: true
  }

  export type UserRecommendYoutubeSumAggregateInputType = {
    sortOrder?: true
  }

  export type UserRecommendYoutubeMinAggregateInputType = {
    id?: true
    url?: true
    thumbnailUrl?: true
    title?: true
    description?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type UserRecommendYoutubeMaxAggregateInputType = {
    id?: true
    url?: true
    thumbnailUrl?: true
    title?: true
    description?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type UserRecommendYoutubeCountAggregateInputType = {
    id?: true
    url?: true
    thumbnailUrl?: true
    title?: true
    description?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type UserRecommendYoutubeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRecommendYoutube to aggregate.
     */
    where?: UserRecommendYoutubeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRecommendYoutubes to fetch.
     */
    orderBy?: UserRecommendYoutubeOrderByWithRelationInput | UserRecommendYoutubeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRecommendYoutubeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRecommendYoutubes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRecommendYoutubes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRecommendYoutubes
    **/
    _count?: true | UserRecommendYoutubeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserRecommendYoutubeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserRecommendYoutubeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRecommendYoutubeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRecommendYoutubeMaxAggregateInputType
  }

  export type GetUserRecommendYoutubeAggregateType<T extends UserRecommendYoutubeAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRecommendYoutube]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRecommendYoutube[P]>
      : GetScalarType<T[P], AggregateUserRecommendYoutube[P]>
  }




  export type UserRecommendYoutubeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRecommendYoutubeWhereInput
    orderBy?: UserRecommendYoutubeOrderByWithAggregationInput | UserRecommendYoutubeOrderByWithAggregationInput[]
    by: UserRecommendYoutubeScalarFieldEnum[] | UserRecommendYoutubeScalarFieldEnum
    having?: UserRecommendYoutubeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRecommendYoutubeCountAggregateInputType | true
    _avg?: UserRecommendYoutubeAvgAggregateInputType
    _sum?: UserRecommendYoutubeSumAggregateInputType
    _min?: UserRecommendYoutubeMinAggregateInputType
    _max?: UserRecommendYoutubeMaxAggregateInputType
  }

  export type UserRecommendYoutubeGroupByOutputType = {
    id: string
    url: string
    thumbnailUrl: string | null
    title: string | null
    description: string | null
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    userId: string
    _count: UserRecommendYoutubeCountAggregateOutputType | null
    _avg: UserRecommendYoutubeAvgAggregateOutputType | null
    _sum: UserRecommendYoutubeSumAggregateOutputType | null
    _min: UserRecommendYoutubeMinAggregateOutputType | null
    _max: UserRecommendYoutubeMaxAggregateOutputType | null
  }

  type GetUserRecommendYoutubeGroupByPayload<T extends UserRecommendYoutubeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRecommendYoutubeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRecommendYoutubeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRecommendYoutubeGroupByOutputType[P]>
            : GetScalarType<T[P], UserRecommendYoutubeGroupByOutputType[P]>
        }
      >
    >


  export type UserRecommendYoutubeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    title?: boolean
    description?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRecommendYoutube"]>

  export type UserRecommendYoutubeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    title?: boolean
    description?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRecommendYoutube"]>

  export type UserRecommendYoutubeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    title?: boolean
    description?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRecommendYoutube"]>

  export type UserRecommendYoutubeSelectScalar = {
    id?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    title?: boolean
    description?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type UserRecommendYoutubeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "thumbnailUrl" | "title" | "description" | "sortOrder" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["userRecommendYoutube"]>
  export type UserRecommendYoutubeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserRecommendYoutubeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserRecommendYoutubeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserRecommendYoutubePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRecommendYoutube"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      thumbnailUrl: string | null
      title: string | null
      description: string | null
      sortOrder: number
      createdAt: Date
      updatedAt: Date
      userId: string
    }, ExtArgs["result"]["userRecommendYoutube"]>
    composites: {}
  }

  type UserRecommendYoutubeGetPayload<S extends boolean | null | undefined | UserRecommendYoutubeDefaultArgs> = $Result.GetResult<Prisma.$UserRecommendYoutubePayload, S>

  type UserRecommendYoutubeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserRecommendYoutubeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserRecommendYoutubeCountAggregateInputType | true
    }

  export interface UserRecommendYoutubeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRecommendYoutube'], meta: { name: 'UserRecommendYoutube' } }
    /**
     * Find zero or one UserRecommendYoutube that matches the filter.
     * @param {UserRecommendYoutubeFindUniqueArgs} args - Arguments to find a UserRecommendYoutube
     * @example
     * // Get one UserRecommendYoutube
     * const userRecommendYoutube = await prisma.userRecommendYoutube.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRecommendYoutubeFindUniqueArgs>(args: SelectSubset<T, UserRecommendYoutubeFindUniqueArgs<ExtArgs>>): Prisma__UserRecommendYoutubeClient<$Result.GetResult<Prisma.$UserRecommendYoutubePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserRecommendYoutube that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserRecommendYoutubeFindUniqueOrThrowArgs} args - Arguments to find a UserRecommendYoutube
     * @example
     * // Get one UserRecommendYoutube
     * const userRecommendYoutube = await prisma.userRecommendYoutube.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRecommendYoutubeFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRecommendYoutubeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRecommendYoutubeClient<$Result.GetResult<Prisma.$UserRecommendYoutubePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRecommendYoutube that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRecommendYoutubeFindFirstArgs} args - Arguments to find a UserRecommendYoutube
     * @example
     * // Get one UserRecommendYoutube
     * const userRecommendYoutube = await prisma.userRecommendYoutube.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRecommendYoutubeFindFirstArgs>(args?: SelectSubset<T, UserRecommendYoutubeFindFirstArgs<ExtArgs>>): Prisma__UserRecommendYoutubeClient<$Result.GetResult<Prisma.$UserRecommendYoutubePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRecommendYoutube that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRecommendYoutubeFindFirstOrThrowArgs} args - Arguments to find a UserRecommendYoutube
     * @example
     * // Get one UserRecommendYoutube
     * const userRecommendYoutube = await prisma.userRecommendYoutube.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRecommendYoutubeFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRecommendYoutubeFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRecommendYoutubeClient<$Result.GetResult<Prisma.$UserRecommendYoutubePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserRecommendYoutubes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRecommendYoutubeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRecommendYoutubes
     * const userRecommendYoutubes = await prisma.userRecommendYoutube.findMany()
     * 
     * // Get first 10 UserRecommendYoutubes
     * const userRecommendYoutubes = await prisma.userRecommendYoutube.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userRecommendYoutubeWithIdOnly = await prisma.userRecommendYoutube.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserRecommendYoutubeFindManyArgs>(args?: SelectSubset<T, UserRecommendYoutubeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRecommendYoutubePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserRecommendYoutube.
     * @param {UserRecommendYoutubeCreateArgs} args - Arguments to create a UserRecommendYoutube.
     * @example
     * // Create one UserRecommendYoutube
     * const UserRecommendYoutube = await prisma.userRecommendYoutube.create({
     *   data: {
     *     // ... data to create a UserRecommendYoutube
     *   }
     * })
     * 
     */
    create<T extends UserRecommendYoutubeCreateArgs>(args: SelectSubset<T, UserRecommendYoutubeCreateArgs<ExtArgs>>): Prisma__UserRecommendYoutubeClient<$Result.GetResult<Prisma.$UserRecommendYoutubePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserRecommendYoutubes.
     * @param {UserRecommendYoutubeCreateManyArgs} args - Arguments to create many UserRecommendYoutubes.
     * @example
     * // Create many UserRecommendYoutubes
     * const userRecommendYoutube = await prisma.userRecommendYoutube.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRecommendYoutubeCreateManyArgs>(args?: SelectSubset<T, UserRecommendYoutubeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRecommendYoutubes and returns the data saved in the database.
     * @param {UserRecommendYoutubeCreateManyAndReturnArgs} args - Arguments to create many UserRecommendYoutubes.
     * @example
     * // Create many UserRecommendYoutubes
     * const userRecommendYoutube = await prisma.userRecommendYoutube.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRecommendYoutubes and only return the `id`
     * const userRecommendYoutubeWithIdOnly = await prisma.userRecommendYoutube.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRecommendYoutubeCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRecommendYoutubeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRecommendYoutubePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserRecommendYoutube.
     * @param {UserRecommendYoutubeDeleteArgs} args - Arguments to delete one UserRecommendYoutube.
     * @example
     * // Delete one UserRecommendYoutube
     * const UserRecommendYoutube = await prisma.userRecommendYoutube.delete({
     *   where: {
     *     // ... filter to delete one UserRecommendYoutube
     *   }
     * })
     * 
     */
    delete<T extends UserRecommendYoutubeDeleteArgs>(args: SelectSubset<T, UserRecommendYoutubeDeleteArgs<ExtArgs>>): Prisma__UserRecommendYoutubeClient<$Result.GetResult<Prisma.$UserRecommendYoutubePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserRecommendYoutube.
     * @param {UserRecommendYoutubeUpdateArgs} args - Arguments to update one UserRecommendYoutube.
     * @example
     * // Update one UserRecommendYoutube
     * const userRecommendYoutube = await prisma.userRecommendYoutube.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRecommendYoutubeUpdateArgs>(args: SelectSubset<T, UserRecommendYoutubeUpdateArgs<ExtArgs>>): Prisma__UserRecommendYoutubeClient<$Result.GetResult<Prisma.$UserRecommendYoutubePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserRecommendYoutubes.
     * @param {UserRecommendYoutubeDeleteManyArgs} args - Arguments to filter UserRecommendYoutubes to delete.
     * @example
     * // Delete a few UserRecommendYoutubes
     * const { count } = await prisma.userRecommendYoutube.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRecommendYoutubeDeleteManyArgs>(args?: SelectSubset<T, UserRecommendYoutubeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRecommendYoutubes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRecommendYoutubeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRecommendYoutubes
     * const userRecommendYoutube = await prisma.userRecommendYoutube.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRecommendYoutubeUpdateManyArgs>(args: SelectSubset<T, UserRecommendYoutubeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRecommendYoutubes and returns the data updated in the database.
     * @param {UserRecommendYoutubeUpdateManyAndReturnArgs} args - Arguments to update many UserRecommendYoutubes.
     * @example
     * // Update many UserRecommendYoutubes
     * const userRecommendYoutube = await prisma.userRecommendYoutube.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserRecommendYoutubes and only return the `id`
     * const userRecommendYoutubeWithIdOnly = await prisma.userRecommendYoutube.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserRecommendYoutubeUpdateManyAndReturnArgs>(args: SelectSubset<T, UserRecommendYoutubeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRecommendYoutubePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserRecommendYoutube.
     * @param {UserRecommendYoutubeUpsertArgs} args - Arguments to update or create a UserRecommendYoutube.
     * @example
     * // Update or create a UserRecommendYoutube
     * const userRecommendYoutube = await prisma.userRecommendYoutube.upsert({
     *   create: {
     *     // ... data to create a UserRecommendYoutube
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRecommendYoutube we want to update
     *   }
     * })
     */
    upsert<T extends UserRecommendYoutubeUpsertArgs>(args: SelectSubset<T, UserRecommendYoutubeUpsertArgs<ExtArgs>>): Prisma__UserRecommendYoutubeClient<$Result.GetResult<Prisma.$UserRecommendYoutubePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserRecommendYoutubes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRecommendYoutubeCountArgs} args - Arguments to filter UserRecommendYoutubes to count.
     * @example
     * // Count the number of UserRecommendYoutubes
     * const count = await prisma.userRecommendYoutube.count({
     *   where: {
     *     // ... the filter for the UserRecommendYoutubes we want to count
     *   }
     * })
    **/
    count<T extends UserRecommendYoutubeCountArgs>(
      args?: Subset<T, UserRecommendYoutubeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRecommendYoutubeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRecommendYoutube.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRecommendYoutubeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRecommendYoutubeAggregateArgs>(args: Subset<T, UserRecommendYoutubeAggregateArgs>): Prisma.PrismaPromise<GetUserRecommendYoutubeAggregateType<T>>

    /**
     * Group by UserRecommendYoutube.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRecommendYoutubeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRecommendYoutubeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRecommendYoutubeGroupByArgs['orderBy'] }
        : { orderBy?: UserRecommendYoutubeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRecommendYoutubeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRecommendYoutubeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRecommendYoutube model
   */
  readonly fields: UserRecommendYoutubeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRecommendYoutube.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRecommendYoutubeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRecommendYoutube model
   */
  interface UserRecommendYoutubeFieldRefs {
    readonly id: FieldRef<"UserRecommendYoutube", 'String'>
    readonly url: FieldRef<"UserRecommendYoutube", 'String'>
    readonly thumbnailUrl: FieldRef<"UserRecommendYoutube", 'String'>
    readonly title: FieldRef<"UserRecommendYoutube", 'String'>
    readonly description: FieldRef<"UserRecommendYoutube", 'String'>
    readonly sortOrder: FieldRef<"UserRecommendYoutube", 'Int'>
    readonly createdAt: FieldRef<"UserRecommendYoutube", 'DateTime'>
    readonly updatedAt: FieldRef<"UserRecommendYoutube", 'DateTime'>
    readonly userId: FieldRef<"UserRecommendYoutube", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserRecommendYoutube findUnique
   */
  export type UserRecommendYoutubeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecommendYoutube
     */
    select?: UserRecommendYoutubeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecommendYoutube
     */
    omit?: UserRecommendYoutubeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRecommendYoutubeInclude<ExtArgs> | null
    /**
     * Filter, which UserRecommendYoutube to fetch.
     */
    where: UserRecommendYoutubeWhereUniqueInput
  }

  /**
   * UserRecommendYoutube findUniqueOrThrow
   */
  export type UserRecommendYoutubeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecommendYoutube
     */
    select?: UserRecommendYoutubeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecommendYoutube
     */
    omit?: UserRecommendYoutubeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRecommendYoutubeInclude<ExtArgs> | null
    /**
     * Filter, which UserRecommendYoutube to fetch.
     */
    where: UserRecommendYoutubeWhereUniqueInput
  }

  /**
   * UserRecommendYoutube findFirst
   */
  export type UserRecommendYoutubeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecommendYoutube
     */
    select?: UserRecommendYoutubeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecommendYoutube
     */
    omit?: UserRecommendYoutubeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRecommendYoutubeInclude<ExtArgs> | null
    /**
     * Filter, which UserRecommendYoutube to fetch.
     */
    where?: UserRecommendYoutubeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRecommendYoutubes to fetch.
     */
    orderBy?: UserRecommendYoutubeOrderByWithRelationInput | UserRecommendYoutubeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRecommendYoutubes.
     */
    cursor?: UserRecommendYoutubeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRecommendYoutubes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRecommendYoutubes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRecommendYoutubes.
     */
    distinct?: UserRecommendYoutubeScalarFieldEnum | UserRecommendYoutubeScalarFieldEnum[]
  }

  /**
   * UserRecommendYoutube findFirstOrThrow
   */
  export type UserRecommendYoutubeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecommendYoutube
     */
    select?: UserRecommendYoutubeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecommendYoutube
     */
    omit?: UserRecommendYoutubeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRecommendYoutubeInclude<ExtArgs> | null
    /**
     * Filter, which UserRecommendYoutube to fetch.
     */
    where?: UserRecommendYoutubeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRecommendYoutubes to fetch.
     */
    orderBy?: UserRecommendYoutubeOrderByWithRelationInput | UserRecommendYoutubeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRecommendYoutubes.
     */
    cursor?: UserRecommendYoutubeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRecommendYoutubes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRecommendYoutubes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRecommendYoutubes.
     */
    distinct?: UserRecommendYoutubeScalarFieldEnum | UserRecommendYoutubeScalarFieldEnum[]
  }

  /**
   * UserRecommendYoutube findMany
   */
  export type UserRecommendYoutubeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecommendYoutube
     */
    select?: UserRecommendYoutubeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecommendYoutube
     */
    omit?: UserRecommendYoutubeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRecommendYoutubeInclude<ExtArgs> | null
    /**
     * Filter, which UserRecommendYoutubes to fetch.
     */
    where?: UserRecommendYoutubeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRecommendYoutubes to fetch.
     */
    orderBy?: UserRecommendYoutubeOrderByWithRelationInput | UserRecommendYoutubeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRecommendYoutubes.
     */
    cursor?: UserRecommendYoutubeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRecommendYoutubes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRecommendYoutubes.
     */
    skip?: number
    distinct?: UserRecommendYoutubeScalarFieldEnum | UserRecommendYoutubeScalarFieldEnum[]
  }

  /**
   * UserRecommendYoutube create
   */
  export type UserRecommendYoutubeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecommendYoutube
     */
    select?: UserRecommendYoutubeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecommendYoutube
     */
    omit?: UserRecommendYoutubeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRecommendYoutubeInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRecommendYoutube.
     */
    data: XOR<UserRecommendYoutubeCreateInput, UserRecommendYoutubeUncheckedCreateInput>
  }

  /**
   * UserRecommendYoutube createMany
   */
  export type UserRecommendYoutubeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRecommendYoutubes.
     */
    data: UserRecommendYoutubeCreateManyInput | UserRecommendYoutubeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRecommendYoutube createManyAndReturn
   */
  export type UserRecommendYoutubeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecommendYoutube
     */
    select?: UserRecommendYoutubeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecommendYoutube
     */
    omit?: UserRecommendYoutubeOmit<ExtArgs> | null
    /**
     * The data used to create many UserRecommendYoutubes.
     */
    data: UserRecommendYoutubeCreateManyInput | UserRecommendYoutubeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRecommendYoutubeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRecommendYoutube update
   */
  export type UserRecommendYoutubeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecommendYoutube
     */
    select?: UserRecommendYoutubeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecommendYoutube
     */
    omit?: UserRecommendYoutubeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRecommendYoutubeInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRecommendYoutube.
     */
    data: XOR<UserRecommendYoutubeUpdateInput, UserRecommendYoutubeUncheckedUpdateInput>
    /**
     * Choose, which UserRecommendYoutube to update.
     */
    where: UserRecommendYoutubeWhereUniqueInput
  }

  /**
   * UserRecommendYoutube updateMany
   */
  export type UserRecommendYoutubeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRecommendYoutubes.
     */
    data: XOR<UserRecommendYoutubeUpdateManyMutationInput, UserRecommendYoutubeUncheckedUpdateManyInput>
    /**
     * Filter which UserRecommendYoutubes to update
     */
    where?: UserRecommendYoutubeWhereInput
    /**
     * Limit how many UserRecommendYoutubes to update.
     */
    limit?: number
  }

  /**
   * UserRecommendYoutube updateManyAndReturn
   */
  export type UserRecommendYoutubeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecommendYoutube
     */
    select?: UserRecommendYoutubeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecommendYoutube
     */
    omit?: UserRecommendYoutubeOmit<ExtArgs> | null
    /**
     * The data used to update UserRecommendYoutubes.
     */
    data: XOR<UserRecommendYoutubeUpdateManyMutationInput, UserRecommendYoutubeUncheckedUpdateManyInput>
    /**
     * Filter which UserRecommendYoutubes to update
     */
    where?: UserRecommendYoutubeWhereInput
    /**
     * Limit how many UserRecommendYoutubes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRecommendYoutubeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRecommendYoutube upsert
   */
  export type UserRecommendYoutubeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecommendYoutube
     */
    select?: UserRecommendYoutubeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecommendYoutube
     */
    omit?: UserRecommendYoutubeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRecommendYoutubeInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRecommendYoutube to update in case it exists.
     */
    where: UserRecommendYoutubeWhereUniqueInput
    /**
     * In case the UserRecommendYoutube found by the `where` argument doesn't exist, create a new UserRecommendYoutube with this data.
     */
    create: XOR<UserRecommendYoutubeCreateInput, UserRecommendYoutubeUncheckedCreateInput>
    /**
     * In case the UserRecommendYoutube was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRecommendYoutubeUpdateInput, UserRecommendYoutubeUncheckedUpdateInput>
  }

  /**
   * UserRecommendYoutube delete
   */
  export type UserRecommendYoutubeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecommendYoutube
     */
    select?: UserRecommendYoutubeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecommendYoutube
     */
    omit?: UserRecommendYoutubeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRecommendYoutubeInclude<ExtArgs> | null
    /**
     * Filter which UserRecommendYoutube to delete.
     */
    where: UserRecommendYoutubeWhereUniqueInput
  }

  /**
   * UserRecommendYoutube deleteMany
   */
  export type UserRecommendYoutubeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRecommendYoutubes to delete
     */
    where?: UserRecommendYoutubeWhereInput
    /**
     * Limit how many UserRecommendYoutubes to delete.
     */
    limit?: number
  }

  /**
   * UserRecommendYoutube without action
   */
  export type UserRecommendYoutubeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRecommendYoutube
     */
    select?: UserRecommendYoutubeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRecommendYoutube
     */
    omit?: UserRecommendYoutubeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRecommendYoutubeInclude<ExtArgs> | null
  }


  /**
   * Model UserPopupSettings
   */

  export type AggregateUserPopupSettings = {
    _count: UserPopupSettingsCountAggregateOutputType | null
    _min: UserPopupSettingsMinAggregateOutputType | null
    _max: UserPopupSettingsMaxAggregateOutputType | null
  }

  export type UserPopupSettingsMinAggregateOutputType = {
    id: string | null
    bellTitle: string | null
    bellText: string | null
    bellImageUrl: string | null
    bellUrl: string | null
    bellLastUpdated: Date | null
    emailTitle: string | null
    emailText: string | null
    popup1ImageUrl: string | null
    popup1Url: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type UserPopupSettingsMaxAggregateOutputType = {
    id: string | null
    bellTitle: string | null
    bellText: string | null
    bellImageUrl: string | null
    bellUrl: string | null
    bellLastUpdated: Date | null
    emailTitle: string | null
    emailText: string | null
    popup1ImageUrl: string | null
    popup1Url: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type UserPopupSettingsCountAggregateOutputType = {
    id: number
    bellTitle: number
    bellText: number
    bellImageUrl: number
    bellUrl: number
    bellLastUpdated: number
    emailTitle: number
    emailText: number
    popup1ImageUrl: number
    popup1Url: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type UserPopupSettingsMinAggregateInputType = {
    id?: true
    bellTitle?: true
    bellText?: true
    bellImageUrl?: true
    bellUrl?: true
    bellLastUpdated?: true
    emailTitle?: true
    emailText?: true
    popup1ImageUrl?: true
    popup1Url?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type UserPopupSettingsMaxAggregateInputType = {
    id?: true
    bellTitle?: true
    bellText?: true
    bellImageUrl?: true
    bellUrl?: true
    bellLastUpdated?: true
    emailTitle?: true
    emailText?: true
    popup1ImageUrl?: true
    popup1Url?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type UserPopupSettingsCountAggregateInputType = {
    id?: true
    bellTitle?: true
    bellText?: true
    bellImageUrl?: true
    bellUrl?: true
    bellLastUpdated?: true
    emailTitle?: true
    emailText?: true
    popup1ImageUrl?: true
    popup1Url?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type UserPopupSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPopupSettings to aggregate.
     */
    where?: UserPopupSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPopupSettings to fetch.
     */
    orderBy?: UserPopupSettingsOrderByWithRelationInput | UserPopupSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPopupSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPopupSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPopupSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPopupSettings
    **/
    _count?: true | UserPopupSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPopupSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPopupSettingsMaxAggregateInputType
  }

  export type GetUserPopupSettingsAggregateType<T extends UserPopupSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPopupSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPopupSettings[P]>
      : GetScalarType<T[P], AggregateUserPopupSettings[P]>
  }




  export type UserPopupSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPopupSettingsWhereInput
    orderBy?: UserPopupSettingsOrderByWithAggregationInput | UserPopupSettingsOrderByWithAggregationInput[]
    by: UserPopupSettingsScalarFieldEnum[] | UserPopupSettingsScalarFieldEnum
    having?: UserPopupSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPopupSettingsCountAggregateInputType | true
    _min?: UserPopupSettingsMinAggregateInputType
    _max?: UserPopupSettingsMaxAggregateInputType
  }

  export type UserPopupSettingsGroupByOutputType = {
    id: string
    bellTitle: string | null
    bellText: string | null
    bellImageUrl: string | null
    bellUrl: string | null
    bellLastUpdated: Date | null
    emailTitle: string | null
    emailText: string | null
    popup1ImageUrl: string | null
    popup1Url: string | null
    createdAt: Date
    updatedAt: Date
    userId: string
    _count: UserPopupSettingsCountAggregateOutputType | null
    _min: UserPopupSettingsMinAggregateOutputType | null
    _max: UserPopupSettingsMaxAggregateOutputType | null
  }

  type GetUserPopupSettingsGroupByPayload<T extends UserPopupSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPopupSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPopupSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPopupSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], UserPopupSettingsGroupByOutputType[P]>
        }
      >
    >


  export type UserPopupSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bellTitle?: boolean
    bellText?: boolean
    bellImageUrl?: boolean
    bellUrl?: boolean
    bellLastUpdated?: boolean
    emailTitle?: boolean
    emailText?: boolean
    popup1ImageUrl?: boolean
    popup1Url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPopupSettings"]>

  export type UserPopupSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bellTitle?: boolean
    bellText?: boolean
    bellImageUrl?: boolean
    bellUrl?: boolean
    bellLastUpdated?: boolean
    emailTitle?: boolean
    emailText?: boolean
    popup1ImageUrl?: boolean
    popup1Url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPopupSettings"]>

  export type UserPopupSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bellTitle?: boolean
    bellText?: boolean
    bellImageUrl?: boolean
    bellUrl?: boolean
    bellLastUpdated?: boolean
    emailTitle?: boolean
    emailText?: boolean
    popup1ImageUrl?: boolean
    popup1Url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPopupSettings"]>

  export type UserPopupSettingsSelectScalar = {
    id?: boolean
    bellTitle?: boolean
    bellText?: boolean
    bellImageUrl?: boolean
    bellUrl?: boolean
    bellLastUpdated?: boolean
    emailTitle?: boolean
    emailText?: boolean
    popup1ImageUrl?: boolean
    popup1Url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type UserPopupSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bellTitle" | "bellText" | "bellImageUrl" | "bellUrl" | "bellLastUpdated" | "emailTitle" | "emailText" | "popup1ImageUrl" | "popup1Url" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["userPopupSettings"]>
  export type UserPopupSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPopupSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPopupSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserPopupSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPopupSettings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bellTitle: string | null
      bellText: string | null
      bellImageUrl: string | null
      bellUrl: string | null
      bellLastUpdated: Date | null
      emailTitle: string | null
      emailText: string | null
      popup1ImageUrl: string | null
      popup1Url: string | null
      createdAt: Date
      updatedAt: Date
      userId: string
    }, ExtArgs["result"]["userPopupSettings"]>
    composites: {}
  }

  type UserPopupSettingsGetPayload<S extends boolean | null | undefined | UserPopupSettingsDefaultArgs> = $Result.GetResult<Prisma.$UserPopupSettingsPayload, S>

  type UserPopupSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPopupSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPopupSettingsCountAggregateInputType | true
    }

  export interface UserPopupSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPopupSettings'], meta: { name: 'UserPopupSettings' } }
    /**
     * Find zero or one UserPopupSettings that matches the filter.
     * @param {UserPopupSettingsFindUniqueArgs} args - Arguments to find a UserPopupSettings
     * @example
     * // Get one UserPopupSettings
     * const userPopupSettings = await prisma.userPopupSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPopupSettingsFindUniqueArgs>(args: SelectSubset<T, UserPopupSettingsFindUniqueArgs<ExtArgs>>): Prisma__UserPopupSettingsClient<$Result.GetResult<Prisma.$UserPopupSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPopupSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPopupSettingsFindUniqueOrThrowArgs} args - Arguments to find a UserPopupSettings
     * @example
     * // Get one UserPopupSettings
     * const userPopupSettings = await prisma.userPopupSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPopupSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPopupSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPopupSettingsClient<$Result.GetResult<Prisma.$UserPopupSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPopupSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPopupSettingsFindFirstArgs} args - Arguments to find a UserPopupSettings
     * @example
     * // Get one UserPopupSettings
     * const userPopupSettings = await prisma.userPopupSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPopupSettingsFindFirstArgs>(args?: SelectSubset<T, UserPopupSettingsFindFirstArgs<ExtArgs>>): Prisma__UserPopupSettingsClient<$Result.GetResult<Prisma.$UserPopupSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPopupSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPopupSettingsFindFirstOrThrowArgs} args - Arguments to find a UserPopupSettings
     * @example
     * // Get one UserPopupSettings
     * const userPopupSettings = await prisma.userPopupSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPopupSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPopupSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPopupSettingsClient<$Result.GetResult<Prisma.$UserPopupSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPopupSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPopupSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPopupSettings
     * const userPopupSettings = await prisma.userPopupSettings.findMany()
     * 
     * // Get first 10 UserPopupSettings
     * const userPopupSettings = await prisma.userPopupSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPopupSettingsWithIdOnly = await prisma.userPopupSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPopupSettingsFindManyArgs>(args?: SelectSubset<T, UserPopupSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPopupSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPopupSettings.
     * @param {UserPopupSettingsCreateArgs} args - Arguments to create a UserPopupSettings.
     * @example
     * // Create one UserPopupSettings
     * const UserPopupSettings = await prisma.userPopupSettings.create({
     *   data: {
     *     // ... data to create a UserPopupSettings
     *   }
     * })
     * 
     */
    create<T extends UserPopupSettingsCreateArgs>(args: SelectSubset<T, UserPopupSettingsCreateArgs<ExtArgs>>): Prisma__UserPopupSettingsClient<$Result.GetResult<Prisma.$UserPopupSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPopupSettings.
     * @param {UserPopupSettingsCreateManyArgs} args - Arguments to create many UserPopupSettings.
     * @example
     * // Create many UserPopupSettings
     * const userPopupSettings = await prisma.userPopupSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPopupSettingsCreateManyArgs>(args?: SelectSubset<T, UserPopupSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPopupSettings and returns the data saved in the database.
     * @param {UserPopupSettingsCreateManyAndReturnArgs} args - Arguments to create many UserPopupSettings.
     * @example
     * // Create many UserPopupSettings
     * const userPopupSettings = await prisma.userPopupSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPopupSettings and only return the `id`
     * const userPopupSettingsWithIdOnly = await prisma.userPopupSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPopupSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPopupSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPopupSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPopupSettings.
     * @param {UserPopupSettingsDeleteArgs} args - Arguments to delete one UserPopupSettings.
     * @example
     * // Delete one UserPopupSettings
     * const UserPopupSettings = await prisma.userPopupSettings.delete({
     *   where: {
     *     // ... filter to delete one UserPopupSettings
     *   }
     * })
     * 
     */
    delete<T extends UserPopupSettingsDeleteArgs>(args: SelectSubset<T, UserPopupSettingsDeleteArgs<ExtArgs>>): Prisma__UserPopupSettingsClient<$Result.GetResult<Prisma.$UserPopupSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPopupSettings.
     * @param {UserPopupSettingsUpdateArgs} args - Arguments to update one UserPopupSettings.
     * @example
     * // Update one UserPopupSettings
     * const userPopupSettings = await prisma.userPopupSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPopupSettingsUpdateArgs>(args: SelectSubset<T, UserPopupSettingsUpdateArgs<ExtArgs>>): Prisma__UserPopupSettingsClient<$Result.GetResult<Prisma.$UserPopupSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPopupSettings.
     * @param {UserPopupSettingsDeleteManyArgs} args - Arguments to filter UserPopupSettings to delete.
     * @example
     * // Delete a few UserPopupSettings
     * const { count } = await prisma.userPopupSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPopupSettingsDeleteManyArgs>(args?: SelectSubset<T, UserPopupSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPopupSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPopupSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPopupSettings
     * const userPopupSettings = await prisma.userPopupSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPopupSettingsUpdateManyArgs>(args: SelectSubset<T, UserPopupSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPopupSettings and returns the data updated in the database.
     * @param {UserPopupSettingsUpdateManyAndReturnArgs} args - Arguments to update many UserPopupSettings.
     * @example
     * // Update many UserPopupSettings
     * const userPopupSettings = await prisma.userPopupSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPopupSettings and only return the `id`
     * const userPopupSettingsWithIdOnly = await prisma.userPopupSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPopupSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPopupSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPopupSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPopupSettings.
     * @param {UserPopupSettingsUpsertArgs} args - Arguments to update or create a UserPopupSettings.
     * @example
     * // Update or create a UserPopupSettings
     * const userPopupSettings = await prisma.userPopupSettings.upsert({
     *   create: {
     *     // ... data to create a UserPopupSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPopupSettings we want to update
     *   }
     * })
     */
    upsert<T extends UserPopupSettingsUpsertArgs>(args: SelectSubset<T, UserPopupSettingsUpsertArgs<ExtArgs>>): Prisma__UserPopupSettingsClient<$Result.GetResult<Prisma.$UserPopupSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPopupSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPopupSettingsCountArgs} args - Arguments to filter UserPopupSettings to count.
     * @example
     * // Count the number of UserPopupSettings
     * const count = await prisma.userPopupSettings.count({
     *   where: {
     *     // ... the filter for the UserPopupSettings we want to count
     *   }
     * })
    **/
    count<T extends UserPopupSettingsCountArgs>(
      args?: Subset<T, UserPopupSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPopupSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPopupSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPopupSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPopupSettingsAggregateArgs>(args: Subset<T, UserPopupSettingsAggregateArgs>): Prisma.PrismaPromise<GetUserPopupSettingsAggregateType<T>>

    /**
     * Group by UserPopupSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPopupSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPopupSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPopupSettingsGroupByArgs['orderBy'] }
        : { orderBy?: UserPopupSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPopupSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPopupSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPopupSettings model
   */
  readonly fields: UserPopupSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPopupSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPopupSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPopupSettings model
   */
  interface UserPopupSettingsFieldRefs {
    readonly id: FieldRef<"UserPopupSettings", 'String'>
    readonly bellTitle: FieldRef<"UserPopupSettings", 'String'>
    readonly bellText: FieldRef<"UserPopupSettings", 'String'>
    readonly bellImageUrl: FieldRef<"UserPopupSettings", 'String'>
    readonly bellUrl: FieldRef<"UserPopupSettings", 'String'>
    readonly bellLastUpdated: FieldRef<"UserPopupSettings", 'DateTime'>
    readonly emailTitle: FieldRef<"UserPopupSettings", 'String'>
    readonly emailText: FieldRef<"UserPopupSettings", 'String'>
    readonly popup1ImageUrl: FieldRef<"UserPopupSettings", 'String'>
    readonly popup1Url: FieldRef<"UserPopupSettings", 'String'>
    readonly createdAt: FieldRef<"UserPopupSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"UserPopupSettings", 'DateTime'>
    readonly userId: FieldRef<"UserPopupSettings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserPopupSettings findUnique
   */
  export type UserPopupSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPopupSettings
     */
    select?: UserPopupSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPopupSettings
     */
    omit?: UserPopupSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPopupSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserPopupSettings to fetch.
     */
    where: UserPopupSettingsWhereUniqueInput
  }

  /**
   * UserPopupSettings findUniqueOrThrow
   */
  export type UserPopupSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPopupSettings
     */
    select?: UserPopupSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPopupSettings
     */
    omit?: UserPopupSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPopupSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserPopupSettings to fetch.
     */
    where: UserPopupSettingsWhereUniqueInput
  }

  /**
   * UserPopupSettings findFirst
   */
  export type UserPopupSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPopupSettings
     */
    select?: UserPopupSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPopupSettings
     */
    omit?: UserPopupSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPopupSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserPopupSettings to fetch.
     */
    where?: UserPopupSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPopupSettings to fetch.
     */
    orderBy?: UserPopupSettingsOrderByWithRelationInput | UserPopupSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPopupSettings.
     */
    cursor?: UserPopupSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPopupSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPopupSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPopupSettings.
     */
    distinct?: UserPopupSettingsScalarFieldEnum | UserPopupSettingsScalarFieldEnum[]
  }

  /**
   * UserPopupSettings findFirstOrThrow
   */
  export type UserPopupSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPopupSettings
     */
    select?: UserPopupSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPopupSettings
     */
    omit?: UserPopupSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPopupSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserPopupSettings to fetch.
     */
    where?: UserPopupSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPopupSettings to fetch.
     */
    orderBy?: UserPopupSettingsOrderByWithRelationInput | UserPopupSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPopupSettings.
     */
    cursor?: UserPopupSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPopupSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPopupSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPopupSettings.
     */
    distinct?: UserPopupSettingsScalarFieldEnum | UserPopupSettingsScalarFieldEnum[]
  }

  /**
   * UserPopupSettings findMany
   */
  export type UserPopupSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPopupSettings
     */
    select?: UserPopupSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPopupSettings
     */
    omit?: UserPopupSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPopupSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserPopupSettings to fetch.
     */
    where?: UserPopupSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPopupSettings to fetch.
     */
    orderBy?: UserPopupSettingsOrderByWithRelationInput | UserPopupSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPopupSettings.
     */
    cursor?: UserPopupSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPopupSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPopupSettings.
     */
    skip?: number
    distinct?: UserPopupSettingsScalarFieldEnum | UserPopupSettingsScalarFieldEnum[]
  }

  /**
   * UserPopupSettings create
   */
  export type UserPopupSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPopupSettings
     */
    select?: UserPopupSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPopupSettings
     */
    omit?: UserPopupSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPopupSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPopupSettings.
     */
    data: XOR<UserPopupSettingsCreateInput, UserPopupSettingsUncheckedCreateInput>
  }

  /**
   * UserPopupSettings createMany
   */
  export type UserPopupSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPopupSettings.
     */
    data: UserPopupSettingsCreateManyInput | UserPopupSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPopupSettings createManyAndReturn
   */
  export type UserPopupSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPopupSettings
     */
    select?: UserPopupSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPopupSettings
     */
    omit?: UserPopupSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many UserPopupSettings.
     */
    data: UserPopupSettingsCreateManyInput | UserPopupSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPopupSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPopupSettings update
   */
  export type UserPopupSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPopupSettings
     */
    select?: UserPopupSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPopupSettings
     */
    omit?: UserPopupSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPopupSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPopupSettings.
     */
    data: XOR<UserPopupSettingsUpdateInput, UserPopupSettingsUncheckedUpdateInput>
    /**
     * Choose, which UserPopupSettings to update.
     */
    where: UserPopupSettingsWhereUniqueInput
  }

  /**
   * UserPopupSettings updateMany
   */
  export type UserPopupSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPopupSettings.
     */
    data: XOR<UserPopupSettingsUpdateManyMutationInput, UserPopupSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserPopupSettings to update
     */
    where?: UserPopupSettingsWhereInput
    /**
     * Limit how many UserPopupSettings to update.
     */
    limit?: number
  }

  /**
   * UserPopupSettings updateManyAndReturn
   */
  export type UserPopupSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPopupSettings
     */
    select?: UserPopupSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPopupSettings
     */
    omit?: UserPopupSettingsOmit<ExtArgs> | null
    /**
     * The data used to update UserPopupSettings.
     */
    data: XOR<UserPopupSettingsUpdateManyMutationInput, UserPopupSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserPopupSettings to update
     */
    where?: UserPopupSettingsWhereInput
    /**
     * Limit how many UserPopupSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPopupSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPopupSettings upsert
   */
  export type UserPopupSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPopupSettings
     */
    select?: UserPopupSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPopupSettings
     */
    omit?: UserPopupSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPopupSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPopupSettings to update in case it exists.
     */
    where: UserPopupSettingsWhereUniqueInput
    /**
     * In case the UserPopupSettings found by the `where` argument doesn't exist, create a new UserPopupSettings with this data.
     */
    create: XOR<UserPopupSettingsCreateInput, UserPopupSettingsUncheckedCreateInput>
    /**
     * In case the UserPopupSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPopupSettingsUpdateInput, UserPopupSettingsUncheckedUpdateInput>
  }

  /**
   * UserPopupSettings delete
   */
  export type UserPopupSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPopupSettings
     */
    select?: UserPopupSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPopupSettings
     */
    omit?: UserPopupSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPopupSettingsInclude<ExtArgs> | null
    /**
     * Filter which UserPopupSettings to delete.
     */
    where: UserPopupSettingsWhereUniqueInput
  }

  /**
   * UserPopupSettings deleteMany
   */
  export type UserPopupSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPopupSettings to delete
     */
    where?: UserPopupSettingsWhereInput
    /**
     * Limit how many UserPopupSettings to delete.
     */
    limit?: number
  }

  /**
   * UserPopupSettings without action
   */
  export type UserPopupSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPopupSettings
     */
    select?: UserPopupSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPopupSettings
     */
    omit?: UserPopupSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPopupSettingsInclude<ExtArgs> | null
  }


  /**
   * Model UserOGP
   */

  export type AggregateUserOGP = {
    _count: UserOGPCountAggregateOutputType | null
    _min: UserOGPMinAggregateOutputType | null
    _max: UserOGPMaxAggregateOutputType | null
  }

  export type UserOGPMinAggregateOutputType = {
    id: string | null
    imgUrl: string | null
    title: string | null
    description: string | null
    userId: string | null
  }

  export type UserOGPMaxAggregateOutputType = {
    id: string | null
    imgUrl: string | null
    title: string | null
    description: string | null
    userId: string | null
  }

  export type UserOGPCountAggregateOutputType = {
    id: number
    imgUrl: number
    title: number
    description: number
    userId: number
    _all: number
  }


  export type UserOGPMinAggregateInputType = {
    id?: true
    imgUrl?: true
    title?: true
    description?: true
    userId?: true
  }

  export type UserOGPMaxAggregateInputType = {
    id?: true
    imgUrl?: true
    title?: true
    description?: true
    userId?: true
  }

  export type UserOGPCountAggregateInputType = {
    id?: true
    imgUrl?: true
    title?: true
    description?: true
    userId?: true
    _all?: true
  }

  export type UserOGPAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserOGP to aggregate.
     */
    where?: UserOGPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOGPS to fetch.
     */
    orderBy?: UserOGPOrderByWithRelationInput | UserOGPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserOGPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOGPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOGPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserOGPS
    **/
    _count?: true | UserOGPCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserOGPMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserOGPMaxAggregateInputType
  }

  export type GetUserOGPAggregateType<T extends UserOGPAggregateArgs> = {
        [P in keyof T & keyof AggregateUserOGP]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserOGP[P]>
      : GetScalarType<T[P], AggregateUserOGP[P]>
  }




  export type UserOGPGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserOGPWhereInput
    orderBy?: UserOGPOrderByWithAggregationInput | UserOGPOrderByWithAggregationInput[]
    by: UserOGPScalarFieldEnum[] | UserOGPScalarFieldEnum
    having?: UserOGPScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserOGPCountAggregateInputType | true
    _min?: UserOGPMinAggregateInputType
    _max?: UserOGPMaxAggregateInputType
  }

  export type UserOGPGroupByOutputType = {
    id: string
    imgUrl: string | null
    title: string | null
    description: string | null
    userId: string
    _count: UserOGPCountAggregateOutputType | null
    _min: UserOGPMinAggregateOutputType | null
    _max: UserOGPMaxAggregateOutputType | null
  }

  type GetUserOGPGroupByPayload<T extends UserOGPGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserOGPGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserOGPGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserOGPGroupByOutputType[P]>
            : GetScalarType<T[P], UserOGPGroupByOutputType[P]>
        }
      >
    >


  export type UserOGPSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    imgUrl?: boolean
    title?: boolean
    description?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userOGP"]>

  export type UserOGPSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    imgUrl?: boolean
    title?: boolean
    description?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userOGP"]>

  export type UserOGPSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    imgUrl?: boolean
    title?: boolean
    description?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userOGP"]>

  export type UserOGPSelectScalar = {
    id?: boolean
    imgUrl?: boolean
    title?: boolean
    description?: boolean
    userId?: boolean
  }

  export type UserOGPOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "imgUrl" | "title" | "description" | "userId", ExtArgs["result"]["userOGP"]>
  export type UserOGPInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserOGPIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserOGPIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserOGPPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserOGP"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      imgUrl: string | null
      title: string | null
      description: string | null
      userId: string
    }, ExtArgs["result"]["userOGP"]>
    composites: {}
  }

  type UserOGPGetPayload<S extends boolean | null | undefined | UserOGPDefaultArgs> = $Result.GetResult<Prisma.$UserOGPPayload, S>

  type UserOGPCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserOGPFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserOGPCountAggregateInputType | true
    }

  export interface UserOGPDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserOGP'], meta: { name: 'UserOGP' } }
    /**
     * Find zero or one UserOGP that matches the filter.
     * @param {UserOGPFindUniqueArgs} args - Arguments to find a UserOGP
     * @example
     * // Get one UserOGP
     * const userOGP = await prisma.userOGP.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserOGPFindUniqueArgs>(args: SelectSubset<T, UserOGPFindUniqueArgs<ExtArgs>>): Prisma__UserOGPClient<$Result.GetResult<Prisma.$UserOGPPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserOGP that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserOGPFindUniqueOrThrowArgs} args - Arguments to find a UserOGP
     * @example
     * // Get one UserOGP
     * const userOGP = await prisma.userOGP.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserOGPFindUniqueOrThrowArgs>(args: SelectSubset<T, UserOGPFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserOGPClient<$Result.GetResult<Prisma.$UserOGPPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserOGP that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOGPFindFirstArgs} args - Arguments to find a UserOGP
     * @example
     * // Get one UserOGP
     * const userOGP = await prisma.userOGP.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserOGPFindFirstArgs>(args?: SelectSubset<T, UserOGPFindFirstArgs<ExtArgs>>): Prisma__UserOGPClient<$Result.GetResult<Prisma.$UserOGPPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserOGP that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOGPFindFirstOrThrowArgs} args - Arguments to find a UserOGP
     * @example
     * // Get one UserOGP
     * const userOGP = await prisma.userOGP.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserOGPFindFirstOrThrowArgs>(args?: SelectSubset<T, UserOGPFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserOGPClient<$Result.GetResult<Prisma.$UserOGPPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserOGPS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOGPFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserOGPS
     * const userOGPS = await prisma.userOGP.findMany()
     * 
     * // Get first 10 UserOGPS
     * const userOGPS = await prisma.userOGP.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userOGPWithIdOnly = await prisma.userOGP.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserOGPFindManyArgs>(args?: SelectSubset<T, UserOGPFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserOGPPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserOGP.
     * @param {UserOGPCreateArgs} args - Arguments to create a UserOGP.
     * @example
     * // Create one UserOGP
     * const UserOGP = await prisma.userOGP.create({
     *   data: {
     *     // ... data to create a UserOGP
     *   }
     * })
     * 
     */
    create<T extends UserOGPCreateArgs>(args: SelectSubset<T, UserOGPCreateArgs<ExtArgs>>): Prisma__UserOGPClient<$Result.GetResult<Prisma.$UserOGPPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserOGPS.
     * @param {UserOGPCreateManyArgs} args - Arguments to create many UserOGPS.
     * @example
     * // Create many UserOGPS
     * const userOGP = await prisma.userOGP.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserOGPCreateManyArgs>(args?: SelectSubset<T, UserOGPCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserOGPS and returns the data saved in the database.
     * @param {UserOGPCreateManyAndReturnArgs} args - Arguments to create many UserOGPS.
     * @example
     * // Create many UserOGPS
     * const userOGP = await prisma.userOGP.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserOGPS and only return the `id`
     * const userOGPWithIdOnly = await prisma.userOGP.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserOGPCreateManyAndReturnArgs>(args?: SelectSubset<T, UserOGPCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserOGPPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserOGP.
     * @param {UserOGPDeleteArgs} args - Arguments to delete one UserOGP.
     * @example
     * // Delete one UserOGP
     * const UserOGP = await prisma.userOGP.delete({
     *   where: {
     *     // ... filter to delete one UserOGP
     *   }
     * })
     * 
     */
    delete<T extends UserOGPDeleteArgs>(args: SelectSubset<T, UserOGPDeleteArgs<ExtArgs>>): Prisma__UserOGPClient<$Result.GetResult<Prisma.$UserOGPPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserOGP.
     * @param {UserOGPUpdateArgs} args - Arguments to update one UserOGP.
     * @example
     * // Update one UserOGP
     * const userOGP = await prisma.userOGP.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserOGPUpdateArgs>(args: SelectSubset<T, UserOGPUpdateArgs<ExtArgs>>): Prisma__UserOGPClient<$Result.GetResult<Prisma.$UserOGPPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserOGPS.
     * @param {UserOGPDeleteManyArgs} args - Arguments to filter UserOGPS to delete.
     * @example
     * // Delete a few UserOGPS
     * const { count } = await prisma.userOGP.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserOGPDeleteManyArgs>(args?: SelectSubset<T, UserOGPDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserOGPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOGPUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserOGPS
     * const userOGP = await prisma.userOGP.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserOGPUpdateManyArgs>(args: SelectSubset<T, UserOGPUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserOGPS and returns the data updated in the database.
     * @param {UserOGPUpdateManyAndReturnArgs} args - Arguments to update many UserOGPS.
     * @example
     * // Update many UserOGPS
     * const userOGP = await prisma.userOGP.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserOGPS and only return the `id`
     * const userOGPWithIdOnly = await prisma.userOGP.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserOGPUpdateManyAndReturnArgs>(args: SelectSubset<T, UserOGPUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserOGPPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserOGP.
     * @param {UserOGPUpsertArgs} args - Arguments to update or create a UserOGP.
     * @example
     * // Update or create a UserOGP
     * const userOGP = await prisma.userOGP.upsert({
     *   create: {
     *     // ... data to create a UserOGP
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserOGP we want to update
     *   }
     * })
     */
    upsert<T extends UserOGPUpsertArgs>(args: SelectSubset<T, UserOGPUpsertArgs<ExtArgs>>): Prisma__UserOGPClient<$Result.GetResult<Prisma.$UserOGPPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserOGPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOGPCountArgs} args - Arguments to filter UserOGPS to count.
     * @example
     * // Count the number of UserOGPS
     * const count = await prisma.userOGP.count({
     *   where: {
     *     // ... the filter for the UserOGPS we want to count
     *   }
     * })
    **/
    count<T extends UserOGPCountArgs>(
      args?: Subset<T, UserOGPCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserOGPCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserOGP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOGPAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserOGPAggregateArgs>(args: Subset<T, UserOGPAggregateArgs>): Prisma.PrismaPromise<GetUserOGPAggregateType<T>>

    /**
     * Group by UserOGP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOGPGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserOGPGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserOGPGroupByArgs['orderBy'] }
        : { orderBy?: UserOGPGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserOGPGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserOGPGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserOGP model
   */
  readonly fields: UserOGPFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserOGP.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserOGPClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserOGP model
   */
  interface UserOGPFieldRefs {
    readonly id: FieldRef<"UserOGP", 'String'>
    readonly imgUrl: FieldRef<"UserOGP", 'String'>
    readonly title: FieldRef<"UserOGP", 'String'>
    readonly description: FieldRef<"UserOGP", 'String'>
    readonly userId: FieldRef<"UserOGP", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserOGP findUnique
   */
  export type UserOGPFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOGP
     */
    select?: UserOGPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOGP
     */
    omit?: UserOGPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOGPInclude<ExtArgs> | null
    /**
     * Filter, which UserOGP to fetch.
     */
    where: UserOGPWhereUniqueInput
  }

  /**
   * UserOGP findUniqueOrThrow
   */
  export type UserOGPFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOGP
     */
    select?: UserOGPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOGP
     */
    omit?: UserOGPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOGPInclude<ExtArgs> | null
    /**
     * Filter, which UserOGP to fetch.
     */
    where: UserOGPWhereUniqueInput
  }

  /**
   * UserOGP findFirst
   */
  export type UserOGPFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOGP
     */
    select?: UserOGPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOGP
     */
    omit?: UserOGPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOGPInclude<ExtArgs> | null
    /**
     * Filter, which UserOGP to fetch.
     */
    where?: UserOGPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOGPS to fetch.
     */
    orderBy?: UserOGPOrderByWithRelationInput | UserOGPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserOGPS.
     */
    cursor?: UserOGPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOGPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOGPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserOGPS.
     */
    distinct?: UserOGPScalarFieldEnum | UserOGPScalarFieldEnum[]
  }

  /**
   * UserOGP findFirstOrThrow
   */
  export type UserOGPFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOGP
     */
    select?: UserOGPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOGP
     */
    omit?: UserOGPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOGPInclude<ExtArgs> | null
    /**
     * Filter, which UserOGP to fetch.
     */
    where?: UserOGPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOGPS to fetch.
     */
    orderBy?: UserOGPOrderByWithRelationInput | UserOGPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserOGPS.
     */
    cursor?: UserOGPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOGPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOGPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserOGPS.
     */
    distinct?: UserOGPScalarFieldEnum | UserOGPScalarFieldEnum[]
  }

  /**
   * UserOGP findMany
   */
  export type UserOGPFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOGP
     */
    select?: UserOGPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOGP
     */
    omit?: UserOGPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOGPInclude<ExtArgs> | null
    /**
     * Filter, which UserOGPS to fetch.
     */
    where?: UserOGPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOGPS to fetch.
     */
    orderBy?: UserOGPOrderByWithRelationInput | UserOGPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserOGPS.
     */
    cursor?: UserOGPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOGPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOGPS.
     */
    skip?: number
    distinct?: UserOGPScalarFieldEnum | UserOGPScalarFieldEnum[]
  }

  /**
   * UserOGP create
   */
  export type UserOGPCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOGP
     */
    select?: UserOGPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOGP
     */
    omit?: UserOGPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOGPInclude<ExtArgs> | null
    /**
     * The data needed to create a UserOGP.
     */
    data: XOR<UserOGPCreateInput, UserOGPUncheckedCreateInput>
  }

  /**
   * UserOGP createMany
   */
  export type UserOGPCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserOGPS.
     */
    data: UserOGPCreateManyInput | UserOGPCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserOGP createManyAndReturn
   */
  export type UserOGPCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOGP
     */
    select?: UserOGPSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserOGP
     */
    omit?: UserOGPOmit<ExtArgs> | null
    /**
     * The data used to create many UserOGPS.
     */
    data: UserOGPCreateManyInput | UserOGPCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOGPIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserOGP update
   */
  export type UserOGPUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOGP
     */
    select?: UserOGPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOGP
     */
    omit?: UserOGPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOGPInclude<ExtArgs> | null
    /**
     * The data needed to update a UserOGP.
     */
    data: XOR<UserOGPUpdateInput, UserOGPUncheckedUpdateInput>
    /**
     * Choose, which UserOGP to update.
     */
    where: UserOGPWhereUniqueInput
  }

  /**
   * UserOGP updateMany
   */
  export type UserOGPUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserOGPS.
     */
    data: XOR<UserOGPUpdateManyMutationInput, UserOGPUncheckedUpdateManyInput>
    /**
     * Filter which UserOGPS to update
     */
    where?: UserOGPWhereInput
    /**
     * Limit how many UserOGPS to update.
     */
    limit?: number
  }

  /**
   * UserOGP updateManyAndReturn
   */
  export type UserOGPUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOGP
     */
    select?: UserOGPSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserOGP
     */
    omit?: UserOGPOmit<ExtArgs> | null
    /**
     * The data used to update UserOGPS.
     */
    data: XOR<UserOGPUpdateManyMutationInput, UserOGPUncheckedUpdateManyInput>
    /**
     * Filter which UserOGPS to update
     */
    where?: UserOGPWhereInput
    /**
     * Limit how many UserOGPS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOGPIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserOGP upsert
   */
  export type UserOGPUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOGP
     */
    select?: UserOGPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOGP
     */
    omit?: UserOGPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOGPInclude<ExtArgs> | null
    /**
     * The filter to search for the UserOGP to update in case it exists.
     */
    where: UserOGPWhereUniqueInput
    /**
     * In case the UserOGP found by the `where` argument doesn't exist, create a new UserOGP with this data.
     */
    create: XOR<UserOGPCreateInput, UserOGPUncheckedCreateInput>
    /**
     * In case the UserOGP was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserOGPUpdateInput, UserOGPUncheckedUpdateInput>
  }

  /**
   * UserOGP delete
   */
  export type UserOGPDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOGP
     */
    select?: UserOGPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOGP
     */
    omit?: UserOGPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOGPInclude<ExtArgs> | null
    /**
     * Filter which UserOGP to delete.
     */
    where: UserOGPWhereUniqueInput
  }

  /**
   * UserOGP deleteMany
   */
  export type UserOGPDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserOGPS to delete
     */
    where?: UserOGPWhereInput
    /**
     * Limit how many UserOGPS to delete.
     */
    limit?: number
  }

  /**
   * UserOGP without action
   */
  export type UserOGPDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOGP
     */
    select?: UserOGPSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOGP
     */
    omit?: UserOGPOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOGPInclude<ExtArgs> | null
  }


  /**
   * Model UserCustomQuestion
   */

  export type AggregateUserCustomQuestion = {
    _count: UserCustomQuestionCountAggregateOutputType | null
    _avg: UserCustomQuestionAvgAggregateOutputType | null
    _sum: UserCustomQuestionSumAggregateOutputType | null
    _min: UserCustomQuestionMinAggregateOutputType | null
    _max: UserCustomQuestionMaxAggregateOutputType | null
  }

  export type UserCustomQuestionAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type UserCustomQuestionSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type UserCustomQuestionMinAggregateOutputType = {
    id: string | null
    question: string | null
    answer: string | null
    sortOrder: number | null
    userId: string | null
  }

  export type UserCustomQuestionMaxAggregateOutputType = {
    id: string | null
    question: string | null
    answer: string | null
    sortOrder: number | null
    userId: string | null
  }

  export type UserCustomQuestionCountAggregateOutputType = {
    id: number
    question: number
    answer: number
    sortOrder: number
    userId: number
    _all: number
  }


  export type UserCustomQuestionAvgAggregateInputType = {
    sortOrder?: true
  }

  export type UserCustomQuestionSumAggregateInputType = {
    sortOrder?: true
  }

  export type UserCustomQuestionMinAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    sortOrder?: true
    userId?: true
  }

  export type UserCustomQuestionMaxAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    sortOrder?: true
    userId?: true
  }

  export type UserCustomQuestionCountAggregateInputType = {
    id?: true
    question?: true
    answer?: true
    sortOrder?: true
    userId?: true
    _all?: true
  }

  export type UserCustomQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCustomQuestion to aggregate.
     */
    where?: UserCustomQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCustomQuestions to fetch.
     */
    orderBy?: UserCustomQuestionOrderByWithRelationInput | UserCustomQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserCustomQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCustomQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCustomQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserCustomQuestions
    **/
    _count?: true | UserCustomQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserCustomQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserCustomQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserCustomQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserCustomQuestionMaxAggregateInputType
  }

  export type GetUserCustomQuestionAggregateType<T extends UserCustomQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserCustomQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserCustomQuestion[P]>
      : GetScalarType<T[P], AggregateUserCustomQuestion[P]>
  }




  export type UserCustomQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCustomQuestionWhereInput
    orderBy?: UserCustomQuestionOrderByWithAggregationInput | UserCustomQuestionOrderByWithAggregationInput[]
    by: UserCustomQuestionScalarFieldEnum[] | UserCustomQuestionScalarFieldEnum
    having?: UserCustomQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCustomQuestionCountAggregateInputType | true
    _avg?: UserCustomQuestionAvgAggregateInputType
    _sum?: UserCustomQuestionSumAggregateInputType
    _min?: UserCustomQuestionMinAggregateInputType
    _max?: UserCustomQuestionMaxAggregateInputType
  }

  export type UserCustomQuestionGroupByOutputType = {
    id: string
    question: string
    answer: string
    sortOrder: number
    userId: string
    _count: UserCustomQuestionCountAggregateOutputType | null
    _avg: UserCustomQuestionAvgAggregateOutputType | null
    _sum: UserCustomQuestionSumAggregateOutputType | null
    _min: UserCustomQuestionMinAggregateOutputType | null
    _max: UserCustomQuestionMaxAggregateOutputType | null
  }

  type GetUserCustomQuestionGroupByPayload<T extends UserCustomQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserCustomQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserCustomQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserCustomQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], UserCustomQuestionGroupByOutputType[P]>
        }
      >
    >


  export type UserCustomQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    sortOrder?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCustomQuestion"]>

  export type UserCustomQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    sortOrder?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCustomQuestion"]>

  export type UserCustomQuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answer?: boolean
    sortOrder?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCustomQuestion"]>

  export type UserCustomQuestionSelectScalar = {
    id?: boolean
    question?: boolean
    answer?: boolean
    sortOrder?: boolean
    userId?: boolean
  }

  export type UserCustomQuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "question" | "answer" | "sortOrder" | "userId", ExtArgs["result"]["userCustomQuestion"]>
  export type UserCustomQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserCustomQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserCustomQuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserCustomQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserCustomQuestion"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      question: string
      answer: string
      sortOrder: number
      userId: string
    }, ExtArgs["result"]["userCustomQuestion"]>
    composites: {}
  }

  type UserCustomQuestionGetPayload<S extends boolean | null | undefined | UserCustomQuestionDefaultArgs> = $Result.GetResult<Prisma.$UserCustomQuestionPayload, S>

  type UserCustomQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserCustomQuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCustomQuestionCountAggregateInputType | true
    }

  export interface UserCustomQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserCustomQuestion'], meta: { name: 'UserCustomQuestion' } }
    /**
     * Find zero or one UserCustomQuestion that matches the filter.
     * @param {UserCustomQuestionFindUniqueArgs} args - Arguments to find a UserCustomQuestion
     * @example
     * // Get one UserCustomQuestion
     * const userCustomQuestion = await prisma.userCustomQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserCustomQuestionFindUniqueArgs>(args: SelectSubset<T, UserCustomQuestionFindUniqueArgs<ExtArgs>>): Prisma__UserCustomQuestionClient<$Result.GetResult<Prisma.$UserCustomQuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserCustomQuestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserCustomQuestionFindUniqueOrThrowArgs} args - Arguments to find a UserCustomQuestion
     * @example
     * // Get one UserCustomQuestion
     * const userCustomQuestion = await prisma.userCustomQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserCustomQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserCustomQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserCustomQuestionClient<$Result.GetResult<Prisma.$UserCustomQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserCustomQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCustomQuestionFindFirstArgs} args - Arguments to find a UserCustomQuestion
     * @example
     * // Get one UserCustomQuestion
     * const userCustomQuestion = await prisma.userCustomQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserCustomQuestionFindFirstArgs>(args?: SelectSubset<T, UserCustomQuestionFindFirstArgs<ExtArgs>>): Prisma__UserCustomQuestionClient<$Result.GetResult<Prisma.$UserCustomQuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserCustomQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCustomQuestionFindFirstOrThrowArgs} args - Arguments to find a UserCustomQuestion
     * @example
     * // Get one UserCustomQuestion
     * const userCustomQuestion = await prisma.userCustomQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserCustomQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserCustomQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserCustomQuestionClient<$Result.GetResult<Prisma.$UserCustomQuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserCustomQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCustomQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserCustomQuestions
     * const userCustomQuestions = await prisma.userCustomQuestion.findMany()
     * 
     * // Get first 10 UserCustomQuestions
     * const userCustomQuestions = await prisma.userCustomQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userCustomQuestionWithIdOnly = await prisma.userCustomQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserCustomQuestionFindManyArgs>(args?: SelectSubset<T, UserCustomQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCustomQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserCustomQuestion.
     * @param {UserCustomQuestionCreateArgs} args - Arguments to create a UserCustomQuestion.
     * @example
     * // Create one UserCustomQuestion
     * const UserCustomQuestion = await prisma.userCustomQuestion.create({
     *   data: {
     *     // ... data to create a UserCustomQuestion
     *   }
     * })
     * 
     */
    create<T extends UserCustomQuestionCreateArgs>(args: SelectSubset<T, UserCustomQuestionCreateArgs<ExtArgs>>): Prisma__UserCustomQuestionClient<$Result.GetResult<Prisma.$UserCustomQuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserCustomQuestions.
     * @param {UserCustomQuestionCreateManyArgs} args - Arguments to create many UserCustomQuestions.
     * @example
     * // Create many UserCustomQuestions
     * const userCustomQuestion = await prisma.userCustomQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCustomQuestionCreateManyArgs>(args?: SelectSubset<T, UserCustomQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserCustomQuestions and returns the data saved in the database.
     * @param {UserCustomQuestionCreateManyAndReturnArgs} args - Arguments to create many UserCustomQuestions.
     * @example
     * // Create many UserCustomQuestions
     * const userCustomQuestion = await prisma.userCustomQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserCustomQuestions and only return the `id`
     * const userCustomQuestionWithIdOnly = await prisma.userCustomQuestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCustomQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCustomQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCustomQuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserCustomQuestion.
     * @param {UserCustomQuestionDeleteArgs} args - Arguments to delete one UserCustomQuestion.
     * @example
     * // Delete one UserCustomQuestion
     * const UserCustomQuestion = await prisma.userCustomQuestion.delete({
     *   where: {
     *     // ... filter to delete one UserCustomQuestion
     *   }
     * })
     * 
     */
    delete<T extends UserCustomQuestionDeleteArgs>(args: SelectSubset<T, UserCustomQuestionDeleteArgs<ExtArgs>>): Prisma__UserCustomQuestionClient<$Result.GetResult<Prisma.$UserCustomQuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserCustomQuestion.
     * @param {UserCustomQuestionUpdateArgs} args - Arguments to update one UserCustomQuestion.
     * @example
     * // Update one UserCustomQuestion
     * const userCustomQuestion = await prisma.userCustomQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserCustomQuestionUpdateArgs>(args: SelectSubset<T, UserCustomQuestionUpdateArgs<ExtArgs>>): Prisma__UserCustomQuestionClient<$Result.GetResult<Prisma.$UserCustomQuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserCustomQuestions.
     * @param {UserCustomQuestionDeleteManyArgs} args - Arguments to filter UserCustomQuestions to delete.
     * @example
     * // Delete a few UserCustomQuestions
     * const { count } = await prisma.userCustomQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserCustomQuestionDeleteManyArgs>(args?: SelectSubset<T, UserCustomQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserCustomQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCustomQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserCustomQuestions
     * const userCustomQuestion = await prisma.userCustomQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserCustomQuestionUpdateManyArgs>(args: SelectSubset<T, UserCustomQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserCustomQuestions and returns the data updated in the database.
     * @param {UserCustomQuestionUpdateManyAndReturnArgs} args - Arguments to update many UserCustomQuestions.
     * @example
     * // Update many UserCustomQuestions
     * const userCustomQuestion = await prisma.userCustomQuestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserCustomQuestions and only return the `id`
     * const userCustomQuestionWithIdOnly = await prisma.userCustomQuestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserCustomQuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, UserCustomQuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCustomQuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserCustomQuestion.
     * @param {UserCustomQuestionUpsertArgs} args - Arguments to update or create a UserCustomQuestion.
     * @example
     * // Update or create a UserCustomQuestion
     * const userCustomQuestion = await prisma.userCustomQuestion.upsert({
     *   create: {
     *     // ... data to create a UserCustomQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserCustomQuestion we want to update
     *   }
     * })
     */
    upsert<T extends UserCustomQuestionUpsertArgs>(args: SelectSubset<T, UserCustomQuestionUpsertArgs<ExtArgs>>): Prisma__UserCustomQuestionClient<$Result.GetResult<Prisma.$UserCustomQuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserCustomQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCustomQuestionCountArgs} args - Arguments to filter UserCustomQuestions to count.
     * @example
     * // Count the number of UserCustomQuestions
     * const count = await prisma.userCustomQuestion.count({
     *   where: {
     *     // ... the filter for the UserCustomQuestions we want to count
     *   }
     * })
    **/
    count<T extends UserCustomQuestionCountArgs>(
      args?: Subset<T, UserCustomQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCustomQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserCustomQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCustomQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserCustomQuestionAggregateArgs>(args: Subset<T, UserCustomQuestionAggregateArgs>): Prisma.PrismaPromise<GetUserCustomQuestionAggregateType<T>>

    /**
     * Group by UserCustomQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCustomQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserCustomQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserCustomQuestionGroupByArgs['orderBy'] }
        : { orderBy?: UserCustomQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserCustomQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserCustomQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserCustomQuestion model
   */
  readonly fields: UserCustomQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserCustomQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserCustomQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserCustomQuestion model
   */
  interface UserCustomQuestionFieldRefs {
    readonly id: FieldRef<"UserCustomQuestion", 'String'>
    readonly question: FieldRef<"UserCustomQuestion", 'String'>
    readonly answer: FieldRef<"UserCustomQuestion", 'String'>
    readonly sortOrder: FieldRef<"UserCustomQuestion", 'Int'>
    readonly userId: FieldRef<"UserCustomQuestion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserCustomQuestion findUnique
   */
  export type UserCustomQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCustomQuestion
     */
    select?: UserCustomQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCustomQuestion
     */
    omit?: UserCustomQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCustomQuestionInclude<ExtArgs> | null
    /**
     * Filter, which UserCustomQuestion to fetch.
     */
    where: UserCustomQuestionWhereUniqueInput
  }

  /**
   * UserCustomQuestion findUniqueOrThrow
   */
  export type UserCustomQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCustomQuestion
     */
    select?: UserCustomQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCustomQuestion
     */
    omit?: UserCustomQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCustomQuestionInclude<ExtArgs> | null
    /**
     * Filter, which UserCustomQuestion to fetch.
     */
    where: UserCustomQuestionWhereUniqueInput
  }

  /**
   * UserCustomQuestion findFirst
   */
  export type UserCustomQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCustomQuestion
     */
    select?: UserCustomQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCustomQuestion
     */
    omit?: UserCustomQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCustomQuestionInclude<ExtArgs> | null
    /**
     * Filter, which UserCustomQuestion to fetch.
     */
    where?: UserCustomQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCustomQuestions to fetch.
     */
    orderBy?: UserCustomQuestionOrderByWithRelationInput | UserCustomQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCustomQuestions.
     */
    cursor?: UserCustomQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCustomQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCustomQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCustomQuestions.
     */
    distinct?: UserCustomQuestionScalarFieldEnum | UserCustomQuestionScalarFieldEnum[]
  }

  /**
   * UserCustomQuestion findFirstOrThrow
   */
  export type UserCustomQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCustomQuestion
     */
    select?: UserCustomQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCustomQuestion
     */
    omit?: UserCustomQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCustomQuestionInclude<ExtArgs> | null
    /**
     * Filter, which UserCustomQuestion to fetch.
     */
    where?: UserCustomQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCustomQuestions to fetch.
     */
    orderBy?: UserCustomQuestionOrderByWithRelationInput | UserCustomQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCustomQuestions.
     */
    cursor?: UserCustomQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCustomQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCustomQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCustomQuestions.
     */
    distinct?: UserCustomQuestionScalarFieldEnum | UserCustomQuestionScalarFieldEnum[]
  }

  /**
   * UserCustomQuestion findMany
   */
  export type UserCustomQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCustomQuestion
     */
    select?: UserCustomQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCustomQuestion
     */
    omit?: UserCustomQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCustomQuestionInclude<ExtArgs> | null
    /**
     * Filter, which UserCustomQuestions to fetch.
     */
    where?: UserCustomQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCustomQuestions to fetch.
     */
    orderBy?: UserCustomQuestionOrderByWithRelationInput | UserCustomQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserCustomQuestions.
     */
    cursor?: UserCustomQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCustomQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCustomQuestions.
     */
    skip?: number
    distinct?: UserCustomQuestionScalarFieldEnum | UserCustomQuestionScalarFieldEnum[]
  }

  /**
   * UserCustomQuestion create
   */
  export type UserCustomQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCustomQuestion
     */
    select?: UserCustomQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCustomQuestion
     */
    omit?: UserCustomQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCustomQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserCustomQuestion.
     */
    data: XOR<UserCustomQuestionCreateInput, UserCustomQuestionUncheckedCreateInput>
  }

  /**
   * UserCustomQuestion createMany
   */
  export type UserCustomQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserCustomQuestions.
     */
    data: UserCustomQuestionCreateManyInput | UserCustomQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserCustomQuestion createManyAndReturn
   */
  export type UserCustomQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCustomQuestion
     */
    select?: UserCustomQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserCustomQuestion
     */
    omit?: UserCustomQuestionOmit<ExtArgs> | null
    /**
     * The data used to create many UserCustomQuestions.
     */
    data: UserCustomQuestionCreateManyInput | UserCustomQuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCustomQuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserCustomQuestion update
   */
  export type UserCustomQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCustomQuestion
     */
    select?: UserCustomQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCustomQuestion
     */
    omit?: UserCustomQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCustomQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserCustomQuestion.
     */
    data: XOR<UserCustomQuestionUpdateInput, UserCustomQuestionUncheckedUpdateInput>
    /**
     * Choose, which UserCustomQuestion to update.
     */
    where: UserCustomQuestionWhereUniqueInput
  }

  /**
   * UserCustomQuestion updateMany
   */
  export type UserCustomQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserCustomQuestions.
     */
    data: XOR<UserCustomQuestionUpdateManyMutationInput, UserCustomQuestionUncheckedUpdateManyInput>
    /**
     * Filter which UserCustomQuestions to update
     */
    where?: UserCustomQuestionWhereInput
    /**
     * Limit how many UserCustomQuestions to update.
     */
    limit?: number
  }

  /**
   * UserCustomQuestion updateManyAndReturn
   */
  export type UserCustomQuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCustomQuestion
     */
    select?: UserCustomQuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserCustomQuestion
     */
    omit?: UserCustomQuestionOmit<ExtArgs> | null
    /**
     * The data used to update UserCustomQuestions.
     */
    data: XOR<UserCustomQuestionUpdateManyMutationInput, UserCustomQuestionUncheckedUpdateManyInput>
    /**
     * Filter which UserCustomQuestions to update
     */
    where?: UserCustomQuestionWhereInput
    /**
     * Limit how many UserCustomQuestions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCustomQuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserCustomQuestion upsert
   */
  export type UserCustomQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCustomQuestion
     */
    select?: UserCustomQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCustomQuestion
     */
    omit?: UserCustomQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCustomQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserCustomQuestion to update in case it exists.
     */
    where: UserCustomQuestionWhereUniqueInput
    /**
     * In case the UserCustomQuestion found by the `where` argument doesn't exist, create a new UserCustomQuestion with this data.
     */
    create: XOR<UserCustomQuestionCreateInput, UserCustomQuestionUncheckedCreateInput>
    /**
     * In case the UserCustomQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserCustomQuestionUpdateInput, UserCustomQuestionUncheckedUpdateInput>
  }

  /**
   * UserCustomQuestion delete
   */
  export type UserCustomQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCustomQuestion
     */
    select?: UserCustomQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCustomQuestion
     */
    omit?: UserCustomQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCustomQuestionInclude<ExtArgs> | null
    /**
     * Filter which UserCustomQuestion to delete.
     */
    where: UserCustomQuestionWhereUniqueInput
  }

  /**
   * UserCustomQuestion deleteMany
   */
  export type UserCustomQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCustomQuestions to delete
     */
    where?: UserCustomQuestionWhereInput
    /**
     * Limit how many UserCustomQuestions to delete.
     */
    limit?: number
  }

  /**
   * UserCustomQuestion without action
   */
  export type UserCustomQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCustomQuestion
     */
    select?: UserCustomQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCustomQuestion
     */
    omit?: UserCustomQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCustomQuestionInclude<ExtArgs> | null
  }


  /**
   * Model UserImageCarousel
   */

  export type AggregateUserImageCarousel = {
    _count: UserImageCarouselCountAggregateOutputType | null
    _avg: UserImageCarouselAvgAggregateOutputType | null
    _sum: UserImageCarouselSumAggregateOutputType | null
    _min: UserImageCarouselMinAggregateOutputType | null
    _max: UserImageCarouselMaxAggregateOutputType | null
  }

  export type UserImageCarouselAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type UserImageCarouselSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type UserImageCarouselMinAggregateOutputType = {
    id: string | null
    url: string | null
    imgUrl: string | null
    alt: string | null
    sortOrder: number | null
    userId: string | null
  }

  export type UserImageCarouselMaxAggregateOutputType = {
    id: string | null
    url: string | null
    imgUrl: string | null
    alt: string | null
    sortOrder: number | null
    userId: string | null
  }

  export type UserImageCarouselCountAggregateOutputType = {
    id: number
    url: number
    imgUrl: number
    alt: number
    sortOrder: number
    userId: number
    _all: number
  }


  export type UserImageCarouselAvgAggregateInputType = {
    sortOrder?: true
  }

  export type UserImageCarouselSumAggregateInputType = {
    sortOrder?: true
  }

  export type UserImageCarouselMinAggregateInputType = {
    id?: true
    url?: true
    imgUrl?: true
    alt?: true
    sortOrder?: true
    userId?: true
  }

  export type UserImageCarouselMaxAggregateInputType = {
    id?: true
    url?: true
    imgUrl?: true
    alt?: true
    sortOrder?: true
    userId?: true
  }

  export type UserImageCarouselCountAggregateInputType = {
    id?: true
    url?: true
    imgUrl?: true
    alt?: true
    sortOrder?: true
    userId?: true
    _all?: true
  }

  export type UserImageCarouselAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserImageCarousel to aggregate.
     */
    where?: UserImageCarouselWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserImageCarousels to fetch.
     */
    orderBy?: UserImageCarouselOrderByWithRelationInput | UserImageCarouselOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserImageCarouselWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserImageCarousels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserImageCarousels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserImageCarousels
    **/
    _count?: true | UserImageCarouselCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserImageCarouselAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserImageCarouselSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserImageCarouselMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserImageCarouselMaxAggregateInputType
  }

  export type GetUserImageCarouselAggregateType<T extends UserImageCarouselAggregateArgs> = {
        [P in keyof T & keyof AggregateUserImageCarousel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserImageCarousel[P]>
      : GetScalarType<T[P], AggregateUserImageCarousel[P]>
  }




  export type UserImageCarouselGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserImageCarouselWhereInput
    orderBy?: UserImageCarouselOrderByWithAggregationInput | UserImageCarouselOrderByWithAggregationInput[]
    by: UserImageCarouselScalarFieldEnum[] | UserImageCarouselScalarFieldEnum
    having?: UserImageCarouselScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserImageCarouselCountAggregateInputType | true
    _avg?: UserImageCarouselAvgAggregateInputType
    _sum?: UserImageCarouselSumAggregateInputType
    _min?: UserImageCarouselMinAggregateInputType
    _max?: UserImageCarouselMaxAggregateInputType
  }

  export type UserImageCarouselGroupByOutputType = {
    id: string
    url: string | null
    imgUrl: string
    alt: string | null
    sortOrder: number
    userId: string
    _count: UserImageCarouselCountAggregateOutputType | null
    _avg: UserImageCarouselAvgAggregateOutputType | null
    _sum: UserImageCarouselSumAggregateOutputType | null
    _min: UserImageCarouselMinAggregateOutputType | null
    _max: UserImageCarouselMaxAggregateOutputType | null
  }

  type GetUserImageCarouselGroupByPayload<T extends UserImageCarouselGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserImageCarouselGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserImageCarouselGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserImageCarouselGroupByOutputType[P]>
            : GetScalarType<T[P], UserImageCarouselGroupByOutputType[P]>
        }
      >
    >


  export type UserImageCarouselSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    imgUrl?: boolean
    alt?: boolean
    sortOrder?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userImageCarousel"]>

  export type UserImageCarouselSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    imgUrl?: boolean
    alt?: boolean
    sortOrder?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userImageCarousel"]>

  export type UserImageCarouselSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    imgUrl?: boolean
    alt?: boolean
    sortOrder?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userImageCarousel"]>

  export type UserImageCarouselSelectScalar = {
    id?: boolean
    url?: boolean
    imgUrl?: boolean
    alt?: boolean
    sortOrder?: boolean
    userId?: boolean
  }

  export type UserImageCarouselOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "imgUrl" | "alt" | "sortOrder" | "userId", ExtArgs["result"]["userImageCarousel"]>
  export type UserImageCarouselInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserImageCarouselIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserImageCarouselIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserImageCarouselPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserImageCarousel"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string | null
      imgUrl: string
      alt: string | null
      sortOrder: number
      userId: string
    }, ExtArgs["result"]["userImageCarousel"]>
    composites: {}
  }

  type UserImageCarouselGetPayload<S extends boolean | null | undefined | UserImageCarouselDefaultArgs> = $Result.GetResult<Prisma.$UserImageCarouselPayload, S>

  type UserImageCarouselCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserImageCarouselFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserImageCarouselCountAggregateInputType | true
    }

  export interface UserImageCarouselDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserImageCarousel'], meta: { name: 'UserImageCarousel' } }
    /**
     * Find zero or one UserImageCarousel that matches the filter.
     * @param {UserImageCarouselFindUniqueArgs} args - Arguments to find a UserImageCarousel
     * @example
     * // Get one UserImageCarousel
     * const userImageCarousel = await prisma.userImageCarousel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserImageCarouselFindUniqueArgs>(args: SelectSubset<T, UserImageCarouselFindUniqueArgs<ExtArgs>>): Prisma__UserImageCarouselClient<$Result.GetResult<Prisma.$UserImageCarouselPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserImageCarousel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserImageCarouselFindUniqueOrThrowArgs} args - Arguments to find a UserImageCarousel
     * @example
     * // Get one UserImageCarousel
     * const userImageCarousel = await prisma.userImageCarousel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserImageCarouselFindUniqueOrThrowArgs>(args: SelectSubset<T, UserImageCarouselFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserImageCarouselClient<$Result.GetResult<Prisma.$UserImageCarouselPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserImageCarousel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserImageCarouselFindFirstArgs} args - Arguments to find a UserImageCarousel
     * @example
     * // Get one UserImageCarousel
     * const userImageCarousel = await prisma.userImageCarousel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserImageCarouselFindFirstArgs>(args?: SelectSubset<T, UserImageCarouselFindFirstArgs<ExtArgs>>): Prisma__UserImageCarouselClient<$Result.GetResult<Prisma.$UserImageCarouselPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserImageCarousel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserImageCarouselFindFirstOrThrowArgs} args - Arguments to find a UserImageCarousel
     * @example
     * // Get one UserImageCarousel
     * const userImageCarousel = await prisma.userImageCarousel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserImageCarouselFindFirstOrThrowArgs>(args?: SelectSubset<T, UserImageCarouselFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserImageCarouselClient<$Result.GetResult<Prisma.$UserImageCarouselPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserImageCarousels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserImageCarouselFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserImageCarousels
     * const userImageCarousels = await prisma.userImageCarousel.findMany()
     * 
     * // Get first 10 UserImageCarousels
     * const userImageCarousels = await prisma.userImageCarousel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userImageCarouselWithIdOnly = await prisma.userImageCarousel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserImageCarouselFindManyArgs>(args?: SelectSubset<T, UserImageCarouselFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserImageCarouselPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserImageCarousel.
     * @param {UserImageCarouselCreateArgs} args - Arguments to create a UserImageCarousel.
     * @example
     * // Create one UserImageCarousel
     * const UserImageCarousel = await prisma.userImageCarousel.create({
     *   data: {
     *     // ... data to create a UserImageCarousel
     *   }
     * })
     * 
     */
    create<T extends UserImageCarouselCreateArgs>(args: SelectSubset<T, UserImageCarouselCreateArgs<ExtArgs>>): Prisma__UserImageCarouselClient<$Result.GetResult<Prisma.$UserImageCarouselPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserImageCarousels.
     * @param {UserImageCarouselCreateManyArgs} args - Arguments to create many UserImageCarousels.
     * @example
     * // Create many UserImageCarousels
     * const userImageCarousel = await prisma.userImageCarousel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserImageCarouselCreateManyArgs>(args?: SelectSubset<T, UserImageCarouselCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserImageCarousels and returns the data saved in the database.
     * @param {UserImageCarouselCreateManyAndReturnArgs} args - Arguments to create many UserImageCarousels.
     * @example
     * // Create many UserImageCarousels
     * const userImageCarousel = await prisma.userImageCarousel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserImageCarousels and only return the `id`
     * const userImageCarouselWithIdOnly = await prisma.userImageCarousel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserImageCarouselCreateManyAndReturnArgs>(args?: SelectSubset<T, UserImageCarouselCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserImageCarouselPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserImageCarousel.
     * @param {UserImageCarouselDeleteArgs} args - Arguments to delete one UserImageCarousel.
     * @example
     * // Delete one UserImageCarousel
     * const UserImageCarousel = await prisma.userImageCarousel.delete({
     *   where: {
     *     // ... filter to delete one UserImageCarousel
     *   }
     * })
     * 
     */
    delete<T extends UserImageCarouselDeleteArgs>(args: SelectSubset<T, UserImageCarouselDeleteArgs<ExtArgs>>): Prisma__UserImageCarouselClient<$Result.GetResult<Prisma.$UserImageCarouselPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserImageCarousel.
     * @param {UserImageCarouselUpdateArgs} args - Arguments to update one UserImageCarousel.
     * @example
     * // Update one UserImageCarousel
     * const userImageCarousel = await prisma.userImageCarousel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserImageCarouselUpdateArgs>(args: SelectSubset<T, UserImageCarouselUpdateArgs<ExtArgs>>): Prisma__UserImageCarouselClient<$Result.GetResult<Prisma.$UserImageCarouselPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserImageCarousels.
     * @param {UserImageCarouselDeleteManyArgs} args - Arguments to filter UserImageCarousels to delete.
     * @example
     * // Delete a few UserImageCarousels
     * const { count } = await prisma.userImageCarousel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserImageCarouselDeleteManyArgs>(args?: SelectSubset<T, UserImageCarouselDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserImageCarousels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserImageCarouselUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserImageCarousels
     * const userImageCarousel = await prisma.userImageCarousel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserImageCarouselUpdateManyArgs>(args: SelectSubset<T, UserImageCarouselUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserImageCarousels and returns the data updated in the database.
     * @param {UserImageCarouselUpdateManyAndReturnArgs} args - Arguments to update many UserImageCarousels.
     * @example
     * // Update many UserImageCarousels
     * const userImageCarousel = await prisma.userImageCarousel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserImageCarousels and only return the `id`
     * const userImageCarouselWithIdOnly = await prisma.userImageCarousel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserImageCarouselUpdateManyAndReturnArgs>(args: SelectSubset<T, UserImageCarouselUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserImageCarouselPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserImageCarousel.
     * @param {UserImageCarouselUpsertArgs} args - Arguments to update or create a UserImageCarousel.
     * @example
     * // Update or create a UserImageCarousel
     * const userImageCarousel = await prisma.userImageCarousel.upsert({
     *   create: {
     *     // ... data to create a UserImageCarousel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserImageCarousel we want to update
     *   }
     * })
     */
    upsert<T extends UserImageCarouselUpsertArgs>(args: SelectSubset<T, UserImageCarouselUpsertArgs<ExtArgs>>): Prisma__UserImageCarouselClient<$Result.GetResult<Prisma.$UserImageCarouselPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserImageCarousels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserImageCarouselCountArgs} args - Arguments to filter UserImageCarousels to count.
     * @example
     * // Count the number of UserImageCarousels
     * const count = await prisma.userImageCarousel.count({
     *   where: {
     *     // ... the filter for the UserImageCarousels we want to count
     *   }
     * })
    **/
    count<T extends UserImageCarouselCountArgs>(
      args?: Subset<T, UserImageCarouselCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserImageCarouselCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserImageCarousel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserImageCarouselAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserImageCarouselAggregateArgs>(args: Subset<T, UserImageCarouselAggregateArgs>): Prisma.PrismaPromise<GetUserImageCarouselAggregateType<T>>

    /**
     * Group by UserImageCarousel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserImageCarouselGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserImageCarouselGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserImageCarouselGroupByArgs['orderBy'] }
        : { orderBy?: UserImageCarouselGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserImageCarouselGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserImageCarouselGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserImageCarousel model
   */
  readonly fields: UserImageCarouselFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserImageCarousel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserImageCarouselClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserImageCarousel model
   */
  interface UserImageCarouselFieldRefs {
    readonly id: FieldRef<"UserImageCarousel", 'String'>
    readonly url: FieldRef<"UserImageCarousel", 'String'>
    readonly imgUrl: FieldRef<"UserImageCarousel", 'String'>
    readonly alt: FieldRef<"UserImageCarousel", 'String'>
    readonly sortOrder: FieldRef<"UserImageCarousel", 'Int'>
    readonly userId: FieldRef<"UserImageCarousel", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserImageCarousel findUnique
   */
  export type UserImageCarouselFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageCarousel
     */
    select?: UserImageCarouselSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageCarousel
     */
    omit?: UserImageCarouselOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageCarouselInclude<ExtArgs> | null
    /**
     * Filter, which UserImageCarousel to fetch.
     */
    where: UserImageCarouselWhereUniqueInput
  }

  /**
   * UserImageCarousel findUniqueOrThrow
   */
  export type UserImageCarouselFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageCarousel
     */
    select?: UserImageCarouselSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageCarousel
     */
    omit?: UserImageCarouselOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageCarouselInclude<ExtArgs> | null
    /**
     * Filter, which UserImageCarousel to fetch.
     */
    where: UserImageCarouselWhereUniqueInput
  }

  /**
   * UserImageCarousel findFirst
   */
  export type UserImageCarouselFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageCarousel
     */
    select?: UserImageCarouselSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageCarousel
     */
    omit?: UserImageCarouselOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageCarouselInclude<ExtArgs> | null
    /**
     * Filter, which UserImageCarousel to fetch.
     */
    where?: UserImageCarouselWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserImageCarousels to fetch.
     */
    orderBy?: UserImageCarouselOrderByWithRelationInput | UserImageCarouselOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserImageCarousels.
     */
    cursor?: UserImageCarouselWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserImageCarousels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserImageCarousels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserImageCarousels.
     */
    distinct?: UserImageCarouselScalarFieldEnum | UserImageCarouselScalarFieldEnum[]
  }

  /**
   * UserImageCarousel findFirstOrThrow
   */
  export type UserImageCarouselFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageCarousel
     */
    select?: UserImageCarouselSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageCarousel
     */
    omit?: UserImageCarouselOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageCarouselInclude<ExtArgs> | null
    /**
     * Filter, which UserImageCarousel to fetch.
     */
    where?: UserImageCarouselWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserImageCarousels to fetch.
     */
    orderBy?: UserImageCarouselOrderByWithRelationInput | UserImageCarouselOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserImageCarousels.
     */
    cursor?: UserImageCarouselWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserImageCarousels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserImageCarousels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserImageCarousels.
     */
    distinct?: UserImageCarouselScalarFieldEnum | UserImageCarouselScalarFieldEnum[]
  }

  /**
   * UserImageCarousel findMany
   */
  export type UserImageCarouselFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageCarousel
     */
    select?: UserImageCarouselSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageCarousel
     */
    omit?: UserImageCarouselOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageCarouselInclude<ExtArgs> | null
    /**
     * Filter, which UserImageCarousels to fetch.
     */
    where?: UserImageCarouselWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserImageCarousels to fetch.
     */
    orderBy?: UserImageCarouselOrderByWithRelationInput | UserImageCarouselOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserImageCarousels.
     */
    cursor?: UserImageCarouselWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserImageCarousels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserImageCarousels.
     */
    skip?: number
    distinct?: UserImageCarouselScalarFieldEnum | UserImageCarouselScalarFieldEnum[]
  }

  /**
   * UserImageCarousel create
   */
  export type UserImageCarouselCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageCarousel
     */
    select?: UserImageCarouselSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageCarousel
     */
    omit?: UserImageCarouselOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageCarouselInclude<ExtArgs> | null
    /**
     * The data needed to create a UserImageCarousel.
     */
    data: XOR<UserImageCarouselCreateInput, UserImageCarouselUncheckedCreateInput>
  }

  /**
   * UserImageCarousel createMany
   */
  export type UserImageCarouselCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserImageCarousels.
     */
    data: UserImageCarouselCreateManyInput | UserImageCarouselCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserImageCarousel createManyAndReturn
   */
  export type UserImageCarouselCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageCarousel
     */
    select?: UserImageCarouselSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageCarousel
     */
    omit?: UserImageCarouselOmit<ExtArgs> | null
    /**
     * The data used to create many UserImageCarousels.
     */
    data: UserImageCarouselCreateManyInput | UserImageCarouselCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageCarouselIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserImageCarousel update
   */
  export type UserImageCarouselUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageCarousel
     */
    select?: UserImageCarouselSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageCarousel
     */
    omit?: UserImageCarouselOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageCarouselInclude<ExtArgs> | null
    /**
     * The data needed to update a UserImageCarousel.
     */
    data: XOR<UserImageCarouselUpdateInput, UserImageCarouselUncheckedUpdateInput>
    /**
     * Choose, which UserImageCarousel to update.
     */
    where: UserImageCarouselWhereUniqueInput
  }

  /**
   * UserImageCarousel updateMany
   */
  export type UserImageCarouselUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserImageCarousels.
     */
    data: XOR<UserImageCarouselUpdateManyMutationInput, UserImageCarouselUncheckedUpdateManyInput>
    /**
     * Filter which UserImageCarousels to update
     */
    where?: UserImageCarouselWhereInput
    /**
     * Limit how many UserImageCarousels to update.
     */
    limit?: number
  }

  /**
   * UserImageCarousel updateManyAndReturn
   */
  export type UserImageCarouselUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageCarousel
     */
    select?: UserImageCarouselSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageCarousel
     */
    omit?: UserImageCarouselOmit<ExtArgs> | null
    /**
     * The data used to update UserImageCarousels.
     */
    data: XOR<UserImageCarouselUpdateManyMutationInput, UserImageCarouselUncheckedUpdateManyInput>
    /**
     * Filter which UserImageCarousels to update
     */
    where?: UserImageCarouselWhereInput
    /**
     * Limit how many UserImageCarousels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageCarouselIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserImageCarousel upsert
   */
  export type UserImageCarouselUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageCarousel
     */
    select?: UserImageCarouselSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageCarousel
     */
    omit?: UserImageCarouselOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageCarouselInclude<ExtArgs> | null
    /**
     * The filter to search for the UserImageCarousel to update in case it exists.
     */
    where: UserImageCarouselWhereUniqueInput
    /**
     * In case the UserImageCarousel found by the `where` argument doesn't exist, create a new UserImageCarousel with this data.
     */
    create: XOR<UserImageCarouselCreateInput, UserImageCarouselUncheckedCreateInput>
    /**
     * In case the UserImageCarousel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserImageCarouselUpdateInput, UserImageCarouselUncheckedUpdateInput>
  }

  /**
   * UserImageCarousel delete
   */
  export type UserImageCarouselDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageCarousel
     */
    select?: UserImageCarouselSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageCarousel
     */
    omit?: UserImageCarouselOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageCarouselInclude<ExtArgs> | null
    /**
     * Filter which UserImageCarousel to delete.
     */
    where: UserImageCarouselWhereUniqueInput
  }

  /**
   * UserImageCarousel deleteMany
   */
  export type UserImageCarouselDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserImageCarousels to delete
     */
    where?: UserImageCarouselWhereInput
    /**
     * Limit how many UserImageCarousels to delete.
     */
    limit?: number
  }

  /**
   * UserImageCarousel without action
   */
  export type UserImageCarouselDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageCarousel
     */
    select?: UserImageCarouselSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageCarousel
     */
    omit?: UserImageCarouselOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageCarouselInclude<ExtArgs> | null
  }


  /**
   * Model UserImageSidebar
   */

  export type AggregateUserImageSidebar = {
    _count: UserImageSidebarCountAggregateOutputType | null
    _avg: UserImageSidebarAvgAggregateOutputType | null
    _sum: UserImageSidebarSumAggregateOutputType | null
    _min: UserImageSidebarMinAggregateOutputType | null
    _max: UserImageSidebarMaxAggregateOutputType | null
  }

  export type UserImageSidebarAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type UserImageSidebarSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type UserImageSidebarMinAggregateOutputType = {
    id: string | null
    url: string | null
    imgUrl: string | null
    alt: string | null
    sortOrder: number | null
    userId: string | null
  }

  export type UserImageSidebarMaxAggregateOutputType = {
    id: string | null
    url: string | null
    imgUrl: string | null
    alt: string | null
    sortOrder: number | null
    userId: string | null
  }

  export type UserImageSidebarCountAggregateOutputType = {
    id: number
    url: number
    imgUrl: number
    alt: number
    sortOrder: number
    userId: number
    _all: number
  }


  export type UserImageSidebarAvgAggregateInputType = {
    sortOrder?: true
  }

  export type UserImageSidebarSumAggregateInputType = {
    sortOrder?: true
  }

  export type UserImageSidebarMinAggregateInputType = {
    id?: true
    url?: true
    imgUrl?: true
    alt?: true
    sortOrder?: true
    userId?: true
  }

  export type UserImageSidebarMaxAggregateInputType = {
    id?: true
    url?: true
    imgUrl?: true
    alt?: true
    sortOrder?: true
    userId?: true
  }

  export type UserImageSidebarCountAggregateInputType = {
    id?: true
    url?: true
    imgUrl?: true
    alt?: true
    sortOrder?: true
    userId?: true
    _all?: true
  }

  export type UserImageSidebarAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserImageSidebar to aggregate.
     */
    where?: UserImageSidebarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserImageSidebars to fetch.
     */
    orderBy?: UserImageSidebarOrderByWithRelationInput | UserImageSidebarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserImageSidebarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserImageSidebars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserImageSidebars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserImageSidebars
    **/
    _count?: true | UserImageSidebarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserImageSidebarAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserImageSidebarSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserImageSidebarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserImageSidebarMaxAggregateInputType
  }

  export type GetUserImageSidebarAggregateType<T extends UserImageSidebarAggregateArgs> = {
        [P in keyof T & keyof AggregateUserImageSidebar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserImageSidebar[P]>
      : GetScalarType<T[P], AggregateUserImageSidebar[P]>
  }




  export type UserImageSidebarGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserImageSidebarWhereInput
    orderBy?: UserImageSidebarOrderByWithAggregationInput | UserImageSidebarOrderByWithAggregationInput[]
    by: UserImageSidebarScalarFieldEnum[] | UserImageSidebarScalarFieldEnum
    having?: UserImageSidebarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserImageSidebarCountAggregateInputType | true
    _avg?: UserImageSidebarAvgAggregateInputType
    _sum?: UserImageSidebarSumAggregateInputType
    _min?: UserImageSidebarMinAggregateInputType
    _max?: UserImageSidebarMaxAggregateInputType
  }

  export type UserImageSidebarGroupByOutputType = {
    id: string
    url: string | null
    imgUrl: string
    alt: string | null
    sortOrder: number
    userId: string
    _count: UserImageSidebarCountAggregateOutputType | null
    _avg: UserImageSidebarAvgAggregateOutputType | null
    _sum: UserImageSidebarSumAggregateOutputType | null
    _min: UserImageSidebarMinAggregateOutputType | null
    _max: UserImageSidebarMaxAggregateOutputType | null
  }

  type GetUserImageSidebarGroupByPayload<T extends UserImageSidebarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserImageSidebarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserImageSidebarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserImageSidebarGroupByOutputType[P]>
            : GetScalarType<T[P], UserImageSidebarGroupByOutputType[P]>
        }
      >
    >


  export type UserImageSidebarSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    imgUrl?: boolean
    alt?: boolean
    sortOrder?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userImageSidebar"]>

  export type UserImageSidebarSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    imgUrl?: boolean
    alt?: boolean
    sortOrder?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userImageSidebar"]>

  export type UserImageSidebarSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    imgUrl?: boolean
    alt?: boolean
    sortOrder?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userImageSidebar"]>

  export type UserImageSidebarSelectScalar = {
    id?: boolean
    url?: boolean
    imgUrl?: boolean
    alt?: boolean
    sortOrder?: boolean
    userId?: boolean
  }

  export type UserImageSidebarOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "imgUrl" | "alt" | "sortOrder" | "userId", ExtArgs["result"]["userImageSidebar"]>
  export type UserImageSidebarInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserImageSidebarIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserImageSidebarIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserImageSidebarPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserImageSidebar"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string | null
      imgUrl: string
      alt: string | null
      sortOrder: number
      userId: string
    }, ExtArgs["result"]["userImageSidebar"]>
    composites: {}
  }

  type UserImageSidebarGetPayload<S extends boolean | null | undefined | UserImageSidebarDefaultArgs> = $Result.GetResult<Prisma.$UserImageSidebarPayload, S>

  type UserImageSidebarCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserImageSidebarFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserImageSidebarCountAggregateInputType | true
    }

  export interface UserImageSidebarDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserImageSidebar'], meta: { name: 'UserImageSidebar' } }
    /**
     * Find zero or one UserImageSidebar that matches the filter.
     * @param {UserImageSidebarFindUniqueArgs} args - Arguments to find a UserImageSidebar
     * @example
     * // Get one UserImageSidebar
     * const userImageSidebar = await prisma.userImageSidebar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserImageSidebarFindUniqueArgs>(args: SelectSubset<T, UserImageSidebarFindUniqueArgs<ExtArgs>>): Prisma__UserImageSidebarClient<$Result.GetResult<Prisma.$UserImageSidebarPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserImageSidebar that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserImageSidebarFindUniqueOrThrowArgs} args - Arguments to find a UserImageSidebar
     * @example
     * // Get one UserImageSidebar
     * const userImageSidebar = await prisma.userImageSidebar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserImageSidebarFindUniqueOrThrowArgs>(args: SelectSubset<T, UserImageSidebarFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserImageSidebarClient<$Result.GetResult<Prisma.$UserImageSidebarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserImageSidebar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserImageSidebarFindFirstArgs} args - Arguments to find a UserImageSidebar
     * @example
     * // Get one UserImageSidebar
     * const userImageSidebar = await prisma.userImageSidebar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserImageSidebarFindFirstArgs>(args?: SelectSubset<T, UserImageSidebarFindFirstArgs<ExtArgs>>): Prisma__UserImageSidebarClient<$Result.GetResult<Prisma.$UserImageSidebarPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserImageSidebar that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserImageSidebarFindFirstOrThrowArgs} args - Arguments to find a UserImageSidebar
     * @example
     * // Get one UserImageSidebar
     * const userImageSidebar = await prisma.userImageSidebar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserImageSidebarFindFirstOrThrowArgs>(args?: SelectSubset<T, UserImageSidebarFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserImageSidebarClient<$Result.GetResult<Prisma.$UserImageSidebarPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserImageSidebars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserImageSidebarFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserImageSidebars
     * const userImageSidebars = await prisma.userImageSidebar.findMany()
     * 
     * // Get first 10 UserImageSidebars
     * const userImageSidebars = await prisma.userImageSidebar.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userImageSidebarWithIdOnly = await prisma.userImageSidebar.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserImageSidebarFindManyArgs>(args?: SelectSubset<T, UserImageSidebarFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserImageSidebarPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserImageSidebar.
     * @param {UserImageSidebarCreateArgs} args - Arguments to create a UserImageSidebar.
     * @example
     * // Create one UserImageSidebar
     * const UserImageSidebar = await prisma.userImageSidebar.create({
     *   data: {
     *     // ... data to create a UserImageSidebar
     *   }
     * })
     * 
     */
    create<T extends UserImageSidebarCreateArgs>(args: SelectSubset<T, UserImageSidebarCreateArgs<ExtArgs>>): Prisma__UserImageSidebarClient<$Result.GetResult<Prisma.$UserImageSidebarPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserImageSidebars.
     * @param {UserImageSidebarCreateManyArgs} args - Arguments to create many UserImageSidebars.
     * @example
     * // Create many UserImageSidebars
     * const userImageSidebar = await prisma.userImageSidebar.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserImageSidebarCreateManyArgs>(args?: SelectSubset<T, UserImageSidebarCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserImageSidebars and returns the data saved in the database.
     * @param {UserImageSidebarCreateManyAndReturnArgs} args - Arguments to create many UserImageSidebars.
     * @example
     * // Create many UserImageSidebars
     * const userImageSidebar = await prisma.userImageSidebar.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserImageSidebars and only return the `id`
     * const userImageSidebarWithIdOnly = await prisma.userImageSidebar.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserImageSidebarCreateManyAndReturnArgs>(args?: SelectSubset<T, UserImageSidebarCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserImageSidebarPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserImageSidebar.
     * @param {UserImageSidebarDeleteArgs} args - Arguments to delete one UserImageSidebar.
     * @example
     * // Delete one UserImageSidebar
     * const UserImageSidebar = await prisma.userImageSidebar.delete({
     *   where: {
     *     // ... filter to delete one UserImageSidebar
     *   }
     * })
     * 
     */
    delete<T extends UserImageSidebarDeleteArgs>(args: SelectSubset<T, UserImageSidebarDeleteArgs<ExtArgs>>): Prisma__UserImageSidebarClient<$Result.GetResult<Prisma.$UserImageSidebarPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserImageSidebar.
     * @param {UserImageSidebarUpdateArgs} args - Arguments to update one UserImageSidebar.
     * @example
     * // Update one UserImageSidebar
     * const userImageSidebar = await prisma.userImageSidebar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserImageSidebarUpdateArgs>(args: SelectSubset<T, UserImageSidebarUpdateArgs<ExtArgs>>): Prisma__UserImageSidebarClient<$Result.GetResult<Prisma.$UserImageSidebarPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserImageSidebars.
     * @param {UserImageSidebarDeleteManyArgs} args - Arguments to filter UserImageSidebars to delete.
     * @example
     * // Delete a few UserImageSidebars
     * const { count } = await prisma.userImageSidebar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserImageSidebarDeleteManyArgs>(args?: SelectSubset<T, UserImageSidebarDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserImageSidebars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserImageSidebarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserImageSidebars
     * const userImageSidebar = await prisma.userImageSidebar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserImageSidebarUpdateManyArgs>(args: SelectSubset<T, UserImageSidebarUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserImageSidebars and returns the data updated in the database.
     * @param {UserImageSidebarUpdateManyAndReturnArgs} args - Arguments to update many UserImageSidebars.
     * @example
     * // Update many UserImageSidebars
     * const userImageSidebar = await prisma.userImageSidebar.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserImageSidebars and only return the `id`
     * const userImageSidebarWithIdOnly = await prisma.userImageSidebar.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserImageSidebarUpdateManyAndReturnArgs>(args: SelectSubset<T, UserImageSidebarUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserImageSidebarPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserImageSidebar.
     * @param {UserImageSidebarUpsertArgs} args - Arguments to update or create a UserImageSidebar.
     * @example
     * // Update or create a UserImageSidebar
     * const userImageSidebar = await prisma.userImageSidebar.upsert({
     *   create: {
     *     // ... data to create a UserImageSidebar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserImageSidebar we want to update
     *   }
     * })
     */
    upsert<T extends UserImageSidebarUpsertArgs>(args: SelectSubset<T, UserImageSidebarUpsertArgs<ExtArgs>>): Prisma__UserImageSidebarClient<$Result.GetResult<Prisma.$UserImageSidebarPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserImageSidebars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserImageSidebarCountArgs} args - Arguments to filter UserImageSidebars to count.
     * @example
     * // Count the number of UserImageSidebars
     * const count = await prisma.userImageSidebar.count({
     *   where: {
     *     // ... the filter for the UserImageSidebars we want to count
     *   }
     * })
    **/
    count<T extends UserImageSidebarCountArgs>(
      args?: Subset<T, UserImageSidebarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserImageSidebarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserImageSidebar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserImageSidebarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserImageSidebarAggregateArgs>(args: Subset<T, UserImageSidebarAggregateArgs>): Prisma.PrismaPromise<GetUserImageSidebarAggregateType<T>>

    /**
     * Group by UserImageSidebar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserImageSidebarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserImageSidebarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserImageSidebarGroupByArgs['orderBy'] }
        : { orderBy?: UserImageSidebarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserImageSidebarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserImageSidebarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserImageSidebar model
   */
  readonly fields: UserImageSidebarFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserImageSidebar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserImageSidebarClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserImageSidebar model
   */
  interface UserImageSidebarFieldRefs {
    readonly id: FieldRef<"UserImageSidebar", 'String'>
    readonly url: FieldRef<"UserImageSidebar", 'String'>
    readonly imgUrl: FieldRef<"UserImageSidebar", 'String'>
    readonly alt: FieldRef<"UserImageSidebar", 'String'>
    readonly sortOrder: FieldRef<"UserImageSidebar", 'Int'>
    readonly userId: FieldRef<"UserImageSidebar", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserImageSidebar findUnique
   */
  export type UserImageSidebarFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageSidebar
     */
    select?: UserImageSidebarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageSidebar
     */
    omit?: UserImageSidebarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageSidebarInclude<ExtArgs> | null
    /**
     * Filter, which UserImageSidebar to fetch.
     */
    where: UserImageSidebarWhereUniqueInput
  }

  /**
   * UserImageSidebar findUniqueOrThrow
   */
  export type UserImageSidebarFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageSidebar
     */
    select?: UserImageSidebarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageSidebar
     */
    omit?: UserImageSidebarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageSidebarInclude<ExtArgs> | null
    /**
     * Filter, which UserImageSidebar to fetch.
     */
    where: UserImageSidebarWhereUniqueInput
  }

  /**
   * UserImageSidebar findFirst
   */
  export type UserImageSidebarFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageSidebar
     */
    select?: UserImageSidebarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageSidebar
     */
    omit?: UserImageSidebarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageSidebarInclude<ExtArgs> | null
    /**
     * Filter, which UserImageSidebar to fetch.
     */
    where?: UserImageSidebarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserImageSidebars to fetch.
     */
    orderBy?: UserImageSidebarOrderByWithRelationInput | UserImageSidebarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserImageSidebars.
     */
    cursor?: UserImageSidebarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserImageSidebars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserImageSidebars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserImageSidebars.
     */
    distinct?: UserImageSidebarScalarFieldEnum | UserImageSidebarScalarFieldEnum[]
  }

  /**
   * UserImageSidebar findFirstOrThrow
   */
  export type UserImageSidebarFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageSidebar
     */
    select?: UserImageSidebarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageSidebar
     */
    omit?: UserImageSidebarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageSidebarInclude<ExtArgs> | null
    /**
     * Filter, which UserImageSidebar to fetch.
     */
    where?: UserImageSidebarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserImageSidebars to fetch.
     */
    orderBy?: UserImageSidebarOrderByWithRelationInput | UserImageSidebarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserImageSidebars.
     */
    cursor?: UserImageSidebarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserImageSidebars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserImageSidebars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserImageSidebars.
     */
    distinct?: UserImageSidebarScalarFieldEnum | UserImageSidebarScalarFieldEnum[]
  }

  /**
   * UserImageSidebar findMany
   */
  export type UserImageSidebarFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageSidebar
     */
    select?: UserImageSidebarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageSidebar
     */
    omit?: UserImageSidebarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageSidebarInclude<ExtArgs> | null
    /**
     * Filter, which UserImageSidebars to fetch.
     */
    where?: UserImageSidebarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserImageSidebars to fetch.
     */
    orderBy?: UserImageSidebarOrderByWithRelationInput | UserImageSidebarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserImageSidebars.
     */
    cursor?: UserImageSidebarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserImageSidebars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserImageSidebars.
     */
    skip?: number
    distinct?: UserImageSidebarScalarFieldEnum | UserImageSidebarScalarFieldEnum[]
  }

  /**
   * UserImageSidebar create
   */
  export type UserImageSidebarCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageSidebar
     */
    select?: UserImageSidebarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageSidebar
     */
    omit?: UserImageSidebarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageSidebarInclude<ExtArgs> | null
    /**
     * The data needed to create a UserImageSidebar.
     */
    data: XOR<UserImageSidebarCreateInput, UserImageSidebarUncheckedCreateInput>
  }

  /**
   * UserImageSidebar createMany
   */
  export type UserImageSidebarCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserImageSidebars.
     */
    data: UserImageSidebarCreateManyInput | UserImageSidebarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserImageSidebar createManyAndReturn
   */
  export type UserImageSidebarCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageSidebar
     */
    select?: UserImageSidebarSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageSidebar
     */
    omit?: UserImageSidebarOmit<ExtArgs> | null
    /**
     * The data used to create many UserImageSidebars.
     */
    data: UserImageSidebarCreateManyInput | UserImageSidebarCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageSidebarIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserImageSidebar update
   */
  export type UserImageSidebarUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageSidebar
     */
    select?: UserImageSidebarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageSidebar
     */
    omit?: UserImageSidebarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageSidebarInclude<ExtArgs> | null
    /**
     * The data needed to update a UserImageSidebar.
     */
    data: XOR<UserImageSidebarUpdateInput, UserImageSidebarUncheckedUpdateInput>
    /**
     * Choose, which UserImageSidebar to update.
     */
    where: UserImageSidebarWhereUniqueInput
  }

  /**
   * UserImageSidebar updateMany
   */
  export type UserImageSidebarUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserImageSidebars.
     */
    data: XOR<UserImageSidebarUpdateManyMutationInput, UserImageSidebarUncheckedUpdateManyInput>
    /**
     * Filter which UserImageSidebars to update
     */
    where?: UserImageSidebarWhereInput
    /**
     * Limit how many UserImageSidebars to update.
     */
    limit?: number
  }

  /**
   * UserImageSidebar updateManyAndReturn
   */
  export type UserImageSidebarUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageSidebar
     */
    select?: UserImageSidebarSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageSidebar
     */
    omit?: UserImageSidebarOmit<ExtArgs> | null
    /**
     * The data used to update UserImageSidebars.
     */
    data: XOR<UserImageSidebarUpdateManyMutationInput, UserImageSidebarUncheckedUpdateManyInput>
    /**
     * Filter which UserImageSidebars to update
     */
    where?: UserImageSidebarWhereInput
    /**
     * Limit how many UserImageSidebars to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageSidebarIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserImageSidebar upsert
   */
  export type UserImageSidebarUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageSidebar
     */
    select?: UserImageSidebarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageSidebar
     */
    omit?: UserImageSidebarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageSidebarInclude<ExtArgs> | null
    /**
     * The filter to search for the UserImageSidebar to update in case it exists.
     */
    where: UserImageSidebarWhereUniqueInput
    /**
     * In case the UserImageSidebar found by the `where` argument doesn't exist, create a new UserImageSidebar with this data.
     */
    create: XOR<UserImageSidebarCreateInput, UserImageSidebarUncheckedCreateInput>
    /**
     * In case the UserImageSidebar was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserImageSidebarUpdateInput, UserImageSidebarUncheckedUpdateInput>
  }

  /**
   * UserImageSidebar delete
   */
  export type UserImageSidebarDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageSidebar
     */
    select?: UserImageSidebarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageSidebar
     */
    omit?: UserImageSidebarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageSidebarInclude<ExtArgs> | null
    /**
     * Filter which UserImageSidebar to delete.
     */
    where: UserImageSidebarWhereUniqueInput
  }

  /**
   * UserImageSidebar deleteMany
   */
  export type UserImageSidebarDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserImageSidebars to delete
     */
    where?: UserImageSidebarWhereInput
    /**
     * Limit how many UserImageSidebars to delete.
     */
    limit?: number
  }

  /**
   * UserImageSidebar without action
   */
  export type UserImageSidebarDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserImageSidebar
     */
    select?: UserImageSidebarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserImageSidebar
     */
    omit?: UserImageSidebarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserImageSidebarInclude<ExtArgs> | null
  }


  /**
   * Model UserDisplaySettings
   */

  export type AggregateUserDisplaySettings = {
    _count: UserDisplaySettingsCountAggregateOutputType | null
    _min: UserDisplaySettingsMinAggregateOutputType | null
    _max: UserDisplaySettingsMaxAggregateOutputType | null
  }

  export type UserDisplaySettingsMinAggregateOutputType = {
    id: string | null
    displayYoutube: boolean | null
    displayDevice: boolean | null
    displayFaq: boolean | null
    displayPopup1: boolean | null
    displayPopupBell: boolean | null
    displayPopupEmail: boolean | null
    displayUserList: boolean | null
    displayOwnPage: boolean | null
    userId: string | null
  }

  export type UserDisplaySettingsMaxAggregateOutputType = {
    id: string | null
    displayYoutube: boolean | null
    displayDevice: boolean | null
    displayFaq: boolean | null
    displayPopup1: boolean | null
    displayPopupBell: boolean | null
    displayPopupEmail: boolean | null
    displayUserList: boolean | null
    displayOwnPage: boolean | null
    userId: string | null
  }

  export type UserDisplaySettingsCountAggregateOutputType = {
    id: number
    displayYoutube: number
    displayDevice: number
    displayFaq: number
    displayPopup1: number
    displayPopupBell: number
    displayPopupEmail: number
    displayUserList: number
    displayOwnPage: number
    userId: number
    _all: number
  }


  export type UserDisplaySettingsMinAggregateInputType = {
    id?: true
    displayYoutube?: true
    displayDevice?: true
    displayFaq?: true
    displayPopup1?: true
    displayPopupBell?: true
    displayPopupEmail?: true
    displayUserList?: true
    displayOwnPage?: true
    userId?: true
  }

  export type UserDisplaySettingsMaxAggregateInputType = {
    id?: true
    displayYoutube?: true
    displayDevice?: true
    displayFaq?: true
    displayPopup1?: true
    displayPopupBell?: true
    displayPopupEmail?: true
    displayUserList?: true
    displayOwnPage?: true
    userId?: true
  }

  export type UserDisplaySettingsCountAggregateInputType = {
    id?: true
    displayYoutube?: true
    displayDevice?: true
    displayFaq?: true
    displayPopup1?: true
    displayPopupBell?: true
    displayPopupEmail?: true
    displayUserList?: true
    displayOwnPage?: true
    userId?: true
    _all?: true
  }

  export type UserDisplaySettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserDisplaySettings to aggregate.
     */
    where?: UserDisplaySettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDisplaySettings to fetch.
     */
    orderBy?: UserDisplaySettingsOrderByWithRelationInput | UserDisplaySettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserDisplaySettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDisplaySettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDisplaySettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserDisplaySettings
    **/
    _count?: true | UserDisplaySettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserDisplaySettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserDisplaySettingsMaxAggregateInputType
  }

  export type GetUserDisplaySettingsAggregateType<T extends UserDisplaySettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserDisplaySettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserDisplaySettings[P]>
      : GetScalarType<T[P], AggregateUserDisplaySettings[P]>
  }




  export type UserDisplaySettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserDisplaySettingsWhereInput
    orderBy?: UserDisplaySettingsOrderByWithAggregationInput | UserDisplaySettingsOrderByWithAggregationInput[]
    by: UserDisplaySettingsScalarFieldEnum[] | UserDisplaySettingsScalarFieldEnum
    having?: UserDisplaySettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserDisplaySettingsCountAggregateInputType | true
    _min?: UserDisplaySettingsMinAggregateInputType
    _max?: UserDisplaySettingsMaxAggregateInputType
  }

  export type UserDisplaySettingsGroupByOutputType = {
    id: string
    displayYoutube: boolean
    displayDevice: boolean
    displayFaq: boolean
    displayPopup1: boolean
    displayPopupBell: boolean
    displayPopupEmail: boolean
    displayUserList: boolean
    displayOwnPage: boolean
    userId: string
    _count: UserDisplaySettingsCountAggregateOutputType | null
    _min: UserDisplaySettingsMinAggregateOutputType | null
    _max: UserDisplaySettingsMaxAggregateOutputType | null
  }

  type GetUserDisplaySettingsGroupByPayload<T extends UserDisplaySettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserDisplaySettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserDisplaySettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserDisplaySettingsGroupByOutputType[P]>
            : GetScalarType<T[P], UserDisplaySettingsGroupByOutputType[P]>
        }
      >
    >


  export type UserDisplaySettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    displayYoutube?: boolean
    displayDevice?: boolean
    displayFaq?: boolean
    displayPopup1?: boolean
    displayPopupBell?: boolean
    displayPopupEmail?: boolean
    displayUserList?: boolean
    displayOwnPage?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userDisplaySettings"]>

  export type UserDisplaySettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    displayYoutube?: boolean
    displayDevice?: boolean
    displayFaq?: boolean
    displayPopup1?: boolean
    displayPopupBell?: boolean
    displayPopupEmail?: boolean
    displayUserList?: boolean
    displayOwnPage?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userDisplaySettings"]>

  export type UserDisplaySettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    displayYoutube?: boolean
    displayDevice?: boolean
    displayFaq?: boolean
    displayPopup1?: boolean
    displayPopupBell?: boolean
    displayPopupEmail?: boolean
    displayUserList?: boolean
    displayOwnPage?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userDisplaySettings"]>

  export type UserDisplaySettingsSelectScalar = {
    id?: boolean
    displayYoutube?: boolean
    displayDevice?: boolean
    displayFaq?: boolean
    displayPopup1?: boolean
    displayPopupBell?: boolean
    displayPopupEmail?: boolean
    displayUserList?: boolean
    displayOwnPage?: boolean
    userId?: boolean
  }

  export type UserDisplaySettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "displayYoutube" | "displayDevice" | "displayFaq" | "displayPopup1" | "displayPopupBell" | "displayPopupEmail" | "displayUserList" | "displayOwnPage" | "userId", ExtArgs["result"]["userDisplaySettings"]>
  export type UserDisplaySettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserDisplaySettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserDisplaySettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserDisplaySettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserDisplaySettings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      displayYoutube: boolean
      displayDevice: boolean
      displayFaq: boolean
      displayPopup1: boolean
      displayPopupBell: boolean
      displayPopupEmail: boolean
      displayUserList: boolean
      displayOwnPage: boolean
      userId: string
    }, ExtArgs["result"]["userDisplaySettings"]>
    composites: {}
  }

  type UserDisplaySettingsGetPayload<S extends boolean | null | undefined | UserDisplaySettingsDefaultArgs> = $Result.GetResult<Prisma.$UserDisplaySettingsPayload, S>

  type UserDisplaySettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserDisplaySettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserDisplaySettingsCountAggregateInputType | true
    }

  export interface UserDisplaySettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserDisplaySettings'], meta: { name: 'UserDisplaySettings' } }
    /**
     * Find zero or one UserDisplaySettings that matches the filter.
     * @param {UserDisplaySettingsFindUniqueArgs} args - Arguments to find a UserDisplaySettings
     * @example
     * // Get one UserDisplaySettings
     * const userDisplaySettings = await prisma.userDisplaySettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserDisplaySettingsFindUniqueArgs>(args: SelectSubset<T, UserDisplaySettingsFindUniqueArgs<ExtArgs>>): Prisma__UserDisplaySettingsClient<$Result.GetResult<Prisma.$UserDisplaySettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserDisplaySettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserDisplaySettingsFindUniqueOrThrowArgs} args - Arguments to find a UserDisplaySettings
     * @example
     * // Get one UserDisplaySettings
     * const userDisplaySettings = await prisma.userDisplaySettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserDisplaySettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserDisplaySettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserDisplaySettingsClient<$Result.GetResult<Prisma.$UserDisplaySettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserDisplaySettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDisplaySettingsFindFirstArgs} args - Arguments to find a UserDisplaySettings
     * @example
     * // Get one UserDisplaySettings
     * const userDisplaySettings = await prisma.userDisplaySettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserDisplaySettingsFindFirstArgs>(args?: SelectSubset<T, UserDisplaySettingsFindFirstArgs<ExtArgs>>): Prisma__UserDisplaySettingsClient<$Result.GetResult<Prisma.$UserDisplaySettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserDisplaySettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDisplaySettingsFindFirstOrThrowArgs} args - Arguments to find a UserDisplaySettings
     * @example
     * // Get one UserDisplaySettings
     * const userDisplaySettings = await prisma.userDisplaySettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserDisplaySettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserDisplaySettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserDisplaySettingsClient<$Result.GetResult<Prisma.$UserDisplaySettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserDisplaySettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDisplaySettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserDisplaySettings
     * const userDisplaySettings = await prisma.userDisplaySettings.findMany()
     * 
     * // Get first 10 UserDisplaySettings
     * const userDisplaySettings = await prisma.userDisplaySettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userDisplaySettingsWithIdOnly = await prisma.userDisplaySettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserDisplaySettingsFindManyArgs>(args?: SelectSubset<T, UserDisplaySettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDisplaySettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserDisplaySettings.
     * @param {UserDisplaySettingsCreateArgs} args - Arguments to create a UserDisplaySettings.
     * @example
     * // Create one UserDisplaySettings
     * const UserDisplaySettings = await prisma.userDisplaySettings.create({
     *   data: {
     *     // ... data to create a UserDisplaySettings
     *   }
     * })
     * 
     */
    create<T extends UserDisplaySettingsCreateArgs>(args: SelectSubset<T, UserDisplaySettingsCreateArgs<ExtArgs>>): Prisma__UserDisplaySettingsClient<$Result.GetResult<Prisma.$UserDisplaySettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserDisplaySettings.
     * @param {UserDisplaySettingsCreateManyArgs} args - Arguments to create many UserDisplaySettings.
     * @example
     * // Create many UserDisplaySettings
     * const userDisplaySettings = await prisma.userDisplaySettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserDisplaySettingsCreateManyArgs>(args?: SelectSubset<T, UserDisplaySettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserDisplaySettings and returns the data saved in the database.
     * @param {UserDisplaySettingsCreateManyAndReturnArgs} args - Arguments to create many UserDisplaySettings.
     * @example
     * // Create many UserDisplaySettings
     * const userDisplaySettings = await prisma.userDisplaySettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserDisplaySettings and only return the `id`
     * const userDisplaySettingsWithIdOnly = await prisma.userDisplaySettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserDisplaySettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserDisplaySettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDisplaySettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserDisplaySettings.
     * @param {UserDisplaySettingsDeleteArgs} args - Arguments to delete one UserDisplaySettings.
     * @example
     * // Delete one UserDisplaySettings
     * const UserDisplaySettings = await prisma.userDisplaySettings.delete({
     *   where: {
     *     // ... filter to delete one UserDisplaySettings
     *   }
     * })
     * 
     */
    delete<T extends UserDisplaySettingsDeleteArgs>(args: SelectSubset<T, UserDisplaySettingsDeleteArgs<ExtArgs>>): Prisma__UserDisplaySettingsClient<$Result.GetResult<Prisma.$UserDisplaySettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserDisplaySettings.
     * @param {UserDisplaySettingsUpdateArgs} args - Arguments to update one UserDisplaySettings.
     * @example
     * // Update one UserDisplaySettings
     * const userDisplaySettings = await prisma.userDisplaySettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserDisplaySettingsUpdateArgs>(args: SelectSubset<T, UserDisplaySettingsUpdateArgs<ExtArgs>>): Prisma__UserDisplaySettingsClient<$Result.GetResult<Prisma.$UserDisplaySettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserDisplaySettings.
     * @param {UserDisplaySettingsDeleteManyArgs} args - Arguments to filter UserDisplaySettings to delete.
     * @example
     * // Delete a few UserDisplaySettings
     * const { count } = await prisma.userDisplaySettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDisplaySettingsDeleteManyArgs>(args?: SelectSubset<T, UserDisplaySettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserDisplaySettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDisplaySettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserDisplaySettings
     * const userDisplaySettings = await prisma.userDisplaySettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserDisplaySettingsUpdateManyArgs>(args: SelectSubset<T, UserDisplaySettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserDisplaySettings and returns the data updated in the database.
     * @param {UserDisplaySettingsUpdateManyAndReturnArgs} args - Arguments to update many UserDisplaySettings.
     * @example
     * // Update many UserDisplaySettings
     * const userDisplaySettings = await prisma.userDisplaySettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserDisplaySettings and only return the `id`
     * const userDisplaySettingsWithIdOnly = await prisma.userDisplaySettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserDisplaySettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, UserDisplaySettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDisplaySettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserDisplaySettings.
     * @param {UserDisplaySettingsUpsertArgs} args - Arguments to update or create a UserDisplaySettings.
     * @example
     * // Update or create a UserDisplaySettings
     * const userDisplaySettings = await prisma.userDisplaySettings.upsert({
     *   create: {
     *     // ... data to create a UserDisplaySettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserDisplaySettings we want to update
     *   }
     * })
     */
    upsert<T extends UserDisplaySettingsUpsertArgs>(args: SelectSubset<T, UserDisplaySettingsUpsertArgs<ExtArgs>>): Prisma__UserDisplaySettingsClient<$Result.GetResult<Prisma.$UserDisplaySettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserDisplaySettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDisplaySettingsCountArgs} args - Arguments to filter UserDisplaySettings to count.
     * @example
     * // Count the number of UserDisplaySettings
     * const count = await prisma.userDisplaySettings.count({
     *   where: {
     *     // ... the filter for the UserDisplaySettings we want to count
     *   }
     * })
    **/
    count<T extends UserDisplaySettingsCountArgs>(
      args?: Subset<T, UserDisplaySettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserDisplaySettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserDisplaySettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDisplaySettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserDisplaySettingsAggregateArgs>(args: Subset<T, UserDisplaySettingsAggregateArgs>): Prisma.PrismaPromise<GetUserDisplaySettingsAggregateType<T>>

    /**
     * Group by UserDisplaySettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDisplaySettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserDisplaySettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserDisplaySettingsGroupByArgs['orderBy'] }
        : { orderBy?: UserDisplaySettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserDisplaySettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserDisplaySettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserDisplaySettings model
   */
  readonly fields: UserDisplaySettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserDisplaySettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserDisplaySettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserDisplaySettings model
   */
  interface UserDisplaySettingsFieldRefs {
    readonly id: FieldRef<"UserDisplaySettings", 'String'>
    readonly displayYoutube: FieldRef<"UserDisplaySettings", 'Boolean'>
    readonly displayDevice: FieldRef<"UserDisplaySettings", 'Boolean'>
    readonly displayFaq: FieldRef<"UserDisplaySettings", 'Boolean'>
    readonly displayPopup1: FieldRef<"UserDisplaySettings", 'Boolean'>
    readonly displayPopupBell: FieldRef<"UserDisplaySettings", 'Boolean'>
    readonly displayPopupEmail: FieldRef<"UserDisplaySettings", 'Boolean'>
    readonly displayUserList: FieldRef<"UserDisplaySettings", 'Boolean'>
    readonly displayOwnPage: FieldRef<"UserDisplaySettings", 'Boolean'>
    readonly userId: FieldRef<"UserDisplaySettings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserDisplaySettings findUnique
   */
  export type UserDisplaySettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDisplaySettings
     */
    select?: UserDisplaySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDisplaySettings
     */
    omit?: UserDisplaySettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDisplaySettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserDisplaySettings to fetch.
     */
    where: UserDisplaySettingsWhereUniqueInput
  }

  /**
   * UserDisplaySettings findUniqueOrThrow
   */
  export type UserDisplaySettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDisplaySettings
     */
    select?: UserDisplaySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDisplaySettings
     */
    omit?: UserDisplaySettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDisplaySettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserDisplaySettings to fetch.
     */
    where: UserDisplaySettingsWhereUniqueInput
  }

  /**
   * UserDisplaySettings findFirst
   */
  export type UserDisplaySettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDisplaySettings
     */
    select?: UserDisplaySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDisplaySettings
     */
    omit?: UserDisplaySettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDisplaySettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserDisplaySettings to fetch.
     */
    where?: UserDisplaySettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDisplaySettings to fetch.
     */
    orderBy?: UserDisplaySettingsOrderByWithRelationInput | UserDisplaySettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserDisplaySettings.
     */
    cursor?: UserDisplaySettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDisplaySettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDisplaySettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserDisplaySettings.
     */
    distinct?: UserDisplaySettingsScalarFieldEnum | UserDisplaySettingsScalarFieldEnum[]
  }

  /**
   * UserDisplaySettings findFirstOrThrow
   */
  export type UserDisplaySettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDisplaySettings
     */
    select?: UserDisplaySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDisplaySettings
     */
    omit?: UserDisplaySettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDisplaySettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserDisplaySettings to fetch.
     */
    where?: UserDisplaySettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDisplaySettings to fetch.
     */
    orderBy?: UserDisplaySettingsOrderByWithRelationInput | UserDisplaySettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserDisplaySettings.
     */
    cursor?: UserDisplaySettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDisplaySettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDisplaySettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserDisplaySettings.
     */
    distinct?: UserDisplaySettingsScalarFieldEnum | UserDisplaySettingsScalarFieldEnum[]
  }

  /**
   * UserDisplaySettings findMany
   */
  export type UserDisplaySettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDisplaySettings
     */
    select?: UserDisplaySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDisplaySettings
     */
    omit?: UserDisplaySettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDisplaySettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserDisplaySettings to fetch.
     */
    where?: UserDisplaySettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDisplaySettings to fetch.
     */
    orderBy?: UserDisplaySettingsOrderByWithRelationInput | UserDisplaySettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserDisplaySettings.
     */
    cursor?: UserDisplaySettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDisplaySettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDisplaySettings.
     */
    skip?: number
    distinct?: UserDisplaySettingsScalarFieldEnum | UserDisplaySettingsScalarFieldEnum[]
  }

  /**
   * UserDisplaySettings create
   */
  export type UserDisplaySettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDisplaySettings
     */
    select?: UserDisplaySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDisplaySettings
     */
    omit?: UserDisplaySettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDisplaySettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserDisplaySettings.
     */
    data: XOR<UserDisplaySettingsCreateInput, UserDisplaySettingsUncheckedCreateInput>
  }

  /**
   * UserDisplaySettings createMany
   */
  export type UserDisplaySettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserDisplaySettings.
     */
    data: UserDisplaySettingsCreateManyInput | UserDisplaySettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserDisplaySettings createManyAndReturn
   */
  export type UserDisplaySettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDisplaySettings
     */
    select?: UserDisplaySettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserDisplaySettings
     */
    omit?: UserDisplaySettingsOmit<ExtArgs> | null
    /**
     * The data used to create many UserDisplaySettings.
     */
    data: UserDisplaySettingsCreateManyInput | UserDisplaySettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDisplaySettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserDisplaySettings update
   */
  export type UserDisplaySettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDisplaySettings
     */
    select?: UserDisplaySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDisplaySettings
     */
    omit?: UserDisplaySettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDisplaySettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserDisplaySettings.
     */
    data: XOR<UserDisplaySettingsUpdateInput, UserDisplaySettingsUncheckedUpdateInput>
    /**
     * Choose, which UserDisplaySettings to update.
     */
    where: UserDisplaySettingsWhereUniqueInput
  }

  /**
   * UserDisplaySettings updateMany
   */
  export type UserDisplaySettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserDisplaySettings.
     */
    data: XOR<UserDisplaySettingsUpdateManyMutationInput, UserDisplaySettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserDisplaySettings to update
     */
    where?: UserDisplaySettingsWhereInput
    /**
     * Limit how many UserDisplaySettings to update.
     */
    limit?: number
  }

  /**
   * UserDisplaySettings updateManyAndReturn
   */
  export type UserDisplaySettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDisplaySettings
     */
    select?: UserDisplaySettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserDisplaySettings
     */
    omit?: UserDisplaySettingsOmit<ExtArgs> | null
    /**
     * The data used to update UserDisplaySettings.
     */
    data: XOR<UserDisplaySettingsUpdateManyMutationInput, UserDisplaySettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserDisplaySettings to update
     */
    where?: UserDisplaySettingsWhereInput
    /**
     * Limit how many UserDisplaySettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDisplaySettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserDisplaySettings upsert
   */
  export type UserDisplaySettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDisplaySettings
     */
    select?: UserDisplaySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDisplaySettings
     */
    omit?: UserDisplaySettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDisplaySettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserDisplaySettings to update in case it exists.
     */
    where: UserDisplaySettingsWhereUniqueInput
    /**
     * In case the UserDisplaySettings found by the `where` argument doesn't exist, create a new UserDisplaySettings with this data.
     */
    create: XOR<UserDisplaySettingsCreateInput, UserDisplaySettingsUncheckedCreateInput>
    /**
     * In case the UserDisplaySettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserDisplaySettingsUpdateInput, UserDisplaySettingsUncheckedUpdateInput>
  }

  /**
   * UserDisplaySettings delete
   */
  export type UserDisplaySettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDisplaySettings
     */
    select?: UserDisplaySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDisplaySettings
     */
    omit?: UserDisplaySettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDisplaySettingsInclude<ExtArgs> | null
    /**
     * Filter which UserDisplaySettings to delete.
     */
    where: UserDisplaySettingsWhereUniqueInput
  }

  /**
   * UserDisplaySettings deleteMany
   */
  export type UserDisplaySettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserDisplaySettings to delete
     */
    where?: UserDisplaySettingsWhereInput
    /**
     * Limit how many UserDisplaySettings to delete.
     */
    limit?: number
  }

  /**
   * UserDisplaySettings without action
   */
  export type UserDisplaySettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDisplaySettings
     */
    select?: UserDisplaySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDisplaySettings
     */
    omit?: UserDisplaySettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDisplaySettingsInclude<ExtArgs> | null
  }


  /**
   * Model LinkService
   */

  export type AggregateLinkService = {
    _count: LinkServiceCountAggregateOutputType | null
    _avg: LinkServiceAvgAggregateOutputType | null
    _sum: LinkServiceSumAggregateOutputType | null
    _min: LinkServiceMinAggregateOutputType | null
    _max: LinkServiceMaxAggregateOutputType | null
  }

  export type LinkServiceAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type LinkServiceSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type LinkServiceMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    baseUrl: string | null
    allowOriginalIcon: boolean | null
    isActive: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LinkServiceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    baseUrl: string | null
    allowOriginalIcon: boolean | null
    isActive: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LinkServiceCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    baseUrl: number
    allowOriginalIcon: number
    isActive: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LinkServiceAvgAggregateInputType = {
    sortOrder?: true
  }

  export type LinkServiceSumAggregateInputType = {
    sortOrder?: true
  }

  export type LinkServiceMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    baseUrl?: true
    allowOriginalIcon?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LinkServiceMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    baseUrl?: true
    allowOriginalIcon?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LinkServiceCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    baseUrl?: true
    allowOriginalIcon?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LinkServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LinkService to aggregate.
     */
    where?: LinkServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkServices to fetch.
     */
    orderBy?: LinkServiceOrderByWithRelationInput | LinkServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LinkServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LinkServices
    **/
    _count?: true | LinkServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LinkServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LinkServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LinkServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LinkServiceMaxAggregateInputType
  }

  export type GetLinkServiceAggregateType<T extends LinkServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateLinkService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLinkService[P]>
      : GetScalarType<T[P], AggregateLinkService[P]>
  }




  export type LinkServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LinkServiceWhereInput
    orderBy?: LinkServiceOrderByWithAggregationInput | LinkServiceOrderByWithAggregationInput[]
    by: LinkServiceScalarFieldEnum[] | LinkServiceScalarFieldEnum
    having?: LinkServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LinkServiceCountAggregateInputType | true
    _avg?: LinkServiceAvgAggregateInputType
    _sum?: LinkServiceSumAggregateInputType
    _min?: LinkServiceMinAggregateInputType
    _max?: LinkServiceMaxAggregateInputType
  }

  export type LinkServiceGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    baseUrl: string | null
    allowOriginalIcon: boolean
    isActive: boolean
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: LinkServiceCountAggregateOutputType | null
    _avg: LinkServiceAvgAggregateOutputType | null
    _sum: LinkServiceSumAggregateOutputType | null
    _min: LinkServiceMinAggregateOutputType | null
    _max: LinkServiceMaxAggregateOutputType | null
  }

  type GetLinkServiceGroupByPayload<T extends LinkServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LinkServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LinkServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LinkServiceGroupByOutputType[P]>
            : GetScalarType<T[P], LinkServiceGroupByOutputType[P]>
        }
      >
    >


  export type LinkServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    baseUrl?: boolean
    allowOriginalIcon?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    icons?: boolean | LinkService$iconsArgs<ExtArgs>
    links?: boolean | LinkService$linksArgs<ExtArgs>
    _count?: boolean | LinkServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["linkService"]>

  export type LinkServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    baseUrl?: boolean
    allowOriginalIcon?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["linkService"]>

  export type LinkServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    baseUrl?: boolean
    allowOriginalIcon?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["linkService"]>

  export type LinkServiceSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    baseUrl?: boolean
    allowOriginalIcon?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LinkServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "baseUrl" | "allowOriginalIcon" | "isActive" | "sortOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["linkService"]>
  export type LinkServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    icons?: boolean | LinkService$iconsArgs<ExtArgs>
    links?: boolean | LinkService$linksArgs<ExtArgs>
    _count?: boolean | LinkServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LinkServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LinkServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LinkServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LinkService"
    objects: {
      icons: Prisma.$ServiceIconPayload<ExtArgs>[]
      links: Prisma.$UserLinkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      baseUrl: string | null
      allowOriginalIcon: boolean
      isActive: boolean
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["linkService"]>
    composites: {}
  }

  type LinkServiceGetPayload<S extends boolean | null | undefined | LinkServiceDefaultArgs> = $Result.GetResult<Prisma.$LinkServicePayload, S>

  type LinkServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LinkServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LinkServiceCountAggregateInputType | true
    }

  export interface LinkServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LinkService'], meta: { name: 'LinkService' } }
    /**
     * Find zero or one LinkService that matches the filter.
     * @param {LinkServiceFindUniqueArgs} args - Arguments to find a LinkService
     * @example
     * // Get one LinkService
     * const linkService = await prisma.linkService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LinkServiceFindUniqueArgs>(args: SelectSubset<T, LinkServiceFindUniqueArgs<ExtArgs>>): Prisma__LinkServiceClient<$Result.GetResult<Prisma.$LinkServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LinkService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LinkServiceFindUniqueOrThrowArgs} args - Arguments to find a LinkService
     * @example
     * // Get one LinkService
     * const linkService = await prisma.linkService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LinkServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, LinkServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LinkServiceClient<$Result.GetResult<Prisma.$LinkServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LinkService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkServiceFindFirstArgs} args - Arguments to find a LinkService
     * @example
     * // Get one LinkService
     * const linkService = await prisma.linkService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LinkServiceFindFirstArgs>(args?: SelectSubset<T, LinkServiceFindFirstArgs<ExtArgs>>): Prisma__LinkServiceClient<$Result.GetResult<Prisma.$LinkServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LinkService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkServiceFindFirstOrThrowArgs} args - Arguments to find a LinkService
     * @example
     * // Get one LinkService
     * const linkService = await prisma.linkService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LinkServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, LinkServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__LinkServiceClient<$Result.GetResult<Prisma.$LinkServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LinkServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LinkServices
     * const linkServices = await prisma.linkService.findMany()
     * 
     * // Get first 10 LinkServices
     * const linkServices = await prisma.linkService.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const linkServiceWithIdOnly = await prisma.linkService.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LinkServiceFindManyArgs>(args?: SelectSubset<T, LinkServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LinkService.
     * @param {LinkServiceCreateArgs} args - Arguments to create a LinkService.
     * @example
     * // Create one LinkService
     * const LinkService = await prisma.linkService.create({
     *   data: {
     *     // ... data to create a LinkService
     *   }
     * })
     * 
     */
    create<T extends LinkServiceCreateArgs>(args: SelectSubset<T, LinkServiceCreateArgs<ExtArgs>>): Prisma__LinkServiceClient<$Result.GetResult<Prisma.$LinkServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LinkServices.
     * @param {LinkServiceCreateManyArgs} args - Arguments to create many LinkServices.
     * @example
     * // Create many LinkServices
     * const linkService = await prisma.linkService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LinkServiceCreateManyArgs>(args?: SelectSubset<T, LinkServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LinkServices and returns the data saved in the database.
     * @param {LinkServiceCreateManyAndReturnArgs} args - Arguments to create many LinkServices.
     * @example
     * // Create many LinkServices
     * const linkService = await prisma.linkService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LinkServices and only return the `id`
     * const linkServiceWithIdOnly = await prisma.linkService.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LinkServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, LinkServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LinkService.
     * @param {LinkServiceDeleteArgs} args - Arguments to delete one LinkService.
     * @example
     * // Delete one LinkService
     * const LinkService = await prisma.linkService.delete({
     *   where: {
     *     // ... filter to delete one LinkService
     *   }
     * })
     * 
     */
    delete<T extends LinkServiceDeleteArgs>(args: SelectSubset<T, LinkServiceDeleteArgs<ExtArgs>>): Prisma__LinkServiceClient<$Result.GetResult<Prisma.$LinkServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LinkService.
     * @param {LinkServiceUpdateArgs} args - Arguments to update one LinkService.
     * @example
     * // Update one LinkService
     * const linkService = await prisma.linkService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LinkServiceUpdateArgs>(args: SelectSubset<T, LinkServiceUpdateArgs<ExtArgs>>): Prisma__LinkServiceClient<$Result.GetResult<Prisma.$LinkServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LinkServices.
     * @param {LinkServiceDeleteManyArgs} args - Arguments to filter LinkServices to delete.
     * @example
     * // Delete a few LinkServices
     * const { count } = await prisma.linkService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LinkServiceDeleteManyArgs>(args?: SelectSubset<T, LinkServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LinkServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LinkServices
     * const linkService = await prisma.linkService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LinkServiceUpdateManyArgs>(args: SelectSubset<T, LinkServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LinkServices and returns the data updated in the database.
     * @param {LinkServiceUpdateManyAndReturnArgs} args - Arguments to update many LinkServices.
     * @example
     * // Update many LinkServices
     * const linkService = await prisma.linkService.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LinkServices and only return the `id`
     * const linkServiceWithIdOnly = await prisma.linkService.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LinkServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, LinkServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LinkService.
     * @param {LinkServiceUpsertArgs} args - Arguments to update or create a LinkService.
     * @example
     * // Update or create a LinkService
     * const linkService = await prisma.linkService.upsert({
     *   create: {
     *     // ... data to create a LinkService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LinkService we want to update
     *   }
     * })
     */
    upsert<T extends LinkServiceUpsertArgs>(args: SelectSubset<T, LinkServiceUpsertArgs<ExtArgs>>): Prisma__LinkServiceClient<$Result.GetResult<Prisma.$LinkServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LinkServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkServiceCountArgs} args - Arguments to filter LinkServices to count.
     * @example
     * // Count the number of LinkServices
     * const count = await prisma.linkService.count({
     *   where: {
     *     // ... the filter for the LinkServices we want to count
     *   }
     * })
    **/
    count<T extends LinkServiceCountArgs>(
      args?: Subset<T, LinkServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LinkServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LinkService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LinkServiceAggregateArgs>(args: Subset<T, LinkServiceAggregateArgs>): Prisma.PrismaPromise<GetLinkServiceAggregateType<T>>

    /**
     * Group by LinkService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LinkServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LinkServiceGroupByArgs['orderBy'] }
        : { orderBy?: LinkServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LinkServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLinkServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LinkService model
   */
  readonly fields: LinkServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LinkService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LinkServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    icons<T extends LinkService$iconsArgs<ExtArgs> = {}>(args?: Subset<T, LinkService$iconsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceIconPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    links<T extends LinkService$linksArgs<ExtArgs> = {}>(args?: Subset<T, LinkService$linksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LinkService model
   */
  interface LinkServiceFieldRefs {
    readonly id: FieldRef<"LinkService", 'String'>
    readonly name: FieldRef<"LinkService", 'String'>
    readonly slug: FieldRef<"LinkService", 'String'>
    readonly description: FieldRef<"LinkService", 'String'>
    readonly baseUrl: FieldRef<"LinkService", 'String'>
    readonly allowOriginalIcon: FieldRef<"LinkService", 'Boolean'>
    readonly isActive: FieldRef<"LinkService", 'Boolean'>
    readonly sortOrder: FieldRef<"LinkService", 'Int'>
    readonly createdAt: FieldRef<"LinkService", 'DateTime'>
    readonly updatedAt: FieldRef<"LinkService", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LinkService findUnique
   */
  export type LinkServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkService
     */
    select?: LinkServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkService
     */
    omit?: LinkServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkServiceInclude<ExtArgs> | null
    /**
     * Filter, which LinkService to fetch.
     */
    where: LinkServiceWhereUniqueInput
  }

  /**
   * LinkService findUniqueOrThrow
   */
  export type LinkServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkService
     */
    select?: LinkServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkService
     */
    omit?: LinkServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkServiceInclude<ExtArgs> | null
    /**
     * Filter, which LinkService to fetch.
     */
    where: LinkServiceWhereUniqueInput
  }

  /**
   * LinkService findFirst
   */
  export type LinkServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkService
     */
    select?: LinkServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkService
     */
    omit?: LinkServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkServiceInclude<ExtArgs> | null
    /**
     * Filter, which LinkService to fetch.
     */
    where?: LinkServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkServices to fetch.
     */
    orderBy?: LinkServiceOrderByWithRelationInput | LinkServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LinkServices.
     */
    cursor?: LinkServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LinkServices.
     */
    distinct?: LinkServiceScalarFieldEnum | LinkServiceScalarFieldEnum[]
  }

  /**
   * LinkService findFirstOrThrow
   */
  export type LinkServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkService
     */
    select?: LinkServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkService
     */
    omit?: LinkServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkServiceInclude<ExtArgs> | null
    /**
     * Filter, which LinkService to fetch.
     */
    where?: LinkServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkServices to fetch.
     */
    orderBy?: LinkServiceOrderByWithRelationInput | LinkServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LinkServices.
     */
    cursor?: LinkServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LinkServices.
     */
    distinct?: LinkServiceScalarFieldEnum | LinkServiceScalarFieldEnum[]
  }

  /**
   * LinkService findMany
   */
  export type LinkServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkService
     */
    select?: LinkServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkService
     */
    omit?: LinkServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkServiceInclude<ExtArgs> | null
    /**
     * Filter, which LinkServices to fetch.
     */
    where?: LinkServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkServices to fetch.
     */
    orderBy?: LinkServiceOrderByWithRelationInput | LinkServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LinkServices.
     */
    cursor?: LinkServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkServices.
     */
    skip?: number
    distinct?: LinkServiceScalarFieldEnum | LinkServiceScalarFieldEnum[]
  }

  /**
   * LinkService create
   */
  export type LinkServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkService
     */
    select?: LinkServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkService
     */
    omit?: LinkServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a LinkService.
     */
    data: XOR<LinkServiceCreateInput, LinkServiceUncheckedCreateInput>
  }

  /**
   * LinkService createMany
   */
  export type LinkServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LinkServices.
     */
    data: LinkServiceCreateManyInput | LinkServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LinkService createManyAndReturn
   */
  export type LinkServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkService
     */
    select?: LinkServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LinkService
     */
    omit?: LinkServiceOmit<ExtArgs> | null
    /**
     * The data used to create many LinkServices.
     */
    data: LinkServiceCreateManyInput | LinkServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LinkService update
   */
  export type LinkServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkService
     */
    select?: LinkServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkService
     */
    omit?: LinkServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a LinkService.
     */
    data: XOR<LinkServiceUpdateInput, LinkServiceUncheckedUpdateInput>
    /**
     * Choose, which LinkService to update.
     */
    where: LinkServiceWhereUniqueInput
  }

  /**
   * LinkService updateMany
   */
  export type LinkServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LinkServices.
     */
    data: XOR<LinkServiceUpdateManyMutationInput, LinkServiceUncheckedUpdateManyInput>
    /**
     * Filter which LinkServices to update
     */
    where?: LinkServiceWhereInput
    /**
     * Limit how many LinkServices to update.
     */
    limit?: number
  }

  /**
   * LinkService updateManyAndReturn
   */
  export type LinkServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkService
     */
    select?: LinkServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LinkService
     */
    omit?: LinkServiceOmit<ExtArgs> | null
    /**
     * The data used to update LinkServices.
     */
    data: XOR<LinkServiceUpdateManyMutationInput, LinkServiceUncheckedUpdateManyInput>
    /**
     * Filter which LinkServices to update
     */
    where?: LinkServiceWhereInput
    /**
     * Limit how many LinkServices to update.
     */
    limit?: number
  }

  /**
   * LinkService upsert
   */
  export type LinkServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkService
     */
    select?: LinkServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkService
     */
    omit?: LinkServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the LinkService to update in case it exists.
     */
    where: LinkServiceWhereUniqueInput
    /**
     * In case the LinkService found by the `where` argument doesn't exist, create a new LinkService with this data.
     */
    create: XOR<LinkServiceCreateInput, LinkServiceUncheckedCreateInput>
    /**
     * In case the LinkService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LinkServiceUpdateInput, LinkServiceUncheckedUpdateInput>
  }

  /**
   * LinkService delete
   */
  export type LinkServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkService
     */
    select?: LinkServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkService
     */
    omit?: LinkServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkServiceInclude<ExtArgs> | null
    /**
     * Filter which LinkService to delete.
     */
    where: LinkServiceWhereUniqueInput
  }

  /**
   * LinkService deleteMany
   */
  export type LinkServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LinkServices to delete
     */
    where?: LinkServiceWhereInput
    /**
     * Limit how many LinkServices to delete.
     */
    limit?: number
  }

  /**
   * LinkService.icons
   */
  export type LinkService$iconsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceIcon
     */
    select?: ServiceIconSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceIcon
     */
    omit?: ServiceIconOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIconInclude<ExtArgs> | null
    where?: ServiceIconWhereInput
    orderBy?: ServiceIconOrderByWithRelationInput | ServiceIconOrderByWithRelationInput[]
    cursor?: ServiceIconWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceIconScalarFieldEnum | ServiceIconScalarFieldEnum[]
  }

  /**
   * LinkService.links
   */
  export type LinkService$linksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLink
     */
    select?: UserLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLink
     */
    omit?: UserLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLinkInclude<ExtArgs> | null
    where?: UserLinkWhereInput
    orderBy?: UserLinkOrderByWithRelationInput | UserLinkOrderByWithRelationInput[]
    cursor?: UserLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLinkScalarFieldEnum | UserLinkScalarFieldEnum[]
  }

  /**
   * LinkService without action
   */
  export type LinkServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkService
     */
    select?: LinkServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkService
     */
    omit?: LinkServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkServiceInclude<ExtArgs> | null
  }


  /**
   * Model ServiceIcon
   */

  export type AggregateServiceIcon = {
    _count: ServiceIconCountAggregateOutputType | null
    _avg: ServiceIconAvgAggregateOutputType | null
    _sum: ServiceIconSumAggregateOutputType | null
    _min: ServiceIconMinAggregateOutputType | null
    _max: ServiceIconMaxAggregateOutputType | null
  }

  export type ServiceIconAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type ServiceIconSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type ServiceIconMinAggregateOutputType = {
    id: string | null
    name: string | null
    fileName: string | null
    filePath: string | null
    style: $Enums.IconStyle | null
    colorScheme: $Enums.IconColor | null
    description: string | null
    isActive: boolean | null
    sortOrder: number | null
    uploadedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    serviceId: string | null
  }

  export type ServiceIconMaxAggregateOutputType = {
    id: string | null
    name: string | null
    fileName: string | null
    filePath: string | null
    style: $Enums.IconStyle | null
    colorScheme: $Enums.IconColor | null
    description: string | null
    isActive: boolean | null
    sortOrder: number | null
    uploadedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    serviceId: string | null
  }

  export type ServiceIconCountAggregateOutputType = {
    id: number
    name: number
    fileName: number
    filePath: number
    style: number
    colorScheme: number
    description: number
    isActive: number
    sortOrder: number
    uploadedBy: number
    createdAt: number
    updatedAt: number
    serviceId: number
    _all: number
  }


  export type ServiceIconAvgAggregateInputType = {
    sortOrder?: true
  }

  export type ServiceIconSumAggregateInputType = {
    sortOrder?: true
  }

  export type ServiceIconMinAggregateInputType = {
    id?: true
    name?: true
    fileName?: true
    filePath?: true
    style?: true
    colorScheme?: true
    description?: true
    isActive?: true
    sortOrder?: true
    uploadedBy?: true
    createdAt?: true
    updatedAt?: true
    serviceId?: true
  }

  export type ServiceIconMaxAggregateInputType = {
    id?: true
    name?: true
    fileName?: true
    filePath?: true
    style?: true
    colorScheme?: true
    description?: true
    isActive?: true
    sortOrder?: true
    uploadedBy?: true
    createdAt?: true
    updatedAt?: true
    serviceId?: true
  }

  export type ServiceIconCountAggregateInputType = {
    id?: true
    name?: true
    fileName?: true
    filePath?: true
    style?: true
    colorScheme?: true
    description?: true
    isActive?: true
    sortOrder?: true
    uploadedBy?: true
    createdAt?: true
    updatedAt?: true
    serviceId?: true
    _all?: true
  }

  export type ServiceIconAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceIcon to aggregate.
     */
    where?: ServiceIconWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceIcons to fetch.
     */
    orderBy?: ServiceIconOrderByWithRelationInput | ServiceIconOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceIconWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceIcons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceIcons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceIcons
    **/
    _count?: true | ServiceIconCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceIconAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceIconSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceIconMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceIconMaxAggregateInputType
  }

  export type GetServiceIconAggregateType<T extends ServiceIconAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceIcon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceIcon[P]>
      : GetScalarType<T[P], AggregateServiceIcon[P]>
  }




  export type ServiceIconGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceIconWhereInput
    orderBy?: ServiceIconOrderByWithAggregationInput | ServiceIconOrderByWithAggregationInput[]
    by: ServiceIconScalarFieldEnum[] | ServiceIconScalarFieldEnum
    having?: ServiceIconScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceIconCountAggregateInputType | true
    _avg?: ServiceIconAvgAggregateInputType
    _sum?: ServiceIconSumAggregateInputType
    _min?: ServiceIconMinAggregateInputType
    _max?: ServiceIconMaxAggregateInputType
  }

  export type ServiceIconGroupByOutputType = {
    id: string
    name: string
    fileName: string
    filePath: string
    style: $Enums.IconStyle
    colorScheme: $Enums.IconColor
    description: string | null
    isActive: boolean
    sortOrder: number
    uploadedBy: string | null
    createdAt: Date
    updatedAt: Date
    serviceId: string
    _count: ServiceIconCountAggregateOutputType | null
    _avg: ServiceIconAvgAggregateOutputType | null
    _sum: ServiceIconSumAggregateOutputType | null
    _min: ServiceIconMinAggregateOutputType | null
    _max: ServiceIconMaxAggregateOutputType | null
  }

  type GetServiceIconGroupByPayload<T extends ServiceIconGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceIconGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceIconGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceIconGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceIconGroupByOutputType[P]>
        }
      >
    >


  export type ServiceIconSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    fileName?: boolean
    filePath?: boolean
    style?: boolean
    colorScheme?: boolean
    description?: boolean
    isActive?: boolean
    sortOrder?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceId?: boolean
    service?: boolean | LinkServiceDefaultArgs<ExtArgs>
    links?: boolean | ServiceIcon$linksArgs<ExtArgs>
    _count?: boolean | ServiceIconCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceIcon"]>

  export type ServiceIconSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    fileName?: boolean
    filePath?: boolean
    style?: boolean
    colorScheme?: boolean
    description?: boolean
    isActive?: boolean
    sortOrder?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceId?: boolean
    service?: boolean | LinkServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceIcon"]>

  export type ServiceIconSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    fileName?: boolean
    filePath?: boolean
    style?: boolean
    colorScheme?: boolean
    description?: boolean
    isActive?: boolean
    sortOrder?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceId?: boolean
    service?: boolean | LinkServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceIcon"]>

  export type ServiceIconSelectScalar = {
    id?: boolean
    name?: boolean
    fileName?: boolean
    filePath?: boolean
    style?: boolean
    colorScheme?: boolean
    description?: boolean
    isActive?: boolean
    sortOrder?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    serviceId?: boolean
  }

  export type ServiceIconOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "fileName" | "filePath" | "style" | "colorScheme" | "description" | "isActive" | "sortOrder" | "uploadedBy" | "createdAt" | "updatedAt" | "serviceId", ExtArgs["result"]["serviceIcon"]>
  export type ServiceIconInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | LinkServiceDefaultArgs<ExtArgs>
    links?: boolean | ServiceIcon$linksArgs<ExtArgs>
    _count?: boolean | ServiceIconCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIconIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | LinkServiceDefaultArgs<ExtArgs>
  }
  export type ServiceIconIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | LinkServiceDefaultArgs<ExtArgs>
  }

  export type $ServiceIconPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceIcon"
    objects: {
      service: Prisma.$LinkServicePayload<ExtArgs>
      links: Prisma.$UserLinkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      fileName: string
      filePath: string
      style: $Enums.IconStyle
      colorScheme: $Enums.IconColor
      description: string | null
      isActive: boolean
      sortOrder: number
      uploadedBy: string | null
      createdAt: Date
      updatedAt: Date
      serviceId: string
    }, ExtArgs["result"]["serviceIcon"]>
    composites: {}
  }

  type ServiceIconGetPayload<S extends boolean | null | undefined | ServiceIconDefaultArgs> = $Result.GetResult<Prisma.$ServiceIconPayload, S>

  type ServiceIconCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceIconFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceIconCountAggregateInputType | true
    }

  export interface ServiceIconDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceIcon'], meta: { name: 'ServiceIcon' } }
    /**
     * Find zero or one ServiceIcon that matches the filter.
     * @param {ServiceIconFindUniqueArgs} args - Arguments to find a ServiceIcon
     * @example
     * // Get one ServiceIcon
     * const serviceIcon = await prisma.serviceIcon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceIconFindUniqueArgs>(args: SelectSubset<T, ServiceIconFindUniqueArgs<ExtArgs>>): Prisma__ServiceIconClient<$Result.GetResult<Prisma.$ServiceIconPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceIcon that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceIconFindUniqueOrThrowArgs} args - Arguments to find a ServiceIcon
     * @example
     * // Get one ServiceIcon
     * const serviceIcon = await prisma.serviceIcon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceIconFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceIconFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceIconClient<$Result.GetResult<Prisma.$ServiceIconPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceIcon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceIconFindFirstArgs} args - Arguments to find a ServiceIcon
     * @example
     * // Get one ServiceIcon
     * const serviceIcon = await prisma.serviceIcon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceIconFindFirstArgs>(args?: SelectSubset<T, ServiceIconFindFirstArgs<ExtArgs>>): Prisma__ServiceIconClient<$Result.GetResult<Prisma.$ServiceIconPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceIcon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceIconFindFirstOrThrowArgs} args - Arguments to find a ServiceIcon
     * @example
     * // Get one ServiceIcon
     * const serviceIcon = await prisma.serviceIcon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceIconFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceIconFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceIconClient<$Result.GetResult<Prisma.$ServiceIconPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceIcons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceIconFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceIcons
     * const serviceIcons = await prisma.serviceIcon.findMany()
     * 
     * // Get first 10 ServiceIcons
     * const serviceIcons = await prisma.serviceIcon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceIconWithIdOnly = await prisma.serviceIcon.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceIconFindManyArgs>(args?: SelectSubset<T, ServiceIconFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceIconPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceIcon.
     * @param {ServiceIconCreateArgs} args - Arguments to create a ServiceIcon.
     * @example
     * // Create one ServiceIcon
     * const ServiceIcon = await prisma.serviceIcon.create({
     *   data: {
     *     // ... data to create a ServiceIcon
     *   }
     * })
     * 
     */
    create<T extends ServiceIconCreateArgs>(args: SelectSubset<T, ServiceIconCreateArgs<ExtArgs>>): Prisma__ServiceIconClient<$Result.GetResult<Prisma.$ServiceIconPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceIcons.
     * @param {ServiceIconCreateManyArgs} args - Arguments to create many ServiceIcons.
     * @example
     * // Create many ServiceIcons
     * const serviceIcon = await prisma.serviceIcon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceIconCreateManyArgs>(args?: SelectSubset<T, ServiceIconCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceIcons and returns the data saved in the database.
     * @param {ServiceIconCreateManyAndReturnArgs} args - Arguments to create many ServiceIcons.
     * @example
     * // Create many ServiceIcons
     * const serviceIcon = await prisma.serviceIcon.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceIcons and only return the `id`
     * const serviceIconWithIdOnly = await prisma.serviceIcon.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceIconCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceIconCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceIconPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceIcon.
     * @param {ServiceIconDeleteArgs} args - Arguments to delete one ServiceIcon.
     * @example
     * // Delete one ServiceIcon
     * const ServiceIcon = await prisma.serviceIcon.delete({
     *   where: {
     *     // ... filter to delete one ServiceIcon
     *   }
     * })
     * 
     */
    delete<T extends ServiceIconDeleteArgs>(args: SelectSubset<T, ServiceIconDeleteArgs<ExtArgs>>): Prisma__ServiceIconClient<$Result.GetResult<Prisma.$ServiceIconPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceIcon.
     * @param {ServiceIconUpdateArgs} args - Arguments to update one ServiceIcon.
     * @example
     * // Update one ServiceIcon
     * const serviceIcon = await prisma.serviceIcon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceIconUpdateArgs>(args: SelectSubset<T, ServiceIconUpdateArgs<ExtArgs>>): Prisma__ServiceIconClient<$Result.GetResult<Prisma.$ServiceIconPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceIcons.
     * @param {ServiceIconDeleteManyArgs} args - Arguments to filter ServiceIcons to delete.
     * @example
     * // Delete a few ServiceIcons
     * const { count } = await prisma.serviceIcon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceIconDeleteManyArgs>(args?: SelectSubset<T, ServiceIconDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceIcons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceIconUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceIcons
     * const serviceIcon = await prisma.serviceIcon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceIconUpdateManyArgs>(args: SelectSubset<T, ServiceIconUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceIcons and returns the data updated in the database.
     * @param {ServiceIconUpdateManyAndReturnArgs} args - Arguments to update many ServiceIcons.
     * @example
     * // Update many ServiceIcons
     * const serviceIcon = await prisma.serviceIcon.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceIcons and only return the `id`
     * const serviceIconWithIdOnly = await prisma.serviceIcon.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceIconUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceIconUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceIconPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceIcon.
     * @param {ServiceIconUpsertArgs} args - Arguments to update or create a ServiceIcon.
     * @example
     * // Update or create a ServiceIcon
     * const serviceIcon = await prisma.serviceIcon.upsert({
     *   create: {
     *     // ... data to create a ServiceIcon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceIcon we want to update
     *   }
     * })
     */
    upsert<T extends ServiceIconUpsertArgs>(args: SelectSubset<T, ServiceIconUpsertArgs<ExtArgs>>): Prisma__ServiceIconClient<$Result.GetResult<Prisma.$ServiceIconPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceIcons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceIconCountArgs} args - Arguments to filter ServiceIcons to count.
     * @example
     * // Count the number of ServiceIcons
     * const count = await prisma.serviceIcon.count({
     *   where: {
     *     // ... the filter for the ServiceIcons we want to count
     *   }
     * })
    **/
    count<T extends ServiceIconCountArgs>(
      args?: Subset<T, ServiceIconCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceIconCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceIcon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceIconAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceIconAggregateArgs>(args: Subset<T, ServiceIconAggregateArgs>): Prisma.PrismaPromise<GetServiceIconAggregateType<T>>

    /**
     * Group by ServiceIcon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceIconGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceIconGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceIconGroupByArgs['orderBy'] }
        : { orderBy?: ServiceIconGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceIconGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceIconGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceIcon model
   */
  readonly fields: ServiceIconFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceIcon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceIconClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends LinkServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LinkServiceDefaultArgs<ExtArgs>>): Prisma__LinkServiceClient<$Result.GetResult<Prisma.$LinkServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    links<T extends ServiceIcon$linksArgs<ExtArgs> = {}>(args?: Subset<T, ServiceIcon$linksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceIcon model
   */
  interface ServiceIconFieldRefs {
    readonly id: FieldRef<"ServiceIcon", 'String'>
    readonly name: FieldRef<"ServiceIcon", 'String'>
    readonly fileName: FieldRef<"ServiceIcon", 'String'>
    readonly filePath: FieldRef<"ServiceIcon", 'String'>
    readonly style: FieldRef<"ServiceIcon", 'IconStyle'>
    readonly colorScheme: FieldRef<"ServiceIcon", 'IconColor'>
    readonly description: FieldRef<"ServiceIcon", 'String'>
    readonly isActive: FieldRef<"ServiceIcon", 'Boolean'>
    readonly sortOrder: FieldRef<"ServiceIcon", 'Int'>
    readonly uploadedBy: FieldRef<"ServiceIcon", 'String'>
    readonly createdAt: FieldRef<"ServiceIcon", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceIcon", 'DateTime'>
    readonly serviceId: FieldRef<"ServiceIcon", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ServiceIcon findUnique
   */
  export type ServiceIconFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceIcon
     */
    select?: ServiceIconSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceIcon
     */
    omit?: ServiceIconOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIconInclude<ExtArgs> | null
    /**
     * Filter, which ServiceIcon to fetch.
     */
    where: ServiceIconWhereUniqueInput
  }

  /**
   * ServiceIcon findUniqueOrThrow
   */
  export type ServiceIconFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceIcon
     */
    select?: ServiceIconSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceIcon
     */
    omit?: ServiceIconOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIconInclude<ExtArgs> | null
    /**
     * Filter, which ServiceIcon to fetch.
     */
    where: ServiceIconWhereUniqueInput
  }

  /**
   * ServiceIcon findFirst
   */
  export type ServiceIconFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceIcon
     */
    select?: ServiceIconSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceIcon
     */
    omit?: ServiceIconOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIconInclude<ExtArgs> | null
    /**
     * Filter, which ServiceIcon to fetch.
     */
    where?: ServiceIconWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceIcons to fetch.
     */
    orderBy?: ServiceIconOrderByWithRelationInput | ServiceIconOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceIcons.
     */
    cursor?: ServiceIconWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceIcons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceIcons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceIcons.
     */
    distinct?: ServiceIconScalarFieldEnum | ServiceIconScalarFieldEnum[]
  }

  /**
   * ServiceIcon findFirstOrThrow
   */
  export type ServiceIconFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceIcon
     */
    select?: ServiceIconSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceIcon
     */
    omit?: ServiceIconOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIconInclude<ExtArgs> | null
    /**
     * Filter, which ServiceIcon to fetch.
     */
    where?: ServiceIconWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceIcons to fetch.
     */
    orderBy?: ServiceIconOrderByWithRelationInput | ServiceIconOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceIcons.
     */
    cursor?: ServiceIconWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceIcons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceIcons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceIcons.
     */
    distinct?: ServiceIconScalarFieldEnum | ServiceIconScalarFieldEnum[]
  }

  /**
   * ServiceIcon findMany
   */
  export type ServiceIconFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceIcon
     */
    select?: ServiceIconSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceIcon
     */
    omit?: ServiceIconOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIconInclude<ExtArgs> | null
    /**
     * Filter, which ServiceIcons to fetch.
     */
    where?: ServiceIconWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceIcons to fetch.
     */
    orderBy?: ServiceIconOrderByWithRelationInput | ServiceIconOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceIcons.
     */
    cursor?: ServiceIconWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceIcons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceIcons.
     */
    skip?: number
    distinct?: ServiceIconScalarFieldEnum | ServiceIconScalarFieldEnum[]
  }

  /**
   * ServiceIcon create
   */
  export type ServiceIconCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceIcon
     */
    select?: ServiceIconSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceIcon
     */
    omit?: ServiceIconOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIconInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceIcon.
     */
    data: XOR<ServiceIconCreateInput, ServiceIconUncheckedCreateInput>
  }

  /**
   * ServiceIcon createMany
   */
  export type ServiceIconCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceIcons.
     */
    data: ServiceIconCreateManyInput | ServiceIconCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceIcon createManyAndReturn
   */
  export type ServiceIconCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceIcon
     */
    select?: ServiceIconSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceIcon
     */
    omit?: ServiceIconOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceIcons.
     */
    data: ServiceIconCreateManyInput | ServiceIconCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIconIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceIcon update
   */
  export type ServiceIconUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceIcon
     */
    select?: ServiceIconSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceIcon
     */
    omit?: ServiceIconOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIconInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceIcon.
     */
    data: XOR<ServiceIconUpdateInput, ServiceIconUncheckedUpdateInput>
    /**
     * Choose, which ServiceIcon to update.
     */
    where: ServiceIconWhereUniqueInput
  }

  /**
   * ServiceIcon updateMany
   */
  export type ServiceIconUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceIcons.
     */
    data: XOR<ServiceIconUpdateManyMutationInput, ServiceIconUncheckedUpdateManyInput>
    /**
     * Filter which ServiceIcons to update
     */
    where?: ServiceIconWhereInput
    /**
     * Limit how many ServiceIcons to update.
     */
    limit?: number
  }

  /**
   * ServiceIcon updateManyAndReturn
   */
  export type ServiceIconUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceIcon
     */
    select?: ServiceIconSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceIcon
     */
    omit?: ServiceIconOmit<ExtArgs> | null
    /**
     * The data used to update ServiceIcons.
     */
    data: XOR<ServiceIconUpdateManyMutationInput, ServiceIconUncheckedUpdateManyInput>
    /**
     * Filter which ServiceIcons to update
     */
    where?: ServiceIconWhereInput
    /**
     * Limit how many ServiceIcons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIconIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceIcon upsert
   */
  export type ServiceIconUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceIcon
     */
    select?: ServiceIconSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceIcon
     */
    omit?: ServiceIconOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIconInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceIcon to update in case it exists.
     */
    where: ServiceIconWhereUniqueInput
    /**
     * In case the ServiceIcon found by the `where` argument doesn't exist, create a new ServiceIcon with this data.
     */
    create: XOR<ServiceIconCreateInput, ServiceIconUncheckedCreateInput>
    /**
     * In case the ServiceIcon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceIconUpdateInput, ServiceIconUncheckedUpdateInput>
  }

  /**
   * ServiceIcon delete
   */
  export type ServiceIconDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceIcon
     */
    select?: ServiceIconSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceIcon
     */
    omit?: ServiceIconOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIconInclude<ExtArgs> | null
    /**
     * Filter which ServiceIcon to delete.
     */
    where: ServiceIconWhereUniqueInput
  }

  /**
   * ServiceIcon deleteMany
   */
  export type ServiceIconDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceIcons to delete
     */
    where?: ServiceIconWhereInput
    /**
     * Limit how many ServiceIcons to delete.
     */
    limit?: number
  }

  /**
   * ServiceIcon.links
   */
  export type ServiceIcon$linksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLink
     */
    select?: UserLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserLink
     */
    omit?: UserLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserLinkInclude<ExtArgs> | null
    where?: UserLinkWhereInput
    orderBy?: UserLinkOrderByWithRelationInput | UserLinkOrderByWithRelationInput[]
    cursor?: UserLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserLinkScalarFieldEnum | UserLinkScalarFieldEnum[]
  }

  /**
   * ServiceIcon without action
   */
  export type ServiceIconDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceIcon
     */
    select?: ServiceIconSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceIcon
     */
    omit?: ServiceIconOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIconInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model Author
   */

  export type AggregateAuthor = {
    _count: AuthorCountAggregateOutputType | null
    _min: AuthorMinAggregateOutputType | null
    _max: AuthorMaxAggregateOutputType | null
  }

  export type AuthorMinAggregateOutputType = {
    id: string | null
    bio: string | null
    profileImage: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type AuthorMaxAggregateOutputType = {
    id: string | null
    bio: string | null
    profileImage: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type AuthorCountAggregateOutputType = {
    id: number
    bio: number
    profileImage: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type AuthorMinAggregateInputType = {
    id?: true
    bio?: true
    profileImage?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type AuthorMaxAggregateInputType = {
    id?: true
    bio?: true
    profileImage?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type AuthorCountAggregateInputType = {
    id?: true
    bio?: true
    profileImage?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type AuthorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Author to aggregate.
     */
    where?: AuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authors to fetch.
     */
    orderBy?: AuthorOrderByWithRelationInput | AuthorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Authors
    **/
    _count?: true | AuthorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthorMaxAggregateInputType
  }

  export type GetAuthorAggregateType<T extends AuthorAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthor[P]>
      : GetScalarType<T[P], AggregateAuthor[P]>
  }




  export type AuthorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthorWhereInput
    orderBy?: AuthorOrderByWithAggregationInput | AuthorOrderByWithAggregationInput[]
    by: AuthorScalarFieldEnum[] | AuthorScalarFieldEnum
    having?: AuthorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthorCountAggregateInputType | true
    _min?: AuthorMinAggregateInputType
    _max?: AuthorMaxAggregateInputType
  }

  export type AuthorGroupByOutputType = {
    id: string
    bio: string | null
    profileImage: string | null
    createdAt: Date
    updatedAt: Date
    userId: string
    _count: AuthorCountAggregateOutputType | null
    _min: AuthorMinAggregateOutputType | null
    _max: AuthorMaxAggregateOutputType | null
  }

  type GetAuthorGroupByPayload<T extends AuthorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuthorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthorGroupByOutputType[P]>
            : GetScalarType<T[P], AuthorGroupByOutputType[P]>
        }
      >
    >


  export type AuthorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bio?: boolean
    profileImage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    articles?: boolean | Author$articlesArgs<ExtArgs>
    _count?: boolean | AuthorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["author"]>

  export type AuthorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bio?: boolean
    profileImage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["author"]>

  export type AuthorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bio?: boolean
    profileImage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["author"]>

  export type AuthorSelectScalar = {
    id?: boolean
    bio?: boolean
    profileImage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type AuthorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bio" | "profileImage" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["author"]>
  export type AuthorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    articles?: boolean | Author$articlesArgs<ExtArgs>
    _count?: boolean | AuthorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AuthorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuthorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuthorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Author"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      articles: Prisma.$ArticlePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bio: string | null
      profileImage: string | null
      createdAt: Date
      updatedAt: Date
      userId: string
    }, ExtArgs["result"]["author"]>
    composites: {}
  }

  type AuthorGetPayload<S extends boolean | null | undefined | AuthorDefaultArgs> = $Result.GetResult<Prisma.$AuthorPayload, S>

  type AuthorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuthorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuthorCountAggregateInputType | true
    }

  export interface AuthorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Author'], meta: { name: 'Author' } }
    /**
     * Find zero or one Author that matches the filter.
     * @param {AuthorFindUniqueArgs} args - Arguments to find a Author
     * @example
     * // Get one Author
     * const author = await prisma.author.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuthorFindUniqueArgs>(args: SelectSubset<T, AuthorFindUniqueArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Author that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuthorFindUniqueOrThrowArgs} args - Arguments to find a Author
     * @example
     * // Get one Author
     * const author = await prisma.author.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuthorFindUniqueOrThrowArgs>(args: SelectSubset<T, AuthorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Author that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorFindFirstArgs} args - Arguments to find a Author
     * @example
     * // Get one Author
     * const author = await prisma.author.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuthorFindFirstArgs>(args?: SelectSubset<T, AuthorFindFirstArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Author that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorFindFirstOrThrowArgs} args - Arguments to find a Author
     * @example
     * // Get one Author
     * const author = await prisma.author.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuthorFindFirstOrThrowArgs>(args?: SelectSubset<T, AuthorFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Authors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Authors
     * const authors = await prisma.author.findMany()
     * 
     * // Get first 10 Authors
     * const authors = await prisma.author.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const authorWithIdOnly = await prisma.author.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuthorFindManyArgs>(args?: SelectSubset<T, AuthorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Author.
     * @param {AuthorCreateArgs} args - Arguments to create a Author.
     * @example
     * // Create one Author
     * const Author = await prisma.author.create({
     *   data: {
     *     // ... data to create a Author
     *   }
     * })
     * 
     */
    create<T extends AuthorCreateArgs>(args: SelectSubset<T, AuthorCreateArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Authors.
     * @param {AuthorCreateManyArgs} args - Arguments to create many Authors.
     * @example
     * // Create many Authors
     * const author = await prisma.author.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuthorCreateManyArgs>(args?: SelectSubset<T, AuthorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Authors and returns the data saved in the database.
     * @param {AuthorCreateManyAndReturnArgs} args - Arguments to create many Authors.
     * @example
     * // Create many Authors
     * const author = await prisma.author.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Authors and only return the `id`
     * const authorWithIdOnly = await prisma.author.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuthorCreateManyAndReturnArgs>(args?: SelectSubset<T, AuthorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Author.
     * @param {AuthorDeleteArgs} args - Arguments to delete one Author.
     * @example
     * // Delete one Author
     * const Author = await prisma.author.delete({
     *   where: {
     *     // ... filter to delete one Author
     *   }
     * })
     * 
     */
    delete<T extends AuthorDeleteArgs>(args: SelectSubset<T, AuthorDeleteArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Author.
     * @param {AuthorUpdateArgs} args - Arguments to update one Author.
     * @example
     * // Update one Author
     * const author = await prisma.author.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuthorUpdateArgs>(args: SelectSubset<T, AuthorUpdateArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Authors.
     * @param {AuthorDeleteManyArgs} args - Arguments to filter Authors to delete.
     * @example
     * // Delete a few Authors
     * const { count } = await prisma.author.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuthorDeleteManyArgs>(args?: SelectSubset<T, AuthorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Authors
     * const author = await prisma.author.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuthorUpdateManyArgs>(args: SelectSubset<T, AuthorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Authors and returns the data updated in the database.
     * @param {AuthorUpdateManyAndReturnArgs} args - Arguments to update many Authors.
     * @example
     * // Update many Authors
     * const author = await prisma.author.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Authors and only return the `id`
     * const authorWithIdOnly = await prisma.author.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuthorUpdateManyAndReturnArgs>(args: SelectSubset<T, AuthorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Author.
     * @param {AuthorUpsertArgs} args - Arguments to update or create a Author.
     * @example
     * // Update or create a Author
     * const author = await prisma.author.upsert({
     *   create: {
     *     // ... data to create a Author
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Author we want to update
     *   }
     * })
     */
    upsert<T extends AuthorUpsertArgs>(args: SelectSubset<T, AuthorUpsertArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorCountArgs} args - Arguments to filter Authors to count.
     * @example
     * // Count the number of Authors
     * const count = await prisma.author.count({
     *   where: {
     *     // ... the filter for the Authors we want to count
     *   }
     * })
    **/
    count<T extends AuthorCountArgs>(
      args?: Subset<T, AuthorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Author.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthorAggregateArgs>(args: Subset<T, AuthorAggregateArgs>): Prisma.PrismaPromise<GetAuthorAggregateType<T>>

    /**
     * Group by Author.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuthorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuthorGroupByArgs['orderBy'] }
        : { orderBy?: AuthorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuthorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Author model
   */
  readonly fields: AuthorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Author.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuthorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    articles<T extends Author$articlesArgs<ExtArgs> = {}>(args?: Subset<T, Author$articlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Author model
   */
  interface AuthorFieldRefs {
    readonly id: FieldRef<"Author", 'String'>
    readonly bio: FieldRef<"Author", 'String'>
    readonly profileImage: FieldRef<"Author", 'String'>
    readonly createdAt: FieldRef<"Author", 'DateTime'>
    readonly updatedAt: FieldRef<"Author", 'DateTime'>
    readonly userId: FieldRef<"Author", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Author findUnique
   */
  export type AuthorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * Filter, which Author to fetch.
     */
    where: AuthorWhereUniqueInput
  }

  /**
   * Author findUniqueOrThrow
   */
  export type AuthorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * Filter, which Author to fetch.
     */
    where: AuthorWhereUniqueInput
  }

  /**
   * Author findFirst
   */
  export type AuthorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * Filter, which Author to fetch.
     */
    where?: AuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authors to fetch.
     */
    orderBy?: AuthorOrderByWithRelationInput | AuthorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Authors.
     */
    cursor?: AuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Authors.
     */
    distinct?: AuthorScalarFieldEnum | AuthorScalarFieldEnum[]
  }

  /**
   * Author findFirstOrThrow
   */
  export type AuthorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * Filter, which Author to fetch.
     */
    where?: AuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authors to fetch.
     */
    orderBy?: AuthorOrderByWithRelationInput | AuthorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Authors.
     */
    cursor?: AuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Authors.
     */
    distinct?: AuthorScalarFieldEnum | AuthorScalarFieldEnum[]
  }

  /**
   * Author findMany
   */
  export type AuthorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * Filter, which Authors to fetch.
     */
    where?: AuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authors to fetch.
     */
    orderBy?: AuthorOrderByWithRelationInput | AuthorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Authors.
     */
    cursor?: AuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authors.
     */
    skip?: number
    distinct?: AuthorScalarFieldEnum | AuthorScalarFieldEnum[]
  }

  /**
   * Author create
   */
  export type AuthorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * The data needed to create a Author.
     */
    data: XOR<AuthorCreateInput, AuthorUncheckedCreateInput>
  }

  /**
   * Author createMany
   */
  export type AuthorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Authors.
     */
    data: AuthorCreateManyInput | AuthorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Author createManyAndReturn
   */
  export type AuthorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * The data used to create many Authors.
     */
    data: AuthorCreateManyInput | AuthorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Author update
   */
  export type AuthorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * The data needed to update a Author.
     */
    data: XOR<AuthorUpdateInput, AuthorUncheckedUpdateInput>
    /**
     * Choose, which Author to update.
     */
    where: AuthorWhereUniqueInput
  }

  /**
   * Author updateMany
   */
  export type AuthorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Authors.
     */
    data: XOR<AuthorUpdateManyMutationInput, AuthorUncheckedUpdateManyInput>
    /**
     * Filter which Authors to update
     */
    where?: AuthorWhereInput
    /**
     * Limit how many Authors to update.
     */
    limit?: number
  }

  /**
   * Author updateManyAndReturn
   */
  export type AuthorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * The data used to update Authors.
     */
    data: XOR<AuthorUpdateManyMutationInput, AuthorUncheckedUpdateManyInput>
    /**
     * Filter which Authors to update
     */
    where?: AuthorWhereInput
    /**
     * Limit how many Authors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Author upsert
   */
  export type AuthorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * The filter to search for the Author to update in case it exists.
     */
    where: AuthorWhereUniqueInput
    /**
     * In case the Author found by the `where` argument doesn't exist, create a new Author with this data.
     */
    create: XOR<AuthorCreateInput, AuthorUncheckedCreateInput>
    /**
     * In case the Author was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuthorUpdateInput, AuthorUncheckedUpdateInput>
  }

  /**
   * Author delete
   */
  export type AuthorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * Filter which Author to delete.
     */
    where: AuthorWhereUniqueInput
  }

  /**
   * Author deleteMany
   */
  export type AuthorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Authors to delete
     */
    where?: AuthorWhereInput
    /**
     * Limit how many Authors to delete.
     */
    limit?: number
  }

  /**
   * Author.articles
   */
  export type Author$articlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    where?: ArticleWhereInput
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    cursor?: ArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }

  /**
   * Author without action
   */
  export type AuthorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    parentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    parentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Category$parentArgs<ExtArgs>
    children?: boolean | Category$childrenArgs<ExtArgs>
    articles?: boolean | Category$articlesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Category$parentArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Category$parentArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "parentId" | "createdAt" | "updatedAt", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Category$parentArgs<ExtArgs>
    children?: boolean | Category$childrenArgs<ExtArgs>
    articles?: boolean | Category$articlesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Category$parentArgs<ExtArgs>
  }
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Category$parentArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      parent: Prisma.$CategoryPayload<ExtArgs> | null
      children: Prisma.$CategoryPayload<ExtArgs>[]
      articles: Prisma.$ArticleCategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      parentId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends Category$parentArgs<ExtArgs> = {}>(args?: Subset<T, Category$parentArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Category$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Category$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    articles<T extends Category$articlesArgs<ExtArgs> = {}>(args?: Subset<T, Category$articlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticleCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly slug: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
    readonly parentId: FieldRef<"Category", 'String'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.parent
   */
  export type Category$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Category.children
   */
  export type Category$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category.articles
   */
  export type Category$articlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleCategory
     */
    select?: ArticleCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleCategory
     */
    omit?: ArticleCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCategoryInclude<ExtArgs> | null
    where?: ArticleCategoryWhereInput
    orderBy?: ArticleCategoryOrderByWithRelationInput | ArticleCategoryOrderByWithRelationInput[]
    cursor?: ArticleCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArticleCategoryScalarFieldEnum | ArticleCategoryScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    articles?: boolean | Tag$articlesArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    articles?: boolean | Tag$articlesArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      articles: Prisma.$ArticleTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    articles<T extends Tag$articlesArgs<ExtArgs> = {}>(args?: Subset<T, Tag$articlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticleTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly slug: FieldRef<"Tag", 'String'>
    readonly description: FieldRef<"Tag", 'String'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
    readonly updatedAt: FieldRef<"Tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.articles
   */
  export type Tag$articlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleTag
     */
    select?: ArticleTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleTag
     */
    omit?: ArticleTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleTagInclude<ExtArgs> | null
    where?: ArticleTagWhereInput
    orderBy?: ArticleTagOrderByWithRelationInput | ArticleTagOrderByWithRelationInput[]
    cursor?: ArticleTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArticleTagScalarFieldEnum | ArticleTagScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model Article
   */

  export type AggregateArticle = {
    _count: ArticleCountAggregateOutputType | null
    _avg: ArticleAvgAggregateOutputType | null
    _sum: ArticleSumAggregateOutputType | null
    _min: ArticleMinAggregateOutputType | null
    _max: ArticleMaxAggregateOutputType | null
  }

  export type ArticleAvgAggregateOutputType = {
    viewCount: number | null
  }

  export type ArticleSumAggregateOutputType = {
    viewCount: number | null
  }

  export type ArticleMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    content: string | null
    excerpt: string | null
    featuredImage: string | null
    status: $Enums.ArticleStatus | null
    viewCount: number | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    authorId: string | null
  }

  export type ArticleMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    content: string | null
    excerpt: string | null
    featuredImage: string | null
    status: $Enums.ArticleStatus | null
    viewCount: number | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    authorId: string | null
  }

  export type ArticleCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    content: number
    excerpt: number
    featuredImage: number
    status: number
    viewCount: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    authorId: number
    _all: number
  }


  export type ArticleAvgAggregateInputType = {
    viewCount?: true
  }

  export type ArticleSumAggregateInputType = {
    viewCount?: true
  }

  export type ArticleMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    content?: true
    excerpt?: true
    featuredImage?: true
    status?: true
    viewCount?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
  }

  export type ArticleMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    content?: true
    excerpt?: true
    featuredImage?: true
    status?: true
    viewCount?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
  }

  export type ArticleCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    content?: true
    excerpt?: true
    featuredImage?: true
    status?: true
    viewCount?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    authorId?: true
    _all?: true
  }

  export type ArticleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Article to aggregate.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Articles
    **/
    _count?: true | ArticleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArticleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArticleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArticleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArticleMaxAggregateInputType
  }

  export type GetArticleAggregateType<T extends ArticleAggregateArgs> = {
        [P in keyof T & keyof AggregateArticle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArticle[P]>
      : GetScalarType<T[P], AggregateArticle[P]>
  }




  export type ArticleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArticleWhereInput
    orderBy?: ArticleOrderByWithAggregationInput | ArticleOrderByWithAggregationInput[]
    by: ArticleScalarFieldEnum[] | ArticleScalarFieldEnum
    having?: ArticleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArticleCountAggregateInputType | true
    _avg?: ArticleAvgAggregateInputType
    _sum?: ArticleSumAggregateInputType
    _min?: ArticleMinAggregateInputType
    _max?: ArticleMaxAggregateInputType
  }

  export type ArticleGroupByOutputType = {
    id: string
    title: string
    slug: string
    content: string
    excerpt: string | null
    featuredImage: string | null
    status: $Enums.ArticleStatus
    viewCount: number
    publishedAt: Date | null
    createdAt: Date
    updatedAt: Date
    authorId: string
    _count: ArticleCountAggregateOutputType | null
    _avg: ArticleAvgAggregateOutputType | null
    _sum: ArticleSumAggregateOutputType | null
    _min: ArticleMinAggregateOutputType | null
    _max: ArticleMaxAggregateOutputType | null
  }

  type GetArticleGroupByPayload<T extends ArticleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArticleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArticleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArticleGroupByOutputType[P]>
            : GetScalarType<T[P], ArticleGroupByOutputType[P]>
        }
      >
    >


  export type ArticleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    excerpt?: boolean
    featuredImage?: boolean
    status?: boolean
    viewCount?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
    author?: boolean | AuthorDefaultArgs<ExtArgs>
    categories?: boolean | Article$categoriesArgs<ExtArgs>
    tags?: boolean | Article$tagsArgs<ExtArgs>
    comments?: boolean | Article$commentsArgs<ExtArgs>
    _count?: boolean | ArticleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["article"]>

  export type ArticleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    excerpt?: boolean
    featuredImage?: boolean
    status?: boolean
    viewCount?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
    author?: boolean | AuthorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["article"]>

  export type ArticleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    excerpt?: boolean
    featuredImage?: boolean
    status?: boolean
    viewCount?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
    author?: boolean | AuthorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["article"]>

  export type ArticleSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    excerpt?: boolean
    featuredImage?: boolean
    status?: boolean
    viewCount?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorId?: boolean
  }

  export type ArticleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "content" | "excerpt" | "featuredImage" | "status" | "viewCount" | "publishedAt" | "createdAt" | "updatedAt" | "authorId", ExtArgs["result"]["article"]>
  export type ArticleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | AuthorDefaultArgs<ExtArgs>
    categories?: boolean | Article$categoriesArgs<ExtArgs>
    tags?: boolean | Article$tagsArgs<ExtArgs>
    comments?: boolean | Article$commentsArgs<ExtArgs>
    _count?: boolean | ArticleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ArticleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | AuthorDefaultArgs<ExtArgs>
  }
  export type ArticleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | AuthorDefaultArgs<ExtArgs>
  }

  export type $ArticlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Article"
    objects: {
      author: Prisma.$AuthorPayload<ExtArgs>
      categories: Prisma.$ArticleCategoryPayload<ExtArgs>[]
      tags: Prisma.$ArticleTagPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      content: string
      excerpt: string | null
      featuredImage: string | null
      status: $Enums.ArticleStatus
      viewCount: number
      publishedAt: Date | null
      createdAt: Date
      updatedAt: Date
      authorId: string
    }, ExtArgs["result"]["article"]>
    composites: {}
  }

  type ArticleGetPayload<S extends boolean | null | undefined | ArticleDefaultArgs> = $Result.GetResult<Prisma.$ArticlePayload, S>

  type ArticleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ArticleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ArticleCountAggregateInputType | true
    }

  export interface ArticleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Article'], meta: { name: 'Article' } }
    /**
     * Find zero or one Article that matches the filter.
     * @param {ArticleFindUniqueArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArticleFindUniqueArgs>(args: SelectSubset<T, ArticleFindUniqueArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Article that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArticleFindUniqueOrThrowArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArticleFindUniqueOrThrowArgs>(args: SelectSubset<T, ArticleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Article that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleFindFirstArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArticleFindFirstArgs>(args?: SelectSubset<T, ArticleFindFirstArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Article that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleFindFirstOrThrowArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArticleFindFirstOrThrowArgs>(args?: SelectSubset<T, ArticleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Articles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Articles
     * const articles = await prisma.article.findMany()
     * 
     * // Get first 10 Articles
     * const articles = await prisma.article.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const articleWithIdOnly = await prisma.article.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ArticleFindManyArgs>(args?: SelectSubset<T, ArticleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Article.
     * @param {ArticleCreateArgs} args - Arguments to create a Article.
     * @example
     * // Create one Article
     * const Article = await prisma.article.create({
     *   data: {
     *     // ... data to create a Article
     *   }
     * })
     * 
     */
    create<T extends ArticleCreateArgs>(args: SelectSubset<T, ArticleCreateArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Articles.
     * @param {ArticleCreateManyArgs} args - Arguments to create many Articles.
     * @example
     * // Create many Articles
     * const article = await prisma.article.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArticleCreateManyArgs>(args?: SelectSubset<T, ArticleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Articles and returns the data saved in the database.
     * @param {ArticleCreateManyAndReturnArgs} args - Arguments to create many Articles.
     * @example
     * // Create many Articles
     * const article = await prisma.article.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Articles and only return the `id`
     * const articleWithIdOnly = await prisma.article.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ArticleCreateManyAndReturnArgs>(args?: SelectSubset<T, ArticleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Article.
     * @param {ArticleDeleteArgs} args - Arguments to delete one Article.
     * @example
     * // Delete one Article
     * const Article = await prisma.article.delete({
     *   where: {
     *     // ... filter to delete one Article
     *   }
     * })
     * 
     */
    delete<T extends ArticleDeleteArgs>(args: SelectSubset<T, ArticleDeleteArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Article.
     * @param {ArticleUpdateArgs} args - Arguments to update one Article.
     * @example
     * // Update one Article
     * const article = await prisma.article.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArticleUpdateArgs>(args: SelectSubset<T, ArticleUpdateArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Articles.
     * @param {ArticleDeleteManyArgs} args - Arguments to filter Articles to delete.
     * @example
     * // Delete a few Articles
     * const { count } = await prisma.article.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArticleDeleteManyArgs>(args?: SelectSubset<T, ArticleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Articles
     * const article = await prisma.article.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArticleUpdateManyArgs>(args: SelectSubset<T, ArticleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Articles and returns the data updated in the database.
     * @param {ArticleUpdateManyAndReturnArgs} args - Arguments to update many Articles.
     * @example
     * // Update many Articles
     * const article = await prisma.article.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Articles and only return the `id`
     * const articleWithIdOnly = await prisma.article.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ArticleUpdateManyAndReturnArgs>(args: SelectSubset<T, ArticleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Article.
     * @param {ArticleUpsertArgs} args - Arguments to update or create a Article.
     * @example
     * // Update or create a Article
     * const article = await prisma.article.upsert({
     *   create: {
     *     // ... data to create a Article
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Article we want to update
     *   }
     * })
     */
    upsert<T extends ArticleUpsertArgs>(args: SelectSubset<T, ArticleUpsertArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCountArgs} args - Arguments to filter Articles to count.
     * @example
     * // Count the number of Articles
     * const count = await prisma.article.count({
     *   where: {
     *     // ... the filter for the Articles we want to count
     *   }
     * })
    **/
    count<T extends ArticleCountArgs>(
      args?: Subset<T, ArticleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArticleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Article.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArticleAggregateArgs>(args: Subset<T, ArticleAggregateArgs>): Prisma.PrismaPromise<GetArticleAggregateType<T>>

    /**
     * Group by Article.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArticleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArticleGroupByArgs['orderBy'] }
        : { orderBy?: ArticleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArticleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArticleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Article model
   */
  readonly fields: ArticleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Article.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArticleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends AuthorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AuthorDefaultArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    categories<T extends Article$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Article$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticleCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Article$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Article$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticleTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends Article$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Article$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Article model
   */
  interface ArticleFieldRefs {
    readonly id: FieldRef<"Article", 'String'>
    readonly title: FieldRef<"Article", 'String'>
    readonly slug: FieldRef<"Article", 'String'>
    readonly content: FieldRef<"Article", 'String'>
    readonly excerpt: FieldRef<"Article", 'String'>
    readonly featuredImage: FieldRef<"Article", 'String'>
    readonly status: FieldRef<"Article", 'ArticleStatus'>
    readonly viewCount: FieldRef<"Article", 'Int'>
    readonly publishedAt: FieldRef<"Article", 'DateTime'>
    readonly createdAt: FieldRef<"Article", 'DateTime'>
    readonly updatedAt: FieldRef<"Article", 'DateTime'>
    readonly authorId: FieldRef<"Article", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Article findUnique
   */
  export type ArticleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where: ArticleWhereUniqueInput
  }

  /**
   * Article findUniqueOrThrow
   */
  export type ArticleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where: ArticleWhereUniqueInput
  }

  /**
   * Article findFirst
   */
  export type ArticleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Articles.
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Articles.
     */
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }

  /**
   * Article findFirstOrThrow
   */
  export type ArticleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Articles.
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Articles.
     */
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }

  /**
   * Article findMany
   */
  export type ArticleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Articles to fetch.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: ArticleOrderByWithRelationInput | ArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Articles.
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    distinct?: ArticleScalarFieldEnum | ArticleScalarFieldEnum[]
  }

  /**
   * Article create
   */
  export type ArticleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * The data needed to create a Article.
     */
    data: XOR<ArticleCreateInput, ArticleUncheckedCreateInput>
  }

  /**
   * Article createMany
   */
  export type ArticleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Articles.
     */
    data: ArticleCreateManyInput | ArticleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Article createManyAndReturn
   */
  export type ArticleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * The data used to create many Articles.
     */
    data: ArticleCreateManyInput | ArticleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Article update
   */
  export type ArticleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * The data needed to update a Article.
     */
    data: XOR<ArticleUpdateInput, ArticleUncheckedUpdateInput>
    /**
     * Choose, which Article to update.
     */
    where: ArticleWhereUniqueInput
  }

  /**
   * Article updateMany
   */
  export type ArticleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Articles.
     */
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyInput>
    /**
     * Filter which Articles to update
     */
    where?: ArticleWhereInput
    /**
     * Limit how many Articles to update.
     */
    limit?: number
  }

  /**
   * Article updateManyAndReturn
   */
  export type ArticleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * The data used to update Articles.
     */
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyInput>
    /**
     * Filter which Articles to update
     */
    where?: ArticleWhereInput
    /**
     * Limit how many Articles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Article upsert
   */
  export type ArticleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * The filter to search for the Article to update in case it exists.
     */
    where: ArticleWhereUniqueInput
    /**
     * In case the Article found by the `where` argument doesn't exist, create a new Article with this data.
     */
    create: XOR<ArticleCreateInput, ArticleUncheckedCreateInput>
    /**
     * In case the Article was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArticleUpdateInput, ArticleUncheckedUpdateInput>
  }

  /**
   * Article delete
   */
  export type ArticleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter which Article to delete.
     */
    where: ArticleWhereUniqueInput
  }

  /**
   * Article deleteMany
   */
  export type ArticleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Articles to delete
     */
    where?: ArticleWhereInput
    /**
     * Limit how many Articles to delete.
     */
    limit?: number
  }

  /**
   * Article.categories
   */
  export type Article$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleCategory
     */
    select?: ArticleCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleCategory
     */
    omit?: ArticleCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCategoryInclude<ExtArgs> | null
    where?: ArticleCategoryWhereInput
    orderBy?: ArticleCategoryOrderByWithRelationInput | ArticleCategoryOrderByWithRelationInput[]
    cursor?: ArticleCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArticleCategoryScalarFieldEnum | ArticleCategoryScalarFieldEnum[]
  }

  /**
   * Article.tags
   */
  export type Article$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleTag
     */
    select?: ArticleTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleTag
     */
    omit?: ArticleTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleTagInclude<ExtArgs> | null
    where?: ArticleTagWhereInput
    orderBy?: ArticleTagOrderByWithRelationInput | ArticleTagOrderByWithRelationInput[]
    cursor?: ArticleTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArticleTagScalarFieldEnum | ArticleTagScalarFieldEnum[]
  }

  /**
   * Article.comments
   */
  export type Article$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Article without action
   */
  export type ArticleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Article
     */
    omit?: ArticleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleInclude<ExtArgs> | null
  }


  /**
   * Model ArticleCategory
   */

  export type AggregateArticleCategory = {
    _count: ArticleCategoryCountAggregateOutputType | null
    _min: ArticleCategoryMinAggregateOutputType | null
    _max: ArticleCategoryMaxAggregateOutputType | null
  }

  export type ArticleCategoryMinAggregateOutputType = {
    articleId: string | null
    categoryId: string | null
  }

  export type ArticleCategoryMaxAggregateOutputType = {
    articleId: string | null
    categoryId: string | null
  }

  export type ArticleCategoryCountAggregateOutputType = {
    articleId: number
    categoryId: number
    _all: number
  }


  export type ArticleCategoryMinAggregateInputType = {
    articleId?: true
    categoryId?: true
  }

  export type ArticleCategoryMaxAggregateInputType = {
    articleId?: true
    categoryId?: true
  }

  export type ArticleCategoryCountAggregateInputType = {
    articleId?: true
    categoryId?: true
    _all?: true
  }

  export type ArticleCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArticleCategory to aggregate.
     */
    where?: ArticleCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleCategories to fetch.
     */
    orderBy?: ArticleCategoryOrderByWithRelationInput | ArticleCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArticleCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ArticleCategories
    **/
    _count?: true | ArticleCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArticleCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArticleCategoryMaxAggregateInputType
  }

  export type GetArticleCategoryAggregateType<T extends ArticleCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateArticleCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArticleCategory[P]>
      : GetScalarType<T[P], AggregateArticleCategory[P]>
  }




  export type ArticleCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArticleCategoryWhereInput
    orderBy?: ArticleCategoryOrderByWithAggregationInput | ArticleCategoryOrderByWithAggregationInput[]
    by: ArticleCategoryScalarFieldEnum[] | ArticleCategoryScalarFieldEnum
    having?: ArticleCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArticleCategoryCountAggregateInputType | true
    _min?: ArticleCategoryMinAggregateInputType
    _max?: ArticleCategoryMaxAggregateInputType
  }

  export type ArticleCategoryGroupByOutputType = {
    articleId: string
    categoryId: string
    _count: ArticleCategoryCountAggregateOutputType | null
    _min: ArticleCategoryMinAggregateOutputType | null
    _max: ArticleCategoryMaxAggregateOutputType | null
  }

  type GetArticleCategoryGroupByPayload<T extends ArticleCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArticleCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArticleCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArticleCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ArticleCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ArticleCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    articleId?: boolean
    categoryId?: boolean
    article?: boolean | ArticleDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["articleCategory"]>

  export type ArticleCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    articleId?: boolean
    categoryId?: boolean
    article?: boolean | ArticleDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["articleCategory"]>

  export type ArticleCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    articleId?: boolean
    categoryId?: boolean
    article?: boolean | ArticleDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["articleCategory"]>

  export type ArticleCategorySelectScalar = {
    articleId?: boolean
    categoryId?: boolean
  }

  export type ArticleCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"articleId" | "categoryId", ExtArgs["result"]["articleCategory"]>
  export type ArticleCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | ArticleDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type ArticleCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | ArticleDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type ArticleCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | ArticleDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }

  export type $ArticleCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ArticleCategory"
    objects: {
      article: Prisma.$ArticlePayload<ExtArgs>
      category: Prisma.$CategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      articleId: string
      categoryId: string
    }, ExtArgs["result"]["articleCategory"]>
    composites: {}
  }

  type ArticleCategoryGetPayload<S extends boolean | null | undefined | ArticleCategoryDefaultArgs> = $Result.GetResult<Prisma.$ArticleCategoryPayload, S>

  type ArticleCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ArticleCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ArticleCategoryCountAggregateInputType | true
    }

  export interface ArticleCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ArticleCategory'], meta: { name: 'ArticleCategory' } }
    /**
     * Find zero or one ArticleCategory that matches the filter.
     * @param {ArticleCategoryFindUniqueArgs} args - Arguments to find a ArticleCategory
     * @example
     * // Get one ArticleCategory
     * const articleCategory = await prisma.articleCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArticleCategoryFindUniqueArgs>(args: SelectSubset<T, ArticleCategoryFindUniqueArgs<ExtArgs>>): Prisma__ArticleCategoryClient<$Result.GetResult<Prisma.$ArticleCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ArticleCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArticleCategoryFindUniqueOrThrowArgs} args - Arguments to find a ArticleCategory
     * @example
     * // Get one ArticleCategory
     * const articleCategory = await prisma.articleCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArticleCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ArticleCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArticleCategoryClient<$Result.GetResult<Prisma.$ArticleCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ArticleCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCategoryFindFirstArgs} args - Arguments to find a ArticleCategory
     * @example
     * // Get one ArticleCategory
     * const articleCategory = await prisma.articleCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArticleCategoryFindFirstArgs>(args?: SelectSubset<T, ArticleCategoryFindFirstArgs<ExtArgs>>): Prisma__ArticleCategoryClient<$Result.GetResult<Prisma.$ArticleCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ArticleCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCategoryFindFirstOrThrowArgs} args - Arguments to find a ArticleCategory
     * @example
     * // Get one ArticleCategory
     * const articleCategory = await prisma.articleCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArticleCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ArticleCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArticleCategoryClient<$Result.GetResult<Prisma.$ArticleCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ArticleCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ArticleCategories
     * const articleCategories = await prisma.articleCategory.findMany()
     * 
     * // Get first 10 ArticleCategories
     * const articleCategories = await prisma.articleCategory.findMany({ take: 10 })
     * 
     * // Only select the `articleId`
     * const articleCategoryWithArticleIdOnly = await prisma.articleCategory.findMany({ select: { articleId: true } })
     * 
     */
    findMany<T extends ArticleCategoryFindManyArgs>(args?: SelectSubset<T, ArticleCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticleCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ArticleCategory.
     * @param {ArticleCategoryCreateArgs} args - Arguments to create a ArticleCategory.
     * @example
     * // Create one ArticleCategory
     * const ArticleCategory = await prisma.articleCategory.create({
     *   data: {
     *     // ... data to create a ArticleCategory
     *   }
     * })
     * 
     */
    create<T extends ArticleCategoryCreateArgs>(args: SelectSubset<T, ArticleCategoryCreateArgs<ExtArgs>>): Prisma__ArticleCategoryClient<$Result.GetResult<Prisma.$ArticleCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ArticleCategories.
     * @param {ArticleCategoryCreateManyArgs} args - Arguments to create many ArticleCategories.
     * @example
     * // Create many ArticleCategories
     * const articleCategory = await prisma.articleCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArticleCategoryCreateManyArgs>(args?: SelectSubset<T, ArticleCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ArticleCategories and returns the data saved in the database.
     * @param {ArticleCategoryCreateManyAndReturnArgs} args - Arguments to create many ArticleCategories.
     * @example
     * // Create many ArticleCategories
     * const articleCategory = await prisma.articleCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ArticleCategories and only return the `articleId`
     * const articleCategoryWithArticleIdOnly = await prisma.articleCategory.createManyAndReturn({
     *   select: { articleId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ArticleCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ArticleCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticleCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ArticleCategory.
     * @param {ArticleCategoryDeleteArgs} args - Arguments to delete one ArticleCategory.
     * @example
     * // Delete one ArticleCategory
     * const ArticleCategory = await prisma.articleCategory.delete({
     *   where: {
     *     // ... filter to delete one ArticleCategory
     *   }
     * })
     * 
     */
    delete<T extends ArticleCategoryDeleteArgs>(args: SelectSubset<T, ArticleCategoryDeleteArgs<ExtArgs>>): Prisma__ArticleCategoryClient<$Result.GetResult<Prisma.$ArticleCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ArticleCategory.
     * @param {ArticleCategoryUpdateArgs} args - Arguments to update one ArticleCategory.
     * @example
     * // Update one ArticleCategory
     * const articleCategory = await prisma.articleCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArticleCategoryUpdateArgs>(args: SelectSubset<T, ArticleCategoryUpdateArgs<ExtArgs>>): Prisma__ArticleCategoryClient<$Result.GetResult<Prisma.$ArticleCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ArticleCategories.
     * @param {ArticleCategoryDeleteManyArgs} args - Arguments to filter ArticleCategories to delete.
     * @example
     * // Delete a few ArticleCategories
     * const { count } = await prisma.articleCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArticleCategoryDeleteManyArgs>(args?: SelectSubset<T, ArticleCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArticleCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ArticleCategories
     * const articleCategory = await prisma.articleCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArticleCategoryUpdateManyArgs>(args: SelectSubset<T, ArticleCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArticleCategories and returns the data updated in the database.
     * @param {ArticleCategoryUpdateManyAndReturnArgs} args - Arguments to update many ArticleCategories.
     * @example
     * // Update many ArticleCategories
     * const articleCategory = await prisma.articleCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ArticleCategories and only return the `articleId`
     * const articleCategoryWithArticleIdOnly = await prisma.articleCategory.updateManyAndReturn({
     *   select: { articleId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ArticleCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ArticleCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticleCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ArticleCategory.
     * @param {ArticleCategoryUpsertArgs} args - Arguments to update or create a ArticleCategory.
     * @example
     * // Update or create a ArticleCategory
     * const articleCategory = await prisma.articleCategory.upsert({
     *   create: {
     *     // ... data to create a ArticleCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ArticleCategory we want to update
     *   }
     * })
     */
    upsert<T extends ArticleCategoryUpsertArgs>(args: SelectSubset<T, ArticleCategoryUpsertArgs<ExtArgs>>): Prisma__ArticleCategoryClient<$Result.GetResult<Prisma.$ArticleCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ArticleCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCategoryCountArgs} args - Arguments to filter ArticleCategories to count.
     * @example
     * // Count the number of ArticleCategories
     * const count = await prisma.articleCategory.count({
     *   where: {
     *     // ... the filter for the ArticleCategories we want to count
     *   }
     * })
    **/
    count<T extends ArticleCategoryCountArgs>(
      args?: Subset<T, ArticleCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArticleCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ArticleCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArticleCategoryAggregateArgs>(args: Subset<T, ArticleCategoryAggregateArgs>): Prisma.PrismaPromise<GetArticleCategoryAggregateType<T>>

    /**
     * Group by ArticleCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArticleCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArticleCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ArticleCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArticleCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArticleCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ArticleCategory model
   */
  readonly fields: ArticleCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ArticleCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArticleCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    article<T extends ArticleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArticleDefaultArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ArticleCategory model
   */
  interface ArticleCategoryFieldRefs {
    readonly articleId: FieldRef<"ArticleCategory", 'String'>
    readonly categoryId: FieldRef<"ArticleCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ArticleCategory findUnique
   */
  export type ArticleCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleCategory
     */
    select?: ArticleCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleCategory
     */
    omit?: ArticleCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ArticleCategory to fetch.
     */
    where: ArticleCategoryWhereUniqueInput
  }

  /**
   * ArticleCategory findUniqueOrThrow
   */
  export type ArticleCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleCategory
     */
    select?: ArticleCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleCategory
     */
    omit?: ArticleCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ArticleCategory to fetch.
     */
    where: ArticleCategoryWhereUniqueInput
  }

  /**
   * ArticleCategory findFirst
   */
  export type ArticleCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleCategory
     */
    select?: ArticleCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleCategory
     */
    omit?: ArticleCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ArticleCategory to fetch.
     */
    where?: ArticleCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleCategories to fetch.
     */
    orderBy?: ArticleCategoryOrderByWithRelationInput | ArticleCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArticleCategories.
     */
    cursor?: ArticleCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArticleCategories.
     */
    distinct?: ArticleCategoryScalarFieldEnum | ArticleCategoryScalarFieldEnum[]
  }

  /**
   * ArticleCategory findFirstOrThrow
   */
  export type ArticleCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleCategory
     */
    select?: ArticleCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleCategory
     */
    omit?: ArticleCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ArticleCategory to fetch.
     */
    where?: ArticleCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleCategories to fetch.
     */
    orderBy?: ArticleCategoryOrderByWithRelationInput | ArticleCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArticleCategories.
     */
    cursor?: ArticleCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArticleCategories.
     */
    distinct?: ArticleCategoryScalarFieldEnum | ArticleCategoryScalarFieldEnum[]
  }

  /**
   * ArticleCategory findMany
   */
  export type ArticleCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleCategory
     */
    select?: ArticleCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleCategory
     */
    omit?: ArticleCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ArticleCategories to fetch.
     */
    where?: ArticleCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleCategories to fetch.
     */
    orderBy?: ArticleCategoryOrderByWithRelationInput | ArticleCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ArticleCategories.
     */
    cursor?: ArticleCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleCategories.
     */
    skip?: number
    distinct?: ArticleCategoryScalarFieldEnum | ArticleCategoryScalarFieldEnum[]
  }

  /**
   * ArticleCategory create
   */
  export type ArticleCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleCategory
     */
    select?: ArticleCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleCategory
     */
    omit?: ArticleCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ArticleCategory.
     */
    data: XOR<ArticleCategoryCreateInput, ArticleCategoryUncheckedCreateInput>
  }

  /**
   * ArticleCategory createMany
   */
  export type ArticleCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ArticleCategories.
     */
    data: ArticleCategoryCreateManyInput | ArticleCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ArticleCategory createManyAndReturn
   */
  export type ArticleCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleCategory
     */
    select?: ArticleCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleCategory
     */
    omit?: ArticleCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ArticleCategories.
     */
    data: ArticleCategoryCreateManyInput | ArticleCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ArticleCategory update
   */
  export type ArticleCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleCategory
     */
    select?: ArticleCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleCategory
     */
    omit?: ArticleCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ArticleCategory.
     */
    data: XOR<ArticleCategoryUpdateInput, ArticleCategoryUncheckedUpdateInput>
    /**
     * Choose, which ArticleCategory to update.
     */
    where: ArticleCategoryWhereUniqueInput
  }

  /**
   * ArticleCategory updateMany
   */
  export type ArticleCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ArticleCategories.
     */
    data: XOR<ArticleCategoryUpdateManyMutationInput, ArticleCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ArticleCategories to update
     */
    where?: ArticleCategoryWhereInput
    /**
     * Limit how many ArticleCategories to update.
     */
    limit?: number
  }

  /**
   * ArticleCategory updateManyAndReturn
   */
  export type ArticleCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleCategory
     */
    select?: ArticleCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleCategory
     */
    omit?: ArticleCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ArticleCategories.
     */
    data: XOR<ArticleCategoryUpdateManyMutationInput, ArticleCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ArticleCategories to update
     */
    where?: ArticleCategoryWhereInput
    /**
     * Limit how many ArticleCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ArticleCategory upsert
   */
  export type ArticleCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleCategory
     */
    select?: ArticleCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleCategory
     */
    omit?: ArticleCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ArticleCategory to update in case it exists.
     */
    where: ArticleCategoryWhereUniqueInput
    /**
     * In case the ArticleCategory found by the `where` argument doesn't exist, create a new ArticleCategory with this data.
     */
    create: XOR<ArticleCategoryCreateInput, ArticleCategoryUncheckedCreateInput>
    /**
     * In case the ArticleCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArticleCategoryUpdateInput, ArticleCategoryUncheckedUpdateInput>
  }

  /**
   * ArticleCategory delete
   */
  export type ArticleCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleCategory
     */
    select?: ArticleCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleCategory
     */
    omit?: ArticleCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCategoryInclude<ExtArgs> | null
    /**
     * Filter which ArticleCategory to delete.
     */
    where: ArticleCategoryWhereUniqueInput
  }

  /**
   * ArticleCategory deleteMany
   */
  export type ArticleCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArticleCategories to delete
     */
    where?: ArticleCategoryWhereInput
    /**
     * Limit how many ArticleCategories to delete.
     */
    limit?: number
  }

  /**
   * ArticleCategory without action
   */
  export type ArticleCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleCategory
     */
    select?: ArticleCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleCategory
     */
    omit?: ArticleCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCategoryInclude<ExtArgs> | null
  }


  /**
   * Model ArticleTag
   */

  export type AggregateArticleTag = {
    _count: ArticleTagCountAggregateOutputType | null
    _min: ArticleTagMinAggregateOutputType | null
    _max: ArticleTagMaxAggregateOutputType | null
  }

  export type ArticleTagMinAggregateOutputType = {
    articleId: string | null
    tagId: string | null
  }

  export type ArticleTagMaxAggregateOutputType = {
    articleId: string | null
    tagId: string | null
  }

  export type ArticleTagCountAggregateOutputType = {
    articleId: number
    tagId: number
    _all: number
  }


  export type ArticleTagMinAggregateInputType = {
    articleId?: true
    tagId?: true
  }

  export type ArticleTagMaxAggregateInputType = {
    articleId?: true
    tagId?: true
  }

  export type ArticleTagCountAggregateInputType = {
    articleId?: true
    tagId?: true
    _all?: true
  }

  export type ArticleTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArticleTag to aggregate.
     */
    where?: ArticleTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleTags to fetch.
     */
    orderBy?: ArticleTagOrderByWithRelationInput | ArticleTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArticleTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ArticleTags
    **/
    _count?: true | ArticleTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArticleTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArticleTagMaxAggregateInputType
  }

  export type GetArticleTagAggregateType<T extends ArticleTagAggregateArgs> = {
        [P in keyof T & keyof AggregateArticleTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArticleTag[P]>
      : GetScalarType<T[P], AggregateArticleTag[P]>
  }




  export type ArticleTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArticleTagWhereInput
    orderBy?: ArticleTagOrderByWithAggregationInput | ArticleTagOrderByWithAggregationInput[]
    by: ArticleTagScalarFieldEnum[] | ArticleTagScalarFieldEnum
    having?: ArticleTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArticleTagCountAggregateInputType | true
    _min?: ArticleTagMinAggregateInputType
    _max?: ArticleTagMaxAggregateInputType
  }

  export type ArticleTagGroupByOutputType = {
    articleId: string
    tagId: string
    _count: ArticleTagCountAggregateOutputType | null
    _min: ArticleTagMinAggregateOutputType | null
    _max: ArticleTagMaxAggregateOutputType | null
  }

  type GetArticleTagGroupByPayload<T extends ArticleTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArticleTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArticleTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArticleTagGroupByOutputType[P]>
            : GetScalarType<T[P], ArticleTagGroupByOutputType[P]>
        }
      >
    >


  export type ArticleTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    articleId?: boolean
    tagId?: boolean
    article?: boolean | ArticleDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["articleTag"]>

  export type ArticleTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    articleId?: boolean
    tagId?: boolean
    article?: boolean | ArticleDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["articleTag"]>

  export type ArticleTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    articleId?: boolean
    tagId?: boolean
    article?: boolean | ArticleDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["articleTag"]>

  export type ArticleTagSelectScalar = {
    articleId?: boolean
    tagId?: boolean
  }

  export type ArticleTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"articleId" | "tagId", ExtArgs["result"]["articleTag"]>
  export type ArticleTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | ArticleDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type ArticleTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | ArticleDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type ArticleTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | ArticleDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $ArticleTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ArticleTag"
    objects: {
      article: Prisma.$ArticlePayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      articleId: string
      tagId: string
    }, ExtArgs["result"]["articleTag"]>
    composites: {}
  }

  type ArticleTagGetPayload<S extends boolean | null | undefined | ArticleTagDefaultArgs> = $Result.GetResult<Prisma.$ArticleTagPayload, S>

  type ArticleTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ArticleTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ArticleTagCountAggregateInputType | true
    }

  export interface ArticleTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ArticleTag'], meta: { name: 'ArticleTag' } }
    /**
     * Find zero or one ArticleTag that matches the filter.
     * @param {ArticleTagFindUniqueArgs} args - Arguments to find a ArticleTag
     * @example
     * // Get one ArticleTag
     * const articleTag = await prisma.articleTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArticleTagFindUniqueArgs>(args: SelectSubset<T, ArticleTagFindUniqueArgs<ExtArgs>>): Prisma__ArticleTagClient<$Result.GetResult<Prisma.$ArticleTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ArticleTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArticleTagFindUniqueOrThrowArgs} args - Arguments to find a ArticleTag
     * @example
     * // Get one ArticleTag
     * const articleTag = await prisma.articleTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArticleTagFindUniqueOrThrowArgs>(args: SelectSubset<T, ArticleTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArticleTagClient<$Result.GetResult<Prisma.$ArticleTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ArticleTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleTagFindFirstArgs} args - Arguments to find a ArticleTag
     * @example
     * // Get one ArticleTag
     * const articleTag = await prisma.articleTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArticleTagFindFirstArgs>(args?: SelectSubset<T, ArticleTagFindFirstArgs<ExtArgs>>): Prisma__ArticleTagClient<$Result.GetResult<Prisma.$ArticleTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ArticleTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleTagFindFirstOrThrowArgs} args - Arguments to find a ArticleTag
     * @example
     * // Get one ArticleTag
     * const articleTag = await prisma.articleTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArticleTagFindFirstOrThrowArgs>(args?: SelectSubset<T, ArticleTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArticleTagClient<$Result.GetResult<Prisma.$ArticleTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ArticleTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ArticleTags
     * const articleTags = await prisma.articleTag.findMany()
     * 
     * // Get first 10 ArticleTags
     * const articleTags = await prisma.articleTag.findMany({ take: 10 })
     * 
     * // Only select the `articleId`
     * const articleTagWithArticleIdOnly = await prisma.articleTag.findMany({ select: { articleId: true } })
     * 
     */
    findMany<T extends ArticleTagFindManyArgs>(args?: SelectSubset<T, ArticleTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticleTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ArticleTag.
     * @param {ArticleTagCreateArgs} args - Arguments to create a ArticleTag.
     * @example
     * // Create one ArticleTag
     * const ArticleTag = await prisma.articleTag.create({
     *   data: {
     *     // ... data to create a ArticleTag
     *   }
     * })
     * 
     */
    create<T extends ArticleTagCreateArgs>(args: SelectSubset<T, ArticleTagCreateArgs<ExtArgs>>): Prisma__ArticleTagClient<$Result.GetResult<Prisma.$ArticleTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ArticleTags.
     * @param {ArticleTagCreateManyArgs} args - Arguments to create many ArticleTags.
     * @example
     * // Create many ArticleTags
     * const articleTag = await prisma.articleTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArticleTagCreateManyArgs>(args?: SelectSubset<T, ArticleTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ArticleTags and returns the data saved in the database.
     * @param {ArticleTagCreateManyAndReturnArgs} args - Arguments to create many ArticleTags.
     * @example
     * // Create many ArticleTags
     * const articleTag = await prisma.articleTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ArticleTags and only return the `articleId`
     * const articleTagWithArticleIdOnly = await prisma.articleTag.createManyAndReturn({
     *   select: { articleId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ArticleTagCreateManyAndReturnArgs>(args?: SelectSubset<T, ArticleTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticleTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ArticleTag.
     * @param {ArticleTagDeleteArgs} args - Arguments to delete one ArticleTag.
     * @example
     * // Delete one ArticleTag
     * const ArticleTag = await prisma.articleTag.delete({
     *   where: {
     *     // ... filter to delete one ArticleTag
     *   }
     * })
     * 
     */
    delete<T extends ArticleTagDeleteArgs>(args: SelectSubset<T, ArticleTagDeleteArgs<ExtArgs>>): Prisma__ArticleTagClient<$Result.GetResult<Prisma.$ArticleTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ArticleTag.
     * @param {ArticleTagUpdateArgs} args - Arguments to update one ArticleTag.
     * @example
     * // Update one ArticleTag
     * const articleTag = await prisma.articleTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArticleTagUpdateArgs>(args: SelectSubset<T, ArticleTagUpdateArgs<ExtArgs>>): Prisma__ArticleTagClient<$Result.GetResult<Prisma.$ArticleTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ArticleTags.
     * @param {ArticleTagDeleteManyArgs} args - Arguments to filter ArticleTags to delete.
     * @example
     * // Delete a few ArticleTags
     * const { count } = await prisma.articleTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArticleTagDeleteManyArgs>(args?: SelectSubset<T, ArticleTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArticleTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ArticleTags
     * const articleTag = await prisma.articleTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArticleTagUpdateManyArgs>(args: SelectSubset<T, ArticleTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArticleTags and returns the data updated in the database.
     * @param {ArticleTagUpdateManyAndReturnArgs} args - Arguments to update many ArticleTags.
     * @example
     * // Update many ArticleTags
     * const articleTag = await prisma.articleTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ArticleTags and only return the `articleId`
     * const articleTagWithArticleIdOnly = await prisma.articleTag.updateManyAndReturn({
     *   select: { articleId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ArticleTagUpdateManyAndReturnArgs>(args: SelectSubset<T, ArticleTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticleTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ArticleTag.
     * @param {ArticleTagUpsertArgs} args - Arguments to update or create a ArticleTag.
     * @example
     * // Update or create a ArticleTag
     * const articleTag = await prisma.articleTag.upsert({
     *   create: {
     *     // ... data to create a ArticleTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ArticleTag we want to update
     *   }
     * })
     */
    upsert<T extends ArticleTagUpsertArgs>(args: SelectSubset<T, ArticleTagUpsertArgs<ExtArgs>>): Prisma__ArticleTagClient<$Result.GetResult<Prisma.$ArticleTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ArticleTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleTagCountArgs} args - Arguments to filter ArticleTags to count.
     * @example
     * // Count the number of ArticleTags
     * const count = await prisma.articleTag.count({
     *   where: {
     *     // ... the filter for the ArticleTags we want to count
     *   }
     * })
    **/
    count<T extends ArticleTagCountArgs>(
      args?: Subset<T, ArticleTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArticleTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ArticleTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArticleTagAggregateArgs>(args: Subset<T, ArticleTagAggregateArgs>): Prisma.PrismaPromise<GetArticleTagAggregateType<T>>

    /**
     * Group by ArticleTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArticleTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArticleTagGroupByArgs['orderBy'] }
        : { orderBy?: ArticleTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArticleTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArticleTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ArticleTag model
   */
  readonly fields: ArticleTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ArticleTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArticleTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    article<T extends ArticleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArticleDefaultArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ArticleTag model
   */
  interface ArticleTagFieldRefs {
    readonly articleId: FieldRef<"ArticleTag", 'String'>
    readonly tagId: FieldRef<"ArticleTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ArticleTag findUnique
   */
  export type ArticleTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleTag
     */
    select?: ArticleTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleTag
     */
    omit?: ArticleTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleTagInclude<ExtArgs> | null
    /**
     * Filter, which ArticleTag to fetch.
     */
    where: ArticleTagWhereUniqueInput
  }

  /**
   * ArticleTag findUniqueOrThrow
   */
  export type ArticleTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleTag
     */
    select?: ArticleTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleTag
     */
    omit?: ArticleTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleTagInclude<ExtArgs> | null
    /**
     * Filter, which ArticleTag to fetch.
     */
    where: ArticleTagWhereUniqueInput
  }

  /**
   * ArticleTag findFirst
   */
  export type ArticleTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleTag
     */
    select?: ArticleTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleTag
     */
    omit?: ArticleTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleTagInclude<ExtArgs> | null
    /**
     * Filter, which ArticleTag to fetch.
     */
    where?: ArticleTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleTags to fetch.
     */
    orderBy?: ArticleTagOrderByWithRelationInput | ArticleTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArticleTags.
     */
    cursor?: ArticleTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArticleTags.
     */
    distinct?: ArticleTagScalarFieldEnum | ArticleTagScalarFieldEnum[]
  }

  /**
   * ArticleTag findFirstOrThrow
   */
  export type ArticleTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleTag
     */
    select?: ArticleTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleTag
     */
    omit?: ArticleTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleTagInclude<ExtArgs> | null
    /**
     * Filter, which ArticleTag to fetch.
     */
    where?: ArticleTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleTags to fetch.
     */
    orderBy?: ArticleTagOrderByWithRelationInput | ArticleTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArticleTags.
     */
    cursor?: ArticleTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArticleTags.
     */
    distinct?: ArticleTagScalarFieldEnum | ArticleTagScalarFieldEnum[]
  }

  /**
   * ArticleTag findMany
   */
  export type ArticleTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleTag
     */
    select?: ArticleTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleTag
     */
    omit?: ArticleTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleTagInclude<ExtArgs> | null
    /**
     * Filter, which ArticleTags to fetch.
     */
    where?: ArticleTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleTags to fetch.
     */
    orderBy?: ArticleTagOrderByWithRelationInput | ArticleTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ArticleTags.
     */
    cursor?: ArticleTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleTags.
     */
    skip?: number
    distinct?: ArticleTagScalarFieldEnum | ArticleTagScalarFieldEnum[]
  }

  /**
   * ArticleTag create
   */
  export type ArticleTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleTag
     */
    select?: ArticleTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleTag
     */
    omit?: ArticleTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleTagInclude<ExtArgs> | null
    /**
     * The data needed to create a ArticleTag.
     */
    data: XOR<ArticleTagCreateInput, ArticleTagUncheckedCreateInput>
  }

  /**
   * ArticleTag createMany
   */
  export type ArticleTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ArticleTags.
     */
    data: ArticleTagCreateManyInput | ArticleTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ArticleTag createManyAndReturn
   */
  export type ArticleTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleTag
     */
    select?: ArticleTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleTag
     */
    omit?: ArticleTagOmit<ExtArgs> | null
    /**
     * The data used to create many ArticleTags.
     */
    data: ArticleTagCreateManyInput | ArticleTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ArticleTag update
   */
  export type ArticleTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleTag
     */
    select?: ArticleTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleTag
     */
    omit?: ArticleTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleTagInclude<ExtArgs> | null
    /**
     * The data needed to update a ArticleTag.
     */
    data: XOR<ArticleTagUpdateInput, ArticleTagUncheckedUpdateInput>
    /**
     * Choose, which ArticleTag to update.
     */
    where: ArticleTagWhereUniqueInput
  }

  /**
   * ArticleTag updateMany
   */
  export type ArticleTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ArticleTags.
     */
    data: XOR<ArticleTagUpdateManyMutationInput, ArticleTagUncheckedUpdateManyInput>
    /**
     * Filter which ArticleTags to update
     */
    where?: ArticleTagWhereInput
    /**
     * Limit how many ArticleTags to update.
     */
    limit?: number
  }

  /**
   * ArticleTag updateManyAndReturn
   */
  export type ArticleTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleTag
     */
    select?: ArticleTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleTag
     */
    omit?: ArticleTagOmit<ExtArgs> | null
    /**
     * The data used to update ArticleTags.
     */
    data: XOR<ArticleTagUpdateManyMutationInput, ArticleTagUncheckedUpdateManyInput>
    /**
     * Filter which ArticleTags to update
     */
    where?: ArticleTagWhereInput
    /**
     * Limit how many ArticleTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ArticleTag upsert
   */
  export type ArticleTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleTag
     */
    select?: ArticleTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleTag
     */
    omit?: ArticleTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleTagInclude<ExtArgs> | null
    /**
     * The filter to search for the ArticleTag to update in case it exists.
     */
    where: ArticleTagWhereUniqueInput
    /**
     * In case the ArticleTag found by the `where` argument doesn't exist, create a new ArticleTag with this data.
     */
    create: XOR<ArticleTagCreateInput, ArticleTagUncheckedCreateInput>
    /**
     * In case the ArticleTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArticleTagUpdateInput, ArticleTagUncheckedUpdateInput>
  }

  /**
   * ArticleTag delete
   */
  export type ArticleTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleTag
     */
    select?: ArticleTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleTag
     */
    omit?: ArticleTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleTagInclude<ExtArgs> | null
    /**
     * Filter which ArticleTag to delete.
     */
    where: ArticleTagWhereUniqueInput
  }

  /**
   * ArticleTag deleteMany
   */
  export type ArticleTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArticleTags to delete
     */
    where?: ArticleTagWhereInput
    /**
     * Limit how many ArticleTags to delete.
     */
    limit?: number
  }

  /**
   * ArticleTag without action
   */
  export type ArticleTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleTag
     */
    select?: ArticleTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleTag
     */
    omit?: ArticleTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleTagInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    content: string | null
    parentId: string | null
    isApproved: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    articleId: string | null
    userId: string | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    content: string | null
    parentId: string | null
    isApproved: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    articleId: string | null
    userId: string | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    content: number
    parentId: number
    isApproved: number
    createdAt: number
    updatedAt: number
    articleId: number
    userId: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    content?: true
    parentId?: true
    isApproved?: true
    createdAt?: true
    updatedAt?: true
    articleId?: true
    userId?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    content?: true
    parentId?: true
    isApproved?: true
    createdAt?: true
    updatedAt?: true
    articleId?: true
    userId?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    content?: true
    parentId?: true
    isApproved?: true
    createdAt?: true
    updatedAt?: true
    articleId?: true
    userId?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    content: string
    parentId: string | null
    isApproved: boolean
    createdAt: Date
    updatedAt: Date
    articleId: string
    userId: string | null
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    parentId?: boolean
    isApproved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    articleId?: boolean
    userId?: boolean
    parent?: boolean | Comment$parentArgs<ExtArgs>
    children?: boolean | Comment$childrenArgs<ExtArgs>
    article?: boolean | ArticleDefaultArgs<ExtArgs>
    user?: boolean | Comment$userArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    parentId?: boolean
    isApproved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    articleId?: boolean
    userId?: boolean
    parent?: boolean | Comment$parentArgs<ExtArgs>
    article?: boolean | ArticleDefaultArgs<ExtArgs>
    user?: boolean | Comment$userArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    parentId?: boolean
    isApproved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    articleId?: boolean
    userId?: boolean
    parent?: boolean | Comment$parentArgs<ExtArgs>
    article?: boolean | ArticleDefaultArgs<ExtArgs>
    user?: boolean | Comment$userArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    content?: boolean
    parentId?: boolean
    isApproved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    articleId?: boolean
    userId?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "parentId" | "isApproved" | "createdAt" | "updatedAt" | "articleId" | "userId", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Comment$parentArgs<ExtArgs>
    children?: boolean | Comment$childrenArgs<ExtArgs>
    article?: boolean | ArticleDefaultArgs<ExtArgs>
    user?: boolean | Comment$userArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Comment$parentArgs<ExtArgs>
    article?: boolean | ArticleDefaultArgs<ExtArgs>
    user?: boolean | Comment$userArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Comment$parentArgs<ExtArgs>
    article?: boolean | ArticleDefaultArgs<ExtArgs>
    user?: boolean | Comment$userArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      parent: Prisma.$CommentPayload<ExtArgs> | null
      children: Prisma.$CommentPayload<ExtArgs>[]
      article: Prisma.$ArticlePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      parentId: string | null
      isApproved: boolean
      createdAt: Date
      updatedAt: Date
      articleId: string
      userId: string | null
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends Comment$parentArgs<ExtArgs> = {}>(args?: Subset<T, Comment$parentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Comment$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Comment$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    article<T extends ArticleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArticleDefaultArgs<ExtArgs>>): Prisma__ArticleClient<$Result.GetResult<Prisma.$ArticlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends Comment$userArgs<ExtArgs> = {}>(args?: Subset<T, Comment$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly parentId: FieldRef<"Comment", 'String'>
    readonly isApproved: FieldRef<"Comment", 'Boolean'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
    readonly articleId: FieldRef<"Comment", 'String'>
    readonly userId: FieldRef<"Comment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment.parent
   */
  export type Comment$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Comment.children
   */
  export type Comment$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment.user
   */
  export type Comment$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    characterName: 'characterName',
    subname: 'subname',
    bio: 'bio',
    birthday: 'birthday',
    gender: 'gender',
    iconUrl: 'iconUrl',
    bannerUrl: 'bannerUrl',
    handle: 'handle',
    handleChangeCount: 'handleChangeCount',
    handleChangeTokens: 'handleChangeTokens',
    isPremiumUser: 'isPremiumUser',
    role: 'role',
    subscriptionStatus: 'subscriptionStatus',
    emailVerified: 'emailVerified',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const NotificationSettingsScalarFieldEnum: {
    id: 'id',
    pushNotifications: 'pushNotifications',
    userId: 'userId'
  };

  export type NotificationSettingsScalarFieldEnum = (typeof NotificationSettingsScalarFieldEnum)[keyof typeof NotificationSettingsScalarFieldEnum]


  export const UserLinkScalarFieldEnum: {
    id: 'id',
    url: 'url',
    title: 'title',
    description: 'description',
    sortOrder: 'sortOrder',
    isActive: 'isActive',
    useOriginalIcon: 'useOriginalIcon',
    originalIconUrl: 'originalIconUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    serviceId: 'serviceId',
    iconId: 'iconId'
  };

  export type UserLinkScalarFieldEnum = (typeof UserLinkScalarFieldEnum)[keyof typeof UserLinkScalarFieldEnum]


  export const UserYoutubeSettingsScalarFieldEnum: {
    id: 'id',
    channelId: 'channelId',
    displayCount: 'displayCount',
    lastFetchedAt: 'lastFetchedAt',
    pickupVideo: 'pickupVideo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type UserYoutubeSettingsScalarFieldEnum = (typeof UserYoutubeSettingsScalarFieldEnum)[keyof typeof UserYoutubeSettingsScalarFieldEnum]


  export const UserImageBannerScalarFieldEnum: {
    id: 'id',
    url: 'url',
    imgUrl: 'imgUrl',
    alt: 'alt',
    sortOrder: 'sortOrder',
    userId: 'userId'
  };

  export type UserImageBannerScalarFieldEnum = (typeof UserImageBannerScalarFieldEnum)[keyof typeof UserImageBannerScalarFieldEnum]


  export const UserYoutubeVideoScalarFieldEnum: {
    id: 'id',
    url: 'url',
    thumbnailUrl: 'thumbnailUrl',
    title: 'title',
    description: 'description',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    settingsId: 'settingsId'
  };

  export type UserYoutubeVideoScalarFieldEnum = (typeof UserYoutubeVideoScalarFieldEnum)[keyof typeof UserYoutubeVideoScalarFieldEnum]


  export const UserRecommendYoutubeScalarFieldEnum: {
    id: 'id',
    url: 'url',
    thumbnailUrl: 'thumbnailUrl',
    title: 'title',
    description: 'description',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type UserRecommendYoutubeScalarFieldEnum = (typeof UserRecommendYoutubeScalarFieldEnum)[keyof typeof UserRecommendYoutubeScalarFieldEnum]


  export const UserPopupSettingsScalarFieldEnum: {
    id: 'id',
    bellTitle: 'bellTitle',
    bellText: 'bellText',
    bellImageUrl: 'bellImageUrl',
    bellUrl: 'bellUrl',
    bellLastUpdated: 'bellLastUpdated',
    emailTitle: 'emailTitle',
    emailText: 'emailText',
    popup1ImageUrl: 'popup1ImageUrl',
    popup1Url: 'popup1Url',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type UserPopupSettingsScalarFieldEnum = (typeof UserPopupSettingsScalarFieldEnum)[keyof typeof UserPopupSettingsScalarFieldEnum]


  export const UserOGPScalarFieldEnum: {
    id: 'id',
    imgUrl: 'imgUrl',
    title: 'title',
    description: 'description',
    userId: 'userId'
  };

  export type UserOGPScalarFieldEnum = (typeof UserOGPScalarFieldEnum)[keyof typeof UserOGPScalarFieldEnum]


  export const UserCustomQuestionScalarFieldEnum: {
    id: 'id',
    question: 'question',
    answer: 'answer',
    sortOrder: 'sortOrder',
    userId: 'userId'
  };

  export type UserCustomQuestionScalarFieldEnum = (typeof UserCustomQuestionScalarFieldEnum)[keyof typeof UserCustomQuestionScalarFieldEnum]


  export const UserImageCarouselScalarFieldEnum: {
    id: 'id',
    url: 'url',
    imgUrl: 'imgUrl',
    alt: 'alt',
    sortOrder: 'sortOrder',
    userId: 'userId'
  };

  export type UserImageCarouselScalarFieldEnum = (typeof UserImageCarouselScalarFieldEnum)[keyof typeof UserImageCarouselScalarFieldEnum]


  export const UserImageSidebarScalarFieldEnum: {
    id: 'id',
    url: 'url',
    imgUrl: 'imgUrl',
    alt: 'alt',
    sortOrder: 'sortOrder',
    userId: 'userId'
  };

  export type UserImageSidebarScalarFieldEnum = (typeof UserImageSidebarScalarFieldEnum)[keyof typeof UserImageSidebarScalarFieldEnum]


  export const UserDisplaySettingsScalarFieldEnum: {
    id: 'id',
    displayYoutube: 'displayYoutube',
    displayDevice: 'displayDevice',
    displayFaq: 'displayFaq',
    displayPopup1: 'displayPopup1',
    displayPopupBell: 'displayPopupBell',
    displayPopupEmail: 'displayPopupEmail',
    displayUserList: 'displayUserList',
    displayOwnPage: 'displayOwnPage',
    userId: 'userId'
  };

  export type UserDisplaySettingsScalarFieldEnum = (typeof UserDisplaySettingsScalarFieldEnum)[keyof typeof UserDisplaySettingsScalarFieldEnum]


  export const LinkServiceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    baseUrl: 'baseUrl',
    allowOriginalIcon: 'allowOriginalIcon',
    isActive: 'isActive',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LinkServiceScalarFieldEnum = (typeof LinkServiceScalarFieldEnum)[keyof typeof LinkServiceScalarFieldEnum]


  export const ServiceIconScalarFieldEnum: {
    id: 'id',
    name: 'name',
    fileName: 'fileName',
    filePath: 'filePath',
    style: 'style',
    colorScheme: 'colorScheme',
    description: 'description',
    isActive: 'isActive',
    sortOrder: 'sortOrder',
    uploadedBy: 'uploadedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    serviceId: 'serviceId'
  };

  export type ServiceIconScalarFieldEnum = (typeof ServiceIconScalarFieldEnum)[keyof typeof ServiceIconScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const AuthorScalarFieldEnum: {
    id: 'id',
    bio: 'bio',
    profileImage: 'profileImage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type AuthorScalarFieldEnum = (typeof AuthorScalarFieldEnum)[keyof typeof AuthorScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    parentId: 'parentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const ArticleScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    content: 'content',
    excerpt: 'excerpt',
    featuredImage: 'featuredImage',
    status: 'status',
    viewCount: 'viewCount',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    authorId: 'authorId'
  };

  export type ArticleScalarFieldEnum = (typeof ArticleScalarFieldEnum)[keyof typeof ArticleScalarFieldEnum]


  export const ArticleCategoryScalarFieldEnum: {
    articleId: 'articleId',
    categoryId: 'categoryId'
  };

  export type ArticleCategoryScalarFieldEnum = (typeof ArticleCategoryScalarFieldEnum)[keyof typeof ArticleCategoryScalarFieldEnum]


  export const ArticleTagScalarFieldEnum: {
    articleId: 'articleId',
    tagId: 'tagId'
  };

  export type ArticleTagScalarFieldEnum = (typeof ArticleTagScalarFieldEnum)[keyof typeof ArticleTagScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    parentId: 'parentId',
    isApproved: 'isApproved',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    articleId: 'articleId',
    userId: 'userId'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'IconStyle'
   */
  export type EnumIconStyleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IconStyle'>
    


  /**
   * Reference to a field of type 'IconStyle[]'
   */
  export type ListEnumIconStyleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IconStyle[]'>
    


  /**
   * Reference to a field of type 'IconColor'
   */
  export type EnumIconColorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IconColor'>
    


  /**
   * Reference to a field of type 'IconColor[]'
   */
  export type ListEnumIconColorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IconColor[]'>
    


  /**
   * Reference to a field of type 'ArticleStatus'
   */
  export type EnumArticleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ArticleStatus'>
    


  /**
   * Reference to a field of type 'ArticleStatus[]'
   */
  export type ListEnumArticleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ArticleStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    characterName?: StringNullableFilter<"User"> | string | null
    subname?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    birthday?: DateTimeNullableFilter<"User"> | Date | string | null
    gender?: StringNullableFilter<"User"> | string | null
    iconUrl?: StringNullableFilter<"User"> | string | null
    bannerUrl?: StringNullableFilter<"User"> | string | null
    handle?: StringNullableFilter<"User"> | string | null
    handleChangeCount?: IntFilter<"User"> | number
    handleChangeTokens?: IntFilter<"User"> | number
    isPremiumUser?: BoolFilter<"User"> | boolean
    role?: StringFilter<"User"> | string
    subscriptionStatus?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    ogp?: XOR<UserOGPNullableScalarRelationFilter, UserOGPWhereInput> | null
    links?: UserLinkListRelationFilter
    imageBanners?: UserImageBannerListRelationFilter
    imageCarousels?: UserImageCarouselListRelationFilter
    imageSidebars?: UserImageSidebarListRelationFilter
    customQuestions?: UserCustomQuestionListRelationFilter
    youtubeSettings?: XOR<UserYoutubeSettingsNullableScalarRelationFilter, UserYoutubeSettingsWhereInput> | null
    recommendYoutubes?: UserRecommendYoutubeListRelationFilter
    popupSettings?: XOR<UserPopupSettingsNullableScalarRelationFilter, UserPopupSettingsWhereInput> | null
    displaySettings?: XOR<UserDisplaySettingsNullableScalarRelationFilter, UserDisplaySettingsWhereInput> | null
    notificationSettings?: XOR<NotificationSettingsNullableScalarRelationFilter, NotificationSettingsWhereInput> | null
    author?: XOR<AuthorNullableScalarRelationFilter, AuthorWhereInput> | null
    comments?: CommentListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    characterName?: SortOrderInput | SortOrder
    subname?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    birthday?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    iconUrl?: SortOrderInput | SortOrder
    bannerUrl?: SortOrderInput | SortOrder
    handle?: SortOrderInput | SortOrder
    handleChangeCount?: SortOrder
    handleChangeTokens?: SortOrder
    isPremiumUser?: SortOrder
    role?: SortOrder
    subscriptionStatus?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    ogp?: UserOGPOrderByWithRelationInput
    links?: UserLinkOrderByRelationAggregateInput
    imageBanners?: UserImageBannerOrderByRelationAggregateInput
    imageCarousels?: UserImageCarouselOrderByRelationAggregateInput
    imageSidebars?: UserImageSidebarOrderByRelationAggregateInput
    customQuestions?: UserCustomQuestionOrderByRelationAggregateInput
    youtubeSettings?: UserYoutubeSettingsOrderByWithRelationInput
    recommendYoutubes?: UserRecommendYoutubeOrderByRelationAggregateInput
    popupSettings?: UserPopupSettingsOrderByWithRelationInput
    displaySettings?: UserDisplaySettingsOrderByWithRelationInput
    notificationSettings?: NotificationSettingsOrderByWithRelationInput
    author?: AuthorOrderByWithRelationInput
    comments?: CommentOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    handle?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    characterName?: StringNullableFilter<"User"> | string | null
    subname?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    birthday?: DateTimeNullableFilter<"User"> | Date | string | null
    gender?: StringNullableFilter<"User"> | string | null
    iconUrl?: StringNullableFilter<"User"> | string | null
    bannerUrl?: StringNullableFilter<"User"> | string | null
    handleChangeCount?: IntFilter<"User"> | number
    handleChangeTokens?: IntFilter<"User"> | number
    isPremiumUser?: BoolFilter<"User"> | boolean
    role?: StringFilter<"User"> | string
    subscriptionStatus?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    ogp?: XOR<UserOGPNullableScalarRelationFilter, UserOGPWhereInput> | null
    links?: UserLinkListRelationFilter
    imageBanners?: UserImageBannerListRelationFilter
    imageCarousels?: UserImageCarouselListRelationFilter
    imageSidebars?: UserImageSidebarListRelationFilter
    customQuestions?: UserCustomQuestionListRelationFilter
    youtubeSettings?: XOR<UserYoutubeSettingsNullableScalarRelationFilter, UserYoutubeSettingsWhereInput> | null
    recommendYoutubes?: UserRecommendYoutubeListRelationFilter
    popupSettings?: XOR<UserPopupSettingsNullableScalarRelationFilter, UserPopupSettingsWhereInput> | null
    displaySettings?: XOR<UserDisplaySettingsNullableScalarRelationFilter, UserDisplaySettingsWhereInput> | null
    notificationSettings?: XOR<NotificationSettingsNullableScalarRelationFilter, NotificationSettingsWhereInput> | null
    author?: XOR<AuthorNullableScalarRelationFilter, AuthorWhereInput> | null
    comments?: CommentListRelationFilter
  }, "id" | "email" | "handle">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    characterName?: SortOrderInput | SortOrder
    subname?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    birthday?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    iconUrl?: SortOrderInput | SortOrder
    bannerUrl?: SortOrderInput | SortOrder
    handle?: SortOrderInput | SortOrder
    handleChangeCount?: SortOrder
    handleChangeTokens?: SortOrder
    isPremiumUser?: SortOrder
    role?: SortOrder
    subscriptionStatus?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    characterName?: StringNullableWithAggregatesFilter<"User"> | string | null
    subname?: StringNullableWithAggregatesFilter<"User"> | string | null
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    birthday?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    gender?: StringNullableWithAggregatesFilter<"User"> | string | null
    iconUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    bannerUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    handle?: StringNullableWithAggregatesFilter<"User"> | string | null
    handleChangeCount?: IntWithAggregatesFilter<"User"> | number
    handleChangeTokens?: IntWithAggregatesFilter<"User"> | number
    isPremiumUser?: BoolWithAggregatesFilter<"User"> | boolean
    role?: StringWithAggregatesFilter<"User"> | string
    subscriptionStatus?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type NotificationSettingsWhereInput = {
    AND?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    OR?: NotificationSettingsWhereInput[]
    NOT?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    id?: StringFilter<"NotificationSettings"> | string
    pushNotifications?: BoolFilter<"NotificationSettings"> | boolean
    userId?: StringFilter<"NotificationSettings"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationSettingsOrderByWithRelationInput = {
    id?: SortOrder
    pushNotifications?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    OR?: NotificationSettingsWhereInput[]
    NOT?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    pushNotifications?: BoolFilter<"NotificationSettings"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type NotificationSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    pushNotifications?: SortOrder
    userId?: SortOrder
    _count?: NotificationSettingsCountOrderByAggregateInput
    _max?: NotificationSettingsMaxOrderByAggregateInput
    _min?: NotificationSettingsMinOrderByAggregateInput
  }

  export type NotificationSettingsScalarWhereWithAggregatesInput = {
    AND?: NotificationSettingsScalarWhereWithAggregatesInput | NotificationSettingsScalarWhereWithAggregatesInput[]
    OR?: NotificationSettingsScalarWhereWithAggregatesInput[]
    NOT?: NotificationSettingsScalarWhereWithAggregatesInput | NotificationSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationSettings"> | string
    pushNotifications?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
    userId?: StringWithAggregatesFilter<"NotificationSettings"> | string
  }

  export type UserLinkWhereInput = {
    AND?: UserLinkWhereInput | UserLinkWhereInput[]
    OR?: UserLinkWhereInput[]
    NOT?: UserLinkWhereInput | UserLinkWhereInput[]
    id?: StringFilter<"UserLink"> | string
    url?: StringFilter<"UserLink"> | string
    title?: StringNullableFilter<"UserLink"> | string | null
    description?: StringNullableFilter<"UserLink"> | string | null
    sortOrder?: IntFilter<"UserLink"> | number
    isActive?: BoolFilter<"UserLink"> | boolean
    useOriginalIcon?: BoolFilter<"UserLink"> | boolean
    originalIconUrl?: StringNullableFilter<"UserLink"> | string | null
    createdAt?: DateTimeFilter<"UserLink"> | Date | string
    updatedAt?: DateTimeFilter<"UserLink"> | Date | string
    userId?: StringFilter<"UserLink"> | string
    serviceId?: StringFilter<"UserLink"> | string
    iconId?: StringNullableFilter<"UserLink"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    service?: XOR<LinkServiceScalarRelationFilter, LinkServiceWhereInput>
    icon?: XOR<ServiceIconNullableScalarRelationFilter, ServiceIconWhereInput> | null
  }

  export type UserLinkOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    useOriginalIcon?: SortOrder
    originalIconUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    iconId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    service?: LinkServiceOrderByWithRelationInput
    icon?: ServiceIconOrderByWithRelationInput
  }

  export type UserLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserLinkWhereInput | UserLinkWhereInput[]
    OR?: UserLinkWhereInput[]
    NOT?: UserLinkWhereInput | UserLinkWhereInput[]
    url?: StringFilter<"UserLink"> | string
    title?: StringNullableFilter<"UserLink"> | string | null
    description?: StringNullableFilter<"UserLink"> | string | null
    sortOrder?: IntFilter<"UserLink"> | number
    isActive?: BoolFilter<"UserLink"> | boolean
    useOriginalIcon?: BoolFilter<"UserLink"> | boolean
    originalIconUrl?: StringNullableFilter<"UserLink"> | string | null
    createdAt?: DateTimeFilter<"UserLink"> | Date | string
    updatedAt?: DateTimeFilter<"UserLink"> | Date | string
    userId?: StringFilter<"UserLink"> | string
    serviceId?: StringFilter<"UserLink"> | string
    iconId?: StringNullableFilter<"UserLink"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    service?: XOR<LinkServiceScalarRelationFilter, LinkServiceWhereInput>
    icon?: XOR<ServiceIconNullableScalarRelationFilter, ServiceIconWhereInput> | null
  }, "id">

  export type UserLinkOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    useOriginalIcon?: SortOrder
    originalIconUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    iconId?: SortOrderInput | SortOrder
    _count?: UserLinkCountOrderByAggregateInput
    _avg?: UserLinkAvgOrderByAggregateInput
    _max?: UserLinkMaxOrderByAggregateInput
    _min?: UserLinkMinOrderByAggregateInput
    _sum?: UserLinkSumOrderByAggregateInput
  }

  export type UserLinkScalarWhereWithAggregatesInput = {
    AND?: UserLinkScalarWhereWithAggregatesInput | UserLinkScalarWhereWithAggregatesInput[]
    OR?: UserLinkScalarWhereWithAggregatesInput[]
    NOT?: UserLinkScalarWhereWithAggregatesInput | UserLinkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserLink"> | string
    url?: StringWithAggregatesFilter<"UserLink"> | string
    title?: StringNullableWithAggregatesFilter<"UserLink"> | string | null
    description?: StringNullableWithAggregatesFilter<"UserLink"> | string | null
    sortOrder?: IntWithAggregatesFilter<"UserLink"> | number
    isActive?: BoolWithAggregatesFilter<"UserLink"> | boolean
    useOriginalIcon?: BoolWithAggregatesFilter<"UserLink"> | boolean
    originalIconUrl?: StringNullableWithAggregatesFilter<"UserLink"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserLink"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserLink"> | Date | string
    userId?: StringWithAggregatesFilter<"UserLink"> | string
    serviceId?: StringWithAggregatesFilter<"UserLink"> | string
    iconId?: StringNullableWithAggregatesFilter<"UserLink"> | string | null
  }

  export type UserYoutubeSettingsWhereInput = {
    AND?: UserYoutubeSettingsWhereInput | UserYoutubeSettingsWhereInput[]
    OR?: UserYoutubeSettingsWhereInput[]
    NOT?: UserYoutubeSettingsWhereInput | UserYoutubeSettingsWhereInput[]
    id?: StringFilter<"UserYoutubeSettings"> | string
    channelId?: StringNullableFilter<"UserYoutubeSettings"> | string | null
    displayCount?: IntFilter<"UserYoutubeSettings"> | number
    lastFetchedAt?: DateTimeNullableFilter<"UserYoutubeSettings"> | Date | string | null
    pickupVideo?: StringNullableFilter<"UserYoutubeSettings"> | string | null
    createdAt?: DateTimeFilter<"UserYoutubeSettings"> | Date | string
    updatedAt?: DateTimeFilter<"UserYoutubeSettings"> | Date | string
    userId?: StringFilter<"UserYoutubeSettings"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    videos?: UserYoutubeVideoListRelationFilter
  }

  export type UserYoutubeSettingsOrderByWithRelationInput = {
    id?: SortOrder
    channelId?: SortOrderInput | SortOrder
    displayCount?: SortOrder
    lastFetchedAt?: SortOrderInput | SortOrder
    pickupVideo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    videos?: UserYoutubeVideoOrderByRelationAggregateInput
  }

  export type UserYoutubeSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserYoutubeSettingsWhereInput | UserYoutubeSettingsWhereInput[]
    OR?: UserYoutubeSettingsWhereInput[]
    NOT?: UserYoutubeSettingsWhereInput | UserYoutubeSettingsWhereInput[]
    channelId?: StringNullableFilter<"UserYoutubeSettings"> | string | null
    displayCount?: IntFilter<"UserYoutubeSettings"> | number
    lastFetchedAt?: DateTimeNullableFilter<"UserYoutubeSettings"> | Date | string | null
    pickupVideo?: StringNullableFilter<"UserYoutubeSettings"> | string | null
    createdAt?: DateTimeFilter<"UserYoutubeSettings"> | Date | string
    updatedAt?: DateTimeFilter<"UserYoutubeSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    videos?: UserYoutubeVideoListRelationFilter
  }, "id" | "userId">

  export type UserYoutubeSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    channelId?: SortOrderInput | SortOrder
    displayCount?: SortOrder
    lastFetchedAt?: SortOrderInput | SortOrder
    pickupVideo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    _count?: UserYoutubeSettingsCountOrderByAggregateInput
    _avg?: UserYoutubeSettingsAvgOrderByAggregateInput
    _max?: UserYoutubeSettingsMaxOrderByAggregateInput
    _min?: UserYoutubeSettingsMinOrderByAggregateInput
    _sum?: UserYoutubeSettingsSumOrderByAggregateInput
  }

  export type UserYoutubeSettingsScalarWhereWithAggregatesInput = {
    AND?: UserYoutubeSettingsScalarWhereWithAggregatesInput | UserYoutubeSettingsScalarWhereWithAggregatesInput[]
    OR?: UserYoutubeSettingsScalarWhereWithAggregatesInput[]
    NOT?: UserYoutubeSettingsScalarWhereWithAggregatesInput | UserYoutubeSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserYoutubeSettings"> | string
    channelId?: StringNullableWithAggregatesFilter<"UserYoutubeSettings"> | string | null
    displayCount?: IntWithAggregatesFilter<"UserYoutubeSettings"> | number
    lastFetchedAt?: DateTimeNullableWithAggregatesFilter<"UserYoutubeSettings"> | Date | string | null
    pickupVideo?: StringNullableWithAggregatesFilter<"UserYoutubeSettings"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserYoutubeSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserYoutubeSettings"> | Date | string
    userId?: StringWithAggregatesFilter<"UserYoutubeSettings"> | string
  }

  export type UserImageBannerWhereInput = {
    AND?: UserImageBannerWhereInput | UserImageBannerWhereInput[]
    OR?: UserImageBannerWhereInput[]
    NOT?: UserImageBannerWhereInput | UserImageBannerWhereInput[]
    id?: StringFilter<"UserImageBanner"> | string
    url?: StringNullableFilter<"UserImageBanner"> | string | null
    imgUrl?: StringFilter<"UserImageBanner"> | string
    alt?: StringNullableFilter<"UserImageBanner"> | string | null
    sortOrder?: IntFilter<"UserImageBanner"> | number
    userId?: StringFilter<"UserImageBanner"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserImageBannerOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrderInput | SortOrder
    imgUrl?: SortOrder
    alt?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserImageBannerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserImageBannerWhereInput | UserImageBannerWhereInput[]
    OR?: UserImageBannerWhereInput[]
    NOT?: UserImageBannerWhereInput | UserImageBannerWhereInput[]
    url?: StringNullableFilter<"UserImageBanner"> | string | null
    imgUrl?: StringFilter<"UserImageBanner"> | string
    alt?: StringNullableFilter<"UserImageBanner"> | string | null
    sortOrder?: IntFilter<"UserImageBanner"> | number
    userId?: StringFilter<"UserImageBanner"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserImageBannerOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrderInput | SortOrder
    imgUrl?: SortOrder
    alt?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    userId?: SortOrder
    _count?: UserImageBannerCountOrderByAggregateInput
    _avg?: UserImageBannerAvgOrderByAggregateInput
    _max?: UserImageBannerMaxOrderByAggregateInput
    _min?: UserImageBannerMinOrderByAggregateInput
    _sum?: UserImageBannerSumOrderByAggregateInput
  }

  export type UserImageBannerScalarWhereWithAggregatesInput = {
    AND?: UserImageBannerScalarWhereWithAggregatesInput | UserImageBannerScalarWhereWithAggregatesInput[]
    OR?: UserImageBannerScalarWhereWithAggregatesInput[]
    NOT?: UserImageBannerScalarWhereWithAggregatesInput | UserImageBannerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserImageBanner"> | string
    url?: StringNullableWithAggregatesFilter<"UserImageBanner"> | string | null
    imgUrl?: StringWithAggregatesFilter<"UserImageBanner"> | string
    alt?: StringNullableWithAggregatesFilter<"UserImageBanner"> | string | null
    sortOrder?: IntWithAggregatesFilter<"UserImageBanner"> | number
    userId?: StringWithAggregatesFilter<"UserImageBanner"> | string
  }

  export type UserYoutubeVideoWhereInput = {
    AND?: UserYoutubeVideoWhereInput | UserYoutubeVideoWhereInput[]
    OR?: UserYoutubeVideoWhereInput[]
    NOT?: UserYoutubeVideoWhereInput | UserYoutubeVideoWhereInput[]
    id?: StringFilter<"UserYoutubeVideo"> | string
    url?: StringFilter<"UserYoutubeVideo"> | string
    thumbnailUrl?: StringNullableFilter<"UserYoutubeVideo"> | string | null
    title?: StringNullableFilter<"UserYoutubeVideo"> | string | null
    description?: StringNullableFilter<"UserYoutubeVideo"> | string | null
    publishedAt?: DateTimeNullableFilter<"UserYoutubeVideo"> | Date | string | null
    createdAt?: DateTimeFilter<"UserYoutubeVideo"> | Date | string
    updatedAt?: DateTimeFilter<"UserYoutubeVideo"> | Date | string
    settingsId?: StringFilter<"UserYoutubeVideo"> | string
    settings?: XOR<UserYoutubeSettingsScalarRelationFilter, UserYoutubeSettingsWhereInput>
  }

  export type UserYoutubeVideoOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    settingsId?: SortOrder
    settings?: UserYoutubeSettingsOrderByWithRelationInput
  }

  export type UserYoutubeVideoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserYoutubeVideoWhereInput | UserYoutubeVideoWhereInput[]
    OR?: UserYoutubeVideoWhereInput[]
    NOT?: UserYoutubeVideoWhereInput | UserYoutubeVideoWhereInput[]
    url?: StringFilter<"UserYoutubeVideo"> | string
    thumbnailUrl?: StringNullableFilter<"UserYoutubeVideo"> | string | null
    title?: StringNullableFilter<"UserYoutubeVideo"> | string | null
    description?: StringNullableFilter<"UserYoutubeVideo"> | string | null
    publishedAt?: DateTimeNullableFilter<"UserYoutubeVideo"> | Date | string | null
    createdAt?: DateTimeFilter<"UserYoutubeVideo"> | Date | string
    updatedAt?: DateTimeFilter<"UserYoutubeVideo"> | Date | string
    settingsId?: StringFilter<"UserYoutubeVideo"> | string
    settings?: XOR<UserYoutubeSettingsScalarRelationFilter, UserYoutubeSettingsWhereInput>
  }, "id">

  export type UserYoutubeVideoOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    settingsId?: SortOrder
    _count?: UserYoutubeVideoCountOrderByAggregateInput
    _max?: UserYoutubeVideoMaxOrderByAggregateInput
    _min?: UserYoutubeVideoMinOrderByAggregateInput
  }

  export type UserYoutubeVideoScalarWhereWithAggregatesInput = {
    AND?: UserYoutubeVideoScalarWhereWithAggregatesInput | UserYoutubeVideoScalarWhereWithAggregatesInput[]
    OR?: UserYoutubeVideoScalarWhereWithAggregatesInput[]
    NOT?: UserYoutubeVideoScalarWhereWithAggregatesInput | UserYoutubeVideoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserYoutubeVideo"> | string
    url?: StringWithAggregatesFilter<"UserYoutubeVideo"> | string
    thumbnailUrl?: StringNullableWithAggregatesFilter<"UserYoutubeVideo"> | string | null
    title?: StringNullableWithAggregatesFilter<"UserYoutubeVideo"> | string | null
    description?: StringNullableWithAggregatesFilter<"UserYoutubeVideo"> | string | null
    publishedAt?: DateTimeNullableWithAggregatesFilter<"UserYoutubeVideo"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserYoutubeVideo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserYoutubeVideo"> | Date | string
    settingsId?: StringWithAggregatesFilter<"UserYoutubeVideo"> | string
  }

  export type UserRecommendYoutubeWhereInput = {
    AND?: UserRecommendYoutubeWhereInput | UserRecommendYoutubeWhereInput[]
    OR?: UserRecommendYoutubeWhereInput[]
    NOT?: UserRecommendYoutubeWhereInput | UserRecommendYoutubeWhereInput[]
    id?: StringFilter<"UserRecommendYoutube"> | string
    url?: StringFilter<"UserRecommendYoutube"> | string
    thumbnailUrl?: StringNullableFilter<"UserRecommendYoutube"> | string | null
    title?: StringNullableFilter<"UserRecommendYoutube"> | string | null
    description?: StringNullableFilter<"UserRecommendYoutube"> | string | null
    sortOrder?: IntFilter<"UserRecommendYoutube"> | number
    createdAt?: DateTimeFilter<"UserRecommendYoutube"> | Date | string
    updatedAt?: DateTimeFilter<"UserRecommendYoutube"> | Date | string
    userId?: StringFilter<"UserRecommendYoutube"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserRecommendYoutubeOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserRecommendYoutubeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserRecommendYoutubeWhereInput | UserRecommendYoutubeWhereInput[]
    OR?: UserRecommendYoutubeWhereInput[]
    NOT?: UserRecommendYoutubeWhereInput | UserRecommendYoutubeWhereInput[]
    url?: StringFilter<"UserRecommendYoutube"> | string
    thumbnailUrl?: StringNullableFilter<"UserRecommendYoutube"> | string | null
    title?: StringNullableFilter<"UserRecommendYoutube"> | string | null
    description?: StringNullableFilter<"UserRecommendYoutube"> | string | null
    sortOrder?: IntFilter<"UserRecommendYoutube"> | number
    createdAt?: DateTimeFilter<"UserRecommendYoutube"> | Date | string
    updatedAt?: DateTimeFilter<"UserRecommendYoutube"> | Date | string
    userId?: StringFilter<"UserRecommendYoutube"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserRecommendYoutubeOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    _count?: UserRecommendYoutubeCountOrderByAggregateInput
    _avg?: UserRecommendYoutubeAvgOrderByAggregateInput
    _max?: UserRecommendYoutubeMaxOrderByAggregateInput
    _min?: UserRecommendYoutubeMinOrderByAggregateInput
    _sum?: UserRecommendYoutubeSumOrderByAggregateInput
  }

  export type UserRecommendYoutubeScalarWhereWithAggregatesInput = {
    AND?: UserRecommendYoutubeScalarWhereWithAggregatesInput | UserRecommendYoutubeScalarWhereWithAggregatesInput[]
    OR?: UserRecommendYoutubeScalarWhereWithAggregatesInput[]
    NOT?: UserRecommendYoutubeScalarWhereWithAggregatesInput | UserRecommendYoutubeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserRecommendYoutube"> | string
    url?: StringWithAggregatesFilter<"UserRecommendYoutube"> | string
    thumbnailUrl?: StringNullableWithAggregatesFilter<"UserRecommendYoutube"> | string | null
    title?: StringNullableWithAggregatesFilter<"UserRecommendYoutube"> | string | null
    description?: StringNullableWithAggregatesFilter<"UserRecommendYoutube"> | string | null
    sortOrder?: IntWithAggregatesFilter<"UserRecommendYoutube"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserRecommendYoutube"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserRecommendYoutube"> | Date | string
    userId?: StringWithAggregatesFilter<"UserRecommendYoutube"> | string
  }

  export type UserPopupSettingsWhereInput = {
    AND?: UserPopupSettingsWhereInput | UserPopupSettingsWhereInput[]
    OR?: UserPopupSettingsWhereInput[]
    NOT?: UserPopupSettingsWhereInput | UserPopupSettingsWhereInput[]
    id?: StringFilter<"UserPopupSettings"> | string
    bellTitle?: StringNullableFilter<"UserPopupSettings"> | string | null
    bellText?: StringNullableFilter<"UserPopupSettings"> | string | null
    bellImageUrl?: StringNullableFilter<"UserPopupSettings"> | string | null
    bellUrl?: StringNullableFilter<"UserPopupSettings"> | string | null
    bellLastUpdated?: DateTimeNullableFilter<"UserPopupSettings"> | Date | string | null
    emailTitle?: StringNullableFilter<"UserPopupSettings"> | string | null
    emailText?: StringNullableFilter<"UserPopupSettings"> | string | null
    popup1ImageUrl?: StringNullableFilter<"UserPopupSettings"> | string | null
    popup1Url?: StringNullableFilter<"UserPopupSettings"> | string | null
    createdAt?: DateTimeFilter<"UserPopupSettings"> | Date | string
    updatedAt?: DateTimeFilter<"UserPopupSettings"> | Date | string
    userId?: StringFilter<"UserPopupSettings"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserPopupSettingsOrderByWithRelationInput = {
    id?: SortOrder
    bellTitle?: SortOrderInput | SortOrder
    bellText?: SortOrderInput | SortOrder
    bellImageUrl?: SortOrderInput | SortOrder
    bellUrl?: SortOrderInput | SortOrder
    bellLastUpdated?: SortOrderInput | SortOrder
    emailTitle?: SortOrderInput | SortOrder
    emailText?: SortOrderInput | SortOrder
    popup1ImageUrl?: SortOrderInput | SortOrder
    popup1Url?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserPopupSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserPopupSettingsWhereInput | UserPopupSettingsWhereInput[]
    OR?: UserPopupSettingsWhereInput[]
    NOT?: UserPopupSettingsWhereInput | UserPopupSettingsWhereInput[]
    bellTitle?: StringNullableFilter<"UserPopupSettings"> | string | null
    bellText?: StringNullableFilter<"UserPopupSettings"> | string | null
    bellImageUrl?: StringNullableFilter<"UserPopupSettings"> | string | null
    bellUrl?: StringNullableFilter<"UserPopupSettings"> | string | null
    bellLastUpdated?: DateTimeNullableFilter<"UserPopupSettings"> | Date | string | null
    emailTitle?: StringNullableFilter<"UserPopupSettings"> | string | null
    emailText?: StringNullableFilter<"UserPopupSettings"> | string | null
    popup1ImageUrl?: StringNullableFilter<"UserPopupSettings"> | string | null
    popup1Url?: StringNullableFilter<"UserPopupSettings"> | string | null
    createdAt?: DateTimeFilter<"UserPopupSettings"> | Date | string
    updatedAt?: DateTimeFilter<"UserPopupSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserPopupSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    bellTitle?: SortOrderInput | SortOrder
    bellText?: SortOrderInput | SortOrder
    bellImageUrl?: SortOrderInput | SortOrder
    bellUrl?: SortOrderInput | SortOrder
    bellLastUpdated?: SortOrderInput | SortOrder
    emailTitle?: SortOrderInput | SortOrder
    emailText?: SortOrderInput | SortOrder
    popup1ImageUrl?: SortOrderInput | SortOrder
    popup1Url?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    _count?: UserPopupSettingsCountOrderByAggregateInput
    _max?: UserPopupSettingsMaxOrderByAggregateInput
    _min?: UserPopupSettingsMinOrderByAggregateInput
  }

  export type UserPopupSettingsScalarWhereWithAggregatesInput = {
    AND?: UserPopupSettingsScalarWhereWithAggregatesInput | UserPopupSettingsScalarWhereWithAggregatesInput[]
    OR?: UserPopupSettingsScalarWhereWithAggregatesInput[]
    NOT?: UserPopupSettingsScalarWhereWithAggregatesInput | UserPopupSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserPopupSettings"> | string
    bellTitle?: StringNullableWithAggregatesFilter<"UserPopupSettings"> | string | null
    bellText?: StringNullableWithAggregatesFilter<"UserPopupSettings"> | string | null
    bellImageUrl?: StringNullableWithAggregatesFilter<"UserPopupSettings"> | string | null
    bellUrl?: StringNullableWithAggregatesFilter<"UserPopupSettings"> | string | null
    bellLastUpdated?: DateTimeNullableWithAggregatesFilter<"UserPopupSettings"> | Date | string | null
    emailTitle?: StringNullableWithAggregatesFilter<"UserPopupSettings"> | string | null
    emailText?: StringNullableWithAggregatesFilter<"UserPopupSettings"> | string | null
    popup1ImageUrl?: StringNullableWithAggregatesFilter<"UserPopupSettings"> | string | null
    popup1Url?: StringNullableWithAggregatesFilter<"UserPopupSettings"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserPopupSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserPopupSettings"> | Date | string
    userId?: StringWithAggregatesFilter<"UserPopupSettings"> | string
  }

  export type UserOGPWhereInput = {
    AND?: UserOGPWhereInput | UserOGPWhereInput[]
    OR?: UserOGPWhereInput[]
    NOT?: UserOGPWhereInput | UserOGPWhereInput[]
    id?: StringFilter<"UserOGP"> | string
    imgUrl?: StringNullableFilter<"UserOGP"> | string | null
    title?: StringNullableFilter<"UserOGP"> | string | null
    description?: StringNullableFilter<"UserOGP"> | string | null
    userId?: StringFilter<"UserOGP"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserOGPOrderByWithRelationInput = {
    id?: SortOrder
    imgUrl?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserOGPWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserOGPWhereInput | UserOGPWhereInput[]
    OR?: UserOGPWhereInput[]
    NOT?: UserOGPWhereInput | UserOGPWhereInput[]
    imgUrl?: StringNullableFilter<"UserOGP"> | string | null
    title?: StringNullableFilter<"UserOGP"> | string | null
    description?: StringNullableFilter<"UserOGP"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserOGPOrderByWithAggregationInput = {
    id?: SortOrder
    imgUrl?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: UserOGPCountOrderByAggregateInput
    _max?: UserOGPMaxOrderByAggregateInput
    _min?: UserOGPMinOrderByAggregateInput
  }

  export type UserOGPScalarWhereWithAggregatesInput = {
    AND?: UserOGPScalarWhereWithAggregatesInput | UserOGPScalarWhereWithAggregatesInput[]
    OR?: UserOGPScalarWhereWithAggregatesInput[]
    NOT?: UserOGPScalarWhereWithAggregatesInput | UserOGPScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserOGP"> | string
    imgUrl?: StringNullableWithAggregatesFilter<"UserOGP"> | string | null
    title?: StringNullableWithAggregatesFilter<"UserOGP"> | string | null
    description?: StringNullableWithAggregatesFilter<"UserOGP"> | string | null
    userId?: StringWithAggregatesFilter<"UserOGP"> | string
  }

  export type UserCustomQuestionWhereInput = {
    AND?: UserCustomQuestionWhereInput | UserCustomQuestionWhereInput[]
    OR?: UserCustomQuestionWhereInput[]
    NOT?: UserCustomQuestionWhereInput | UserCustomQuestionWhereInput[]
    id?: StringFilter<"UserCustomQuestion"> | string
    question?: StringFilter<"UserCustomQuestion"> | string
    answer?: StringFilter<"UserCustomQuestion"> | string
    sortOrder?: IntFilter<"UserCustomQuestion"> | number
    userId?: StringFilter<"UserCustomQuestion"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserCustomQuestionOrderByWithRelationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    sortOrder?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserCustomQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserCustomQuestionWhereInput | UserCustomQuestionWhereInput[]
    OR?: UserCustomQuestionWhereInput[]
    NOT?: UserCustomQuestionWhereInput | UserCustomQuestionWhereInput[]
    question?: StringFilter<"UserCustomQuestion"> | string
    answer?: StringFilter<"UserCustomQuestion"> | string
    sortOrder?: IntFilter<"UserCustomQuestion"> | number
    userId?: StringFilter<"UserCustomQuestion"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserCustomQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    sortOrder?: SortOrder
    userId?: SortOrder
    _count?: UserCustomQuestionCountOrderByAggregateInput
    _avg?: UserCustomQuestionAvgOrderByAggregateInput
    _max?: UserCustomQuestionMaxOrderByAggregateInput
    _min?: UserCustomQuestionMinOrderByAggregateInput
    _sum?: UserCustomQuestionSumOrderByAggregateInput
  }

  export type UserCustomQuestionScalarWhereWithAggregatesInput = {
    AND?: UserCustomQuestionScalarWhereWithAggregatesInput | UserCustomQuestionScalarWhereWithAggregatesInput[]
    OR?: UserCustomQuestionScalarWhereWithAggregatesInput[]
    NOT?: UserCustomQuestionScalarWhereWithAggregatesInput | UserCustomQuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserCustomQuestion"> | string
    question?: StringWithAggregatesFilter<"UserCustomQuestion"> | string
    answer?: StringWithAggregatesFilter<"UserCustomQuestion"> | string
    sortOrder?: IntWithAggregatesFilter<"UserCustomQuestion"> | number
    userId?: StringWithAggregatesFilter<"UserCustomQuestion"> | string
  }

  export type UserImageCarouselWhereInput = {
    AND?: UserImageCarouselWhereInput | UserImageCarouselWhereInput[]
    OR?: UserImageCarouselWhereInput[]
    NOT?: UserImageCarouselWhereInput | UserImageCarouselWhereInput[]
    id?: StringFilter<"UserImageCarousel"> | string
    url?: StringNullableFilter<"UserImageCarousel"> | string | null
    imgUrl?: StringFilter<"UserImageCarousel"> | string
    alt?: StringNullableFilter<"UserImageCarousel"> | string | null
    sortOrder?: IntFilter<"UserImageCarousel"> | number
    userId?: StringFilter<"UserImageCarousel"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserImageCarouselOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrderInput | SortOrder
    imgUrl?: SortOrder
    alt?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserImageCarouselWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserImageCarouselWhereInput | UserImageCarouselWhereInput[]
    OR?: UserImageCarouselWhereInput[]
    NOT?: UserImageCarouselWhereInput | UserImageCarouselWhereInput[]
    url?: StringNullableFilter<"UserImageCarousel"> | string | null
    imgUrl?: StringFilter<"UserImageCarousel"> | string
    alt?: StringNullableFilter<"UserImageCarousel"> | string | null
    sortOrder?: IntFilter<"UserImageCarousel"> | number
    userId?: StringFilter<"UserImageCarousel"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserImageCarouselOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrderInput | SortOrder
    imgUrl?: SortOrder
    alt?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    userId?: SortOrder
    _count?: UserImageCarouselCountOrderByAggregateInput
    _avg?: UserImageCarouselAvgOrderByAggregateInput
    _max?: UserImageCarouselMaxOrderByAggregateInput
    _min?: UserImageCarouselMinOrderByAggregateInput
    _sum?: UserImageCarouselSumOrderByAggregateInput
  }

  export type UserImageCarouselScalarWhereWithAggregatesInput = {
    AND?: UserImageCarouselScalarWhereWithAggregatesInput | UserImageCarouselScalarWhereWithAggregatesInput[]
    OR?: UserImageCarouselScalarWhereWithAggregatesInput[]
    NOT?: UserImageCarouselScalarWhereWithAggregatesInput | UserImageCarouselScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserImageCarousel"> | string
    url?: StringNullableWithAggregatesFilter<"UserImageCarousel"> | string | null
    imgUrl?: StringWithAggregatesFilter<"UserImageCarousel"> | string
    alt?: StringNullableWithAggregatesFilter<"UserImageCarousel"> | string | null
    sortOrder?: IntWithAggregatesFilter<"UserImageCarousel"> | number
    userId?: StringWithAggregatesFilter<"UserImageCarousel"> | string
  }

  export type UserImageSidebarWhereInput = {
    AND?: UserImageSidebarWhereInput | UserImageSidebarWhereInput[]
    OR?: UserImageSidebarWhereInput[]
    NOT?: UserImageSidebarWhereInput | UserImageSidebarWhereInput[]
    id?: StringFilter<"UserImageSidebar"> | string
    url?: StringNullableFilter<"UserImageSidebar"> | string | null
    imgUrl?: StringFilter<"UserImageSidebar"> | string
    alt?: StringNullableFilter<"UserImageSidebar"> | string | null
    sortOrder?: IntFilter<"UserImageSidebar"> | number
    userId?: StringFilter<"UserImageSidebar"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserImageSidebarOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrderInput | SortOrder
    imgUrl?: SortOrder
    alt?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserImageSidebarWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserImageSidebarWhereInput | UserImageSidebarWhereInput[]
    OR?: UserImageSidebarWhereInput[]
    NOT?: UserImageSidebarWhereInput | UserImageSidebarWhereInput[]
    url?: StringNullableFilter<"UserImageSidebar"> | string | null
    imgUrl?: StringFilter<"UserImageSidebar"> | string
    alt?: StringNullableFilter<"UserImageSidebar"> | string | null
    sortOrder?: IntFilter<"UserImageSidebar"> | number
    userId?: StringFilter<"UserImageSidebar"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserImageSidebarOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrderInput | SortOrder
    imgUrl?: SortOrder
    alt?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    userId?: SortOrder
    _count?: UserImageSidebarCountOrderByAggregateInput
    _avg?: UserImageSidebarAvgOrderByAggregateInput
    _max?: UserImageSidebarMaxOrderByAggregateInput
    _min?: UserImageSidebarMinOrderByAggregateInput
    _sum?: UserImageSidebarSumOrderByAggregateInput
  }

  export type UserImageSidebarScalarWhereWithAggregatesInput = {
    AND?: UserImageSidebarScalarWhereWithAggregatesInput | UserImageSidebarScalarWhereWithAggregatesInput[]
    OR?: UserImageSidebarScalarWhereWithAggregatesInput[]
    NOT?: UserImageSidebarScalarWhereWithAggregatesInput | UserImageSidebarScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserImageSidebar"> | string
    url?: StringNullableWithAggregatesFilter<"UserImageSidebar"> | string | null
    imgUrl?: StringWithAggregatesFilter<"UserImageSidebar"> | string
    alt?: StringNullableWithAggregatesFilter<"UserImageSidebar"> | string | null
    sortOrder?: IntWithAggregatesFilter<"UserImageSidebar"> | number
    userId?: StringWithAggregatesFilter<"UserImageSidebar"> | string
  }

  export type UserDisplaySettingsWhereInput = {
    AND?: UserDisplaySettingsWhereInput | UserDisplaySettingsWhereInput[]
    OR?: UserDisplaySettingsWhereInput[]
    NOT?: UserDisplaySettingsWhereInput | UserDisplaySettingsWhereInput[]
    id?: StringFilter<"UserDisplaySettings"> | string
    displayYoutube?: BoolFilter<"UserDisplaySettings"> | boolean
    displayDevice?: BoolFilter<"UserDisplaySettings"> | boolean
    displayFaq?: BoolFilter<"UserDisplaySettings"> | boolean
    displayPopup1?: BoolFilter<"UserDisplaySettings"> | boolean
    displayPopupBell?: BoolFilter<"UserDisplaySettings"> | boolean
    displayPopupEmail?: BoolFilter<"UserDisplaySettings"> | boolean
    displayUserList?: BoolFilter<"UserDisplaySettings"> | boolean
    displayOwnPage?: BoolFilter<"UserDisplaySettings"> | boolean
    userId?: StringFilter<"UserDisplaySettings"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserDisplaySettingsOrderByWithRelationInput = {
    id?: SortOrder
    displayYoutube?: SortOrder
    displayDevice?: SortOrder
    displayFaq?: SortOrder
    displayPopup1?: SortOrder
    displayPopupBell?: SortOrder
    displayPopupEmail?: SortOrder
    displayUserList?: SortOrder
    displayOwnPage?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserDisplaySettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserDisplaySettingsWhereInput | UserDisplaySettingsWhereInput[]
    OR?: UserDisplaySettingsWhereInput[]
    NOT?: UserDisplaySettingsWhereInput | UserDisplaySettingsWhereInput[]
    displayYoutube?: BoolFilter<"UserDisplaySettings"> | boolean
    displayDevice?: BoolFilter<"UserDisplaySettings"> | boolean
    displayFaq?: BoolFilter<"UserDisplaySettings"> | boolean
    displayPopup1?: BoolFilter<"UserDisplaySettings"> | boolean
    displayPopupBell?: BoolFilter<"UserDisplaySettings"> | boolean
    displayPopupEmail?: BoolFilter<"UserDisplaySettings"> | boolean
    displayUserList?: BoolFilter<"UserDisplaySettings"> | boolean
    displayOwnPage?: BoolFilter<"UserDisplaySettings"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserDisplaySettingsOrderByWithAggregationInput = {
    id?: SortOrder
    displayYoutube?: SortOrder
    displayDevice?: SortOrder
    displayFaq?: SortOrder
    displayPopup1?: SortOrder
    displayPopupBell?: SortOrder
    displayPopupEmail?: SortOrder
    displayUserList?: SortOrder
    displayOwnPage?: SortOrder
    userId?: SortOrder
    _count?: UserDisplaySettingsCountOrderByAggregateInput
    _max?: UserDisplaySettingsMaxOrderByAggregateInput
    _min?: UserDisplaySettingsMinOrderByAggregateInput
  }

  export type UserDisplaySettingsScalarWhereWithAggregatesInput = {
    AND?: UserDisplaySettingsScalarWhereWithAggregatesInput | UserDisplaySettingsScalarWhereWithAggregatesInput[]
    OR?: UserDisplaySettingsScalarWhereWithAggregatesInput[]
    NOT?: UserDisplaySettingsScalarWhereWithAggregatesInput | UserDisplaySettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserDisplaySettings"> | string
    displayYoutube?: BoolWithAggregatesFilter<"UserDisplaySettings"> | boolean
    displayDevice?: BoolWithAggregatesFilter<"UserDisplaySettings"> | boolean
    displayFaq?: BoolWithAggregatesFilter<"UserDisplaySettings"> | boolean
    displayPopup1?: BoolWithAggregatesFilter<"UserDisplaySettings"> | boolean
    displayPopupBell?: BoolWithAggregatesFilter<"UserDisplaySettings"> | boolean
    displayPopupEmail?: BoolWithAggregatesFilter<"UserDisplaySettings"> | boolean
    displayUserList?: BoolWithAggregatesFilter<"UserDisplaySettings"> | boolean
    displayOwnPage?: BoolWithAggregatesFilter<"UserDisplaySettings"> | boolean
    userId?: StringWithAggregatesFilter<"UserDisplaySettings"> | string
  }

  export type LinkServiceWhereInput = {
    AND?: LinkServiceWhereInput | LinkServiceWhereInput[]
    OR?: LinkServiceWhereInput[]
    NOT?: LinkServiceWhereInput | LinkServiceWhereInput[]
    id?: StringFilter<"LinkService"> | string
    name?: StringFilter<"LinkService"> | string
    slug?: StringFilter<"LinkService"> | string
    description?: StringNullableFilter<"LinkService"> | string | null
    baseUrl?: StringNullableFilter<"LinkService"> | string | null
    allowOriginalIcon?: BoolFilter<"LinkService"> | boolean
    isActive?: BoolFilter<"LinkService"> | boolean
    sortOrder?: IntFilter<"LinkService"> | number
    createdAt?: DateTimeFilter<"LinkService"> | Date | string
    updatedAt?: DateTimeFilter<"LinkService"> | Date | string
    icons?: ServiceIconListRelationFilter
    links?: UserLinkListRelationFilter
  }

  export type LinkServiceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    baseUrl?: SortOrderInput | SortOrder
    allowOriginalIcon?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    icons?: ServiceIconOrderByRelationAggregateInput
    links?: UserLinkOrderByRelationAggregateInput
  }

  export type LinkServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: LinkServiceWhereInput | LinkServiceWhereInput[]
    OR?: LinkServiceWhereInput[]
    NOT?: LinkServiceWhereInput | LinkServiceWhereInput[]
    name?: StringFilter<"LinkService"> | string
    description?: StringNullableFilter<"LinkService"> | string | null
    baseUrl?: StringNullableFilter<"LinkService"> | string | null
    allowOriginalIcon?: BoolFilter<"LinkService"> | boolean
    isActive?: BoolFilter<"LinkService"> | boolean
    sortOrder?: IntFilter<"LinkService"> | number
    createdAt?: DateTimeFilter<"LinkService"> | Date | string
    updatedAt?: DateTimeFilter<"LinkService"> | Date | string
    icons?: ServiceIconListRelationFilter
    links?: UserLinkListRelationFilter
  }, "id" | "slug">

  export type LinkServiceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    baseUrl?: SortOrderInput | SortOrder
    allowOriginalIcon?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LinkServiceCountOrderByAggregateInput
    _avg?: LinkServiceAvgOrderByAggregateInput
    _max?: LinkServiceMaxOrderByAggregateInput
    _min?: LinkServiceMinOrderByAggregateInput
    _sum?: LinkServiceSumOrderByAggregateInput
  }

  export type LinkServiceScalarWhereWithAggregatesInput = {
    AND?: LinkServiceScalarWhereWithAggregatesInput | LinkServiceScalarWhereWithAggregatesInput[]
    OR?: LinkServiceScalarWhereWithAggregatesInput[]
    NOT?: LinkServiceScalarWhereWithAggregatesInput | LinkServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LinkService"> | string
    name?: StringWithAggregatesFilter<"LinkService"> | string
    slug?: StringWithAggregatesFilter<"LinkService"> | string
    description?: StringNullableWithAggregatesFilter<"LinkService"> | string | null
    baseUrl?: StringNullableWithAggregatesFilter<"LinkService"> | string | null
    allowOriginalIcon?: BoolWithAggregatesFilter<"LinkService"> | boolean
    isActive?: BoolWithAggregatesFilter<"LinkService"> | boolean
    sortOrder?: IntWithAggregatesFilter<"LinkService"> | number
    createdAt?: DateTimeWithAggregatesFilter<"LinkService"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LinkService"> | Date | string
  }

  export type ServiceIconWhereInput = {
    AND?: ServiceIconWhereInput | ServiceIconWhereInput[]
    OR?: ServiceIconWhereInput[]
    NOT?: ServiceIconWhereInput | ServiceIconWhereInput[]
    id?: StringFilter<"ServiceIcon"> | string
    name?: StringFilter<"ServiceIcon"> | string
    fileName?: StringFilter<"ServiceIcon"> | string
    filePath?: StringFilter<"ServiceIcon"> | string
    style?: EnumIconStyleFilter<"ServiceIcon"> | $Enums.IconStyle
    colorScheme?: EnumIconColorFilter<"ServiceIcon"> | $Enums.IconColor
    description?: StringNullableFilter<"ServiceIcon"> | string | null
    isActive?: BoolFilter<"ServiceIcon"> | boolean
    sortOrder?: IntFilter<"ServiceIcon"> | number
    uploadedBy?: StringNullableFilter<"ServiceIcon"> | string | null
    createdAt?: DateTimeFilter<"ServiceIcon"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceIcon"> | Date | string
    serviceId?: StringFilter<"ServiceIcon"> | string
    service?: XOR<LinkServiceScalarRelationFilter, LinkServiceWhereInput>
    links?: UserLinkListRelationFilter
  }

  export type ServiceIconOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    style?: SortOrder
    colorScheme?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceId?: SortOrder
    service?: LinkServiceOrderByWithRelationInput
    links?: UserLinkOrderByRelationAggregateInput
  }

  export type ServiceIconWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceIconWhereInput | ServiceIconWhereInput[]
    OR?: ServiceIconWhereInput[]
    NOT?: ServiceIconWhereInput | ServiceIconWhereInput[]
    name?: StringFilter<"ServiceIcon"> | string
    fileName?: StringFilter<"ServiceIcon"> | string
    filePath?: StringFilter<"ServiceIcon"> | string
    style?: EnumIconStyleFilter<"ServiceIcon"> | $Enums.IconStyle
    colorScheme?: EnumIconColorFilter<"ServiceIcon"> | $Enums.IconColor
    description?: StringNullableFilter<"ServiceIcon"> | string | null
    isActive?: BoolFilter<"ServiceIcon"> | boolean
    sortOrder?: IntFilter<"ServiceIcon"> | number
    uploadedBy?: StringNullableFilter<"ServiceIcon"> | string | null
    createdAt?: DateTimeFilter<"ServiceIcon"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceIcon"> | Date | string
    serviceId?: StringFilter<"ServiceIcon"> | string
    service?: XOR<LinkServiceScalarRelationFilter, LinkServiceWhereInput>
    links?: UserLinkListRelationFilter
  }, "id">

  export type ServiceIconOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    style?: SortOrder
    colorScheme?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceId?: SortOrder
    _count?: ServiceIconCountOrderByAggregateInput
    _avg?: ServiceIconAvgOrderByAggregateInput
    _max?: ServiceIconMaxOrderByAggregateInput
    _min?: ServiceIconMinOrderByAggregateInput
    _sum?: ServiceIconSumOrderByAggregateInput
  }

  export type ServiceIconScalarWhereWithAggregatesInput = {
    AND?: ServiceIconScalarWhereWithAggregatesInput | ServiceIconScalarWhereWithAggregatesInput[]
    OR?: ServiceIconScalarWhereWithAggregatesInput[]
    NOT?: ServiceIconScalarWhereWithAggregatesInput | ServiceIconScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceIcon"> | string
    name?: StringWithAggregatesFilter<"ServiceIcon"> | string
    fileName?: StringWithAggregatesFilter<"ServiceIcon"> | string
    filePath?: StringWithAggregatesFilter<"ServiceIcon"> | string
    style?: EnumIconStyleWithAggregatesFilter<"ServiceIcon"> | $Enums.IconStyle
    colorScheme?: EnumIconColorWithAggregatesFilter<"ServiceIcon"> | $Enums.IconColor
    description?: StringNullableWithAggregatesFilter<"ServiceIcon"> | string | null
    isActive?: BoolWithAggregatesFilter<"ServiceIcon"> | boolean
    sortOrder?: IntWithAggregatesFilter<"ServiceIcon"> | number
    uploadedBy?: StringNullableWithAggregatesFilter<"ServiceIcon"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ServiceIcon"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceIcon"> | Date | string
    serviceId?: StringWithAggregatesFilter<"ServiceIcon"> | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type AuthorWhereInput = {
    AND?: AuthorWhereInput | AuthorWhereInput[]
    OR?: AuthorWhereInput[]
    NOT?: AuthorWhereInput | AuthorWhereInput[]
    id?: StringFilter<"Author"> | string
    bio?: StringNullableFilter<"Author"> | string | null
    profileImage?: StringNullableFilter<"Author"> | string | null
    createdAt?: DateTimeFilter<"Author"> | Date | string
    updatedAt?: DateTimeFilter<"Author"> | Date | string
    userId?: StringFilter<"Author"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    articles?: ArticleListRelationFilter
  }

  export type AuthorOrderByWithRelationInput = {
    id?: SortOrder
    bio?: SortOrderInput | SortOrder
    profileImage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    articles?: ArticleOrderByRelationAggregateInput
  }

  export type AuthorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AuthorWhereInput | AuthorWhereInput[]
    OR?: AuthorWhereInput[]
    NOT?: AuthorWhereInput | AuthorWhereInput[]
    bio?: StringNullableFilter<"Author"> | string | null
    profileImage?: StringNullableFilter<"Author"> | string | null
    createdAt?: DateTimeFilter<"Author"> | Date | string
    updatedAt?: DateTimeFilter<"Author"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    articles?: ArticleListRelationFilter
  }, "id" | "userId">

  export type AuthorOrderByWithAggregationInput = {
    id?: SortOrder
    bio?: SortOrderInput | SortOrder
    profileImage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    _count?: AuthorCountOrderByAggregateInput
    _max?: AuthorMaxOrderByAggregateInput
    _min?: AuthorMinOrderByAggregateInput
  }

  export type AuthorScalarWhereWithAggregatesInput = {
    AND?: AuthorScalarWhereWithAggregatesInput | AuthorScalarWhereWithAggregatesInput[]
    OR?: AuthorScalarWhereWithAggregatesInput[]
    NOT?: AuthorScalarWhereWithAggregatesInput | AuthorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Author"> | string
    bio?: StringNullableWithAggregatesFilter<"Author"> | string | null
    profileImage?: StringNullableWithAggregatesFilter<"Author"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Author"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Author"> | Date | string
    userId?: StringWithAggregatesFilter<"Author"> | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    parentId?: StringNullableFilter<"Category"> | string | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    parent?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    children?: CategoryListRelationFilter
    articles?: ArticleCategoryListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parent?: CategoryOrderByWithRelationInput
    children?: CategoryOrderByRelationAggregateInput
    articles?: ArticleCategoryOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    parentId?: StringNullableFilter<"Category"> | string | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    parent?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    children?: CategoryListRelationFilter
    articles?: ArticleCategoryListRelationFilter
  }, "id" | "slug">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    slug?: StringWithAggregatesFilter<"Category"> | string
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
    parentId?: StringNullableWithAggregatesFilter<"Category"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    slug?: StringFilter<"Tag"> | string
    description?: StringNullableFilter<"Tag"> | string | null
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    articles?: ArticleTagListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    articles?: ArticleTagOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    name?: StringFilter<"Tag"> | string
    description?: StringNullableFilter<"Tag"> | string | null
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    articles?: ArticleTagListRelationFilter
  }, "id" | "slug">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tag"> | string
    name?: StringWithAggregatesFilter<"Tag"> | string
    slug?: StringWithAggregatesFilter<"Tag"> | string
    description?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
  }

  export type ArticleWhereInput = {
    AND?: ArticleWhereInput | ArticleWhereInput[]
    OR?: ArticleWhereInput[]
    NOT?: ArticleWhereInput | ArticleWhereInput[]
    id?: StringFilter<"Article"> | string
    title?: StringFilter<"Article"> | string
    slug?: StringFilter<"Article"> | string
    content?: StringFilter<"Article"> | string
    excerpt?: StringNullableFilter<"Article"> | string | null
    featuredImage?: StringNullableFilter<"Article"> | string | null
    status?: EnumArticleStatusFilter<"Article"> | $Enums.ArticleStatus
    viewCount?: IntFilter<"Article"> | number
    publishedAt?: DateTimeNullableFilter<"Article"> | Date | string | null
    createdAt?: DateTimeFilter<"Article"> | Date | string
    updatedAt?: DateTimeFilter<"Article"> | Date | string
    authorId?: StringFilter<"Article"> | string
    author?: XOR<AuthorScalarRelationFilter, AuthorWhereInput>
    categories?: ArticleCategoryListRelationFilter
    tags?: ArticleTagListRelationFilter
    comments?: CommentListRelationFilter
  }

  export type ArticleOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    featuredImage?: SortOrderInput | SortOrder
    status?: SortOrder
    viewCount?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    author?: AuthorOrderByWithRelationInput
    categories?: ArticleCategoryOrderByRelationAggregateInput
    tags?: ArticleTagOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
  }

  export type ArticleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ArticleWhereInput | ArticleWhereInput[]
    OR?: ArticleWhereInput[]
    NOT?: ArticleWhereInput | ArticleWhereInput[]
    title?: StringFilter<"Article"> | string
    content?: StringFilter<"Article"> | string
    excerpt?: StringNullableFilter<"Article"> | string | null
    featuredImage?: StringNullableFilter<"Article"> | string | null
    status?: EnumArticleStatusFilter<"Article"> | $Enums.ArticleStatus
    viewCount?: IntFilter<"Article"> | number
    publishedAt?: DateTimeNullableFilter<"Article"> | Date | string | null
    createdAt?: DateTimeFilter<"Article"> | Date | string
    updatedAt?: DateTimeFilter<"Article"> | Date | string
    authorId?: StringFilter<"Article"> | string
    author?: XOR<AuthorScalarRelationFilter, AuthorWhereInput>
    categories?: ArticleCategoryListRelationFilter
    tags?: ArticleTagListRelationFilter
    comments?: CommentListRelationFilter
  }, "id" | "slug">

  export type ArticleOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    featuredImage?: SortOrderInput | SortOrder
    status?: SortOrder
    viewCount?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
    _count?: ArticleCountOrderByAggregateInput
    _avg?: ArticleAvgOrderByAggregateInput
    _max?: ArticleMaxOrderByAggregateInput
    _min?: ArticleMinOrderByAggregateInput
    _sum?: ArticleSumOrderByAggregateInput
  }

  export type ArticleScalarWhereWithAggregatesInput = {
    AND?: ArticleScalarWhereWithAggregatesInput | ArticleScalarWhereWithAggregatesInput[]
    OR?: ArticleScalarWhereWithAggregatesInput[]
    NOT?: ArticleScalarWhereWithAggregatesInput | ArticleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Article"> | string
    title?: StringWithAggregatesFilter<"Article"> | string
    slug?: StringWithAggregatesFilter<"Article"> | string
    content?: StringWithAggregatesFilter<"Article"> | string
    excerpt?: StringNullableWithAggregatesFilter<"Article"> | string | null
    featuredImage?: StringNullableWithAggregatesFilter<"Article"> | string | null
    status?: EnumArticleStatusWithAggregatesFilter<"Article"> | $Enums.ArticleStatus
    viewCount?: IntWithAggregatesFilter<"Article"> | number
    publishedAt?: DateTimeNullableWithAggregatesFilter<"Article"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Article"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Article"> | Date | string
    authorId?: StringWithAggregatesFilter<"Article"> | string
  }

  export type ArticleCategoryWhereInput = {
    AND?: ArticleCategoryWhereInput | ArticleCategoryWhereInput[]
    OR?: ArticleCategoryWhereInput[]
    NOT?: ArticleCategoryWhereInput | ArticleCategoryWhereInput[]
    articleId?: StringFilter<"ArticleCategory"> | string
    categoryId?: StringFilter<"ArticleCategory"> | string
    article?: XOR<ArticleScalarRelationFilter, ArticleWhereInput>
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
  }

  export type ArticleCategoryOrderByWithRelationInput = {
    articleId?: SortOrder
    categoryId?: SortOrder
    article?: ArticleOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
  }

  export type ArticleCategoryWhereUniqueInput = Prisma.AtLeast<{
    articleId_categoryId?: ArticleCategoryArticleIdCategoryIdCompoundUniqueInput
    AND?: ArticleCategoryWhereInput | ArticleCategoryWhereInput[]
    OR?: ArticleCategoryWhereInput[]
    NOT?: ArticleCategoryWhereInput | ArticleCategoryWhereInput[]
    articleId?: StringFilter<"ArticleCategory"> | string
    categoryId?: StringFilter<"ArticleCategory"> | string
    article?: XOR<ArticleScalarRelationFilter, ArticleWhereInput>
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
  }, "articleId_categoryId">

  export type ArticleCategoryOrderByWithAggregationInput = {
    articleId?: SortOrder
    categoryId?: SortOrder
    _count?: ArticleCategoryCountOrderByAggregateInput
    _max?: ArticleCategoryMaxOrderByAggregateInput
    _min?: ArticleCategoryMinOrderByAggregateInput
  }

  export type ArticleCategoryScalarWhereWithAggregatesInput = {
    AND?: ArticleCategoryScalarWhereWithAggregatesInput | ArticleCategoryScalarWhereWithAggregatesInput[]
    OR?: ArticleCategoryScalarWhereWithAggregatesInput[]
    NOT?: ArticleCategoryScalarWhereWithAggregatesInput | ArticleCategoryScalarWhereWithAggregatesInput[]
    articleId?: StringWithAggregatesFilter<"ArticleCategory"> | string
    categoryId?: StringWithAggregatesFilter<"ArticleCategory"> | string
  }

  export type ArticleTagWhereInput = {
    AND?: ArticleTagWhereInput | ArticleTagWhereInput[]
    OR?: ArticleTagWhereInput[]
    NOT?: ArticleTagWhereInput | ArticleTagWhereInput[]
    articleId?: StringFilter<"ArticleTag"> | string
    tagId?: StringFilter<"ArticleTag"> | string
    article?: XOR<ArticleScalarRelationFilter, ArticleWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type ArticleTagOrderByWithRelationInput = {
    articleId?: SortOrder
    tagId?: SortOrder
    article?: ArticleOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type ArticleTagWhereUniqueInput = Prisma.AtLeast<{
    articleId_tagId?: ArticleTagArticleIdTagIdCompoundUniqueInput
    AND?: ArticleTagWhereInput | ArticleTagWhereInput[]
    OR?: ArticleTagWhereInput[]
    NOT?: ArticleTagWhereInput | ArticleTagWhereInput[]
    articleId?: StringFilter<"ArticleTag"> | string
    tagId?: StringFilter<"ArticleTag"> | string
    article?: XOR<ArticleScalarRelationFilter, ArticleWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "articleId_tagId">

  export type ArticleTagOrderByWithAggregationInput = {
    articleId?: SortOrder
    tagId?: SortOrder
    _count?: ArticleTagCountOrderByAggregateInput
    _max?: ArticleTagMaxOrderByAggregateInput
    _min?: ArticleTagMinOrderByAggregateInput
  }

  export type ArticleTagScalarWhereWithAggregatesInput = {
    AND?: ArticleTagScalarWhereWithAggregatesInput | ArticleTagScalarWhereWithAggregatesInput[]
    OR?: ArticleTagScalarWhereWithAggregatesInput[]
    NOT?: ArticleTagScalarWhereWithAggregatesInput | ArticleTagScalarWhereWithAggregatesInput[]
    articleId?: StringWithAggregatesFilter<"ArticleTag"> | string
    tagId?: StringWithAggregatesFilter<"ArticleTag"> | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    isApproved?: BoolFilter<"Comment"> | boolean
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    articleId?: StringFilter<"Comment"> | string
    userId?: StringNullableFilter<"Comment"> | string | null
    parent?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    children?: CommentListRelationFilter
    article?: XOR<ArticleScalarRelationFilter, ArticleWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    parentId?: SortOrderInput | SortOrder
    isApproved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    articleId?: SortOrder
    userId?: SortOrderInput | SortOrder
    parent?: CommentOrderByWithRelationInput
    children?: CommentOrderByRelationAggregateInput
    article?: ArticleOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    content?: StringFilter<"Comment"> | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    isApproved?: BoolFilter<"Comment"> | boolean
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    articleId?: StringFilter<"Comment"> | string
    userId?: StringNullableFilter<"Comment"> | string | null
    parent?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    children?: CommentListRelationFilter
    article?: XOR<ArticleScalarRelationFilter, ArticleWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    parentId?: SortOrderInput | SortOrder
    isApproved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    articleId?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    content?: StringWithAggregatesFilter<"Comment"> | string
    parentId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    isApproved?: BoolWithAggregatesFilter<"Comment"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    articleId?: StringWithAggregatesFilter<"Comment"> | string
    userId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name?: string | null
    characterName?: string | null
    subname?: string | null
    bio?: string | null
    birthday?: Date | string | null
    gender?: string | null
    iconUrl?: string | null
    bannerUrl?: string | null
    handle?: string | null
    handleChangeCount?: number
    handleChangeTokens?: number
    isPremiumUser?: boolean
    role?: string
    subscriptionStatus?: string | null
    emailVerified?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    ogp?: UserOGPCreateNestedOneWithoutUserInput
    links?: UserLinkCreateNestedManyWithoutUserInput
    imageBanners?: UserImageBannerCreateNestedManyWithoutUserInput
    imageCarousels?: UserImageCarouselCreateNestedManyWithoutUserInput
    imageSidebars?: UserImageSidebarCreateNestedManyWithoutUserInput
    customQuestions?: UserCustomQuestionCreateNestedManyWithoutUserInput
    youtubeSettings?: UserYoutubeSettingsCreateNestedOneWithoutUserInput
    recommendYoutubes?: UserRecommendYoutubeCreateNestedManyWithoutUserInput
    popupSettings?: UserPopupSettingsCreateNestedOneWithoutUserInput
    displaySettings?: UserDisplaySettingsCreateNestedOneWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    author?: AuthorCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    characterName?: string | null
    subname?: string | null
    bio?: string | null
    birthday?: Date | string | null
    gender?: string | null
    iconUrl?: string | null
    bannerUrl?: string | null
    handle?: string | null
    handleChangeCount?: number
    handleChangeTokens?: number
    isPremiumUser?: boolean
    role?: string
    subscriptionStatus?: string | null
    emailVerified?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    ogp?: UserOGPUncheckedCreateNestedOneWithoutUserInput
    links?: UserLinkUncheckedCreateNestedManyWithoutUserInput
    imageBanners?: UserImageBannerUncheckedCreateNestedManyWithoutUserInput
    imageCarousels?: UserImageCarouselUncheckedCreateNestedManyWithoutUserInput
    imageSidebars?: UserImageSidebarUncheckedCreateNestedManyWithoutUserInput
    customQuestions?: UserCustomQuestionUncheckedCreateNestedManyWithoutUserInput
    youtubeSettings?: UserYoutubeSettingsUncheckedCreateNestedOneWithoutUserInput
    recommendYoutubes?: UserRecommendYoutubeUncheckedCreateNestedManyWithoutUserInput
    popupSettings?: UserPopupSettingsUncheckedCreateNestedOneWithoutUserInput
    displaySettings?: UserDisplaySettingsUncheckedCreateNestedOneWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    author?: AuthorUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    characterName?: NullableStringFieldUpdateOperationsInput | string | null
    subname?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    handleChangeCount?: IntFieldUpdateOperationsInput | number
    handleChangeTokens?: IntFieldUpdateOperationsInput | number
    isPremiumUser?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    ogp?: UserOGPUpdateOneWithoutUserNestedInput
    links?: UserLinkUpdateManyWithoutUserNestedInput
    imageBanners?: UserImageBannerUpdateManyWithoutUserNestedInput
    imageCarousels?: UserImageCarouselUpdateManyWithoutUserNestedInput
    imageSidebars?: UserImageSidebarUpdateManyWithoutUserNestedInput
    customQuestions?: UserCustomQuestionUpdateManyWithoutUserNestedInput
    youtubeSettings?: UserYoutubeSettingsUpdateOneWithoutUserNestedInput
    recommendYoutubes?: UserRecommendYoutubeUpdateManyWithoutUserNestedInput
    popupSettings?: UserPopupSettingsUpdateOneWithoutUserNestedInput
    displaySettings?: UserDisplaySettingsUpdateOneWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    author?: AuthorUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    characterName?: NullableStringFieldUpdateOperationsInput | string | null
    subname?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    handleChangeCount?: IntFieldUpdateOperationsInput | number
    handleChangeTokens?: IntFieldUpdateOperationsInput | number
    isPremiumUser?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    ogp?: UserOGPUncheckedUpdateOneWithoutUserNestedInput
    links?: UserLinkUncheckedUpdateManyWithoutUserNestedInput
    imageBanners?: UserImageBannerUncheckedUpdateManyWithoutUserNestedInput
    imageCarousels?: UserImageCarouselUncheckedUpdateManyWithoutUserNestedInput
    imageSidebars?: UserImageSidebarUncheckedUpdateManyWithoutUserNestedInput
    customQuestions?: UserCustomQuestionUncheckedUpdateManyWithoutUserNestedInput
    youtubeSettings?: UserYoutubeSettingsUncheckedUpdateOneWithoutUserNestedInput
    recommendYoutubes?: UserRecommendYoutubeUncheckedUpdateManyWithoutUserNestedInput
    popupSettings?: UserPopupSettingsUncheckedUpdateOneWithoutUserNestedInput
    displaySettings?: UserDisplaySettingsUncheckedUpdateOneWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    author?: AuthorUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    characterName?: string | null
    subname?: string | null
    bio?: string | null
    birthday?: Date | string | null
    gender?: string | null
    iconUrl?: string | null
    bannerUrl?: string | null
    handle?: string | null
    handleChangeCount?: number
    handleChangeTokens?: number
    isPremiumUser?: boolean
    role?: string
    subscriptionStatus?: string | null
    emailVerified?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    characterName?: NullableStringFieldUpdateOperationsInput | string | null
    subname?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    handleChangeCount?: IntFieldUpdateOperationsInput | number
    handleChangeTokens?: IntFieldUpdateOperationsInput | number
    isPremiumUser?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    characterName?: NullableStringFieldUpdateOperationsInput | string | null
    subname?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    handleChangeCount?: IntFieldUpdateOperationsInput | number
    handleChangeTokens?: IntFieldUpdateOperationsInput | number
    isPremiumUser?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSettingsCreateInput = {
    id?: string
    pushNotifications?: boolean
    user: UserCreateNestedOneWithoutNotificationSettingsInput
  }

  export type NotificationSettingsUncheckedCreateInput = {
    id?: string
    pushNotifications?: boolean
    userId: string
  }

  export type NotificationSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutNotificationSettingsNestedInput
  }

  export type NotificationSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationSettingsCreateManyInput = {
    id?: string
    pushNotifications?: boolean
    userId: string
  }

  export type NotificationSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserLinkCreateInput = {
    id?: string
    url: string
    title?: string | null
    description?: string | null
    sortOrder?: number
    isActive?: boolean
    useOriginalIcon?: boolean
    originalIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLinksInput
    service: LinkServiceCreateNestedOneWithoutLinksInput
    icon?: ServiceIconCreateNestedOneWithoutLinksInput
  }

  export type UserLinkUncheckedCreateInput = {
    id?: string
    url: string
    title?: string | null
    description?: string | null
    sortOrder?: number
    isActive?: boolean
    useOriginalIcon?: boolean
    originalIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    serviceId: string
    iconId?: string | null
  }

  export type UserLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    useOriginalIcon?: BoolFieldUpdateOperationsInput | boolean
    originalIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLinksNestedInput
    service?: LinkServiceUpdateOneRequiredWithoutLinksNestedInput
    icon?: ServiceIconUpdateOneWithoutLinksNestedInput
  }

  export type UserLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    useOriginalIcon?: BoolFieldUpdateOperationsInput | boolean
    originalIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    iconId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserLinkCreateManyInput = {
    id?: string
    url: string
    title?: string | null
    description?: string | null
    sortOrder?: number
    isActive?: boolean
    useOriginalIcon?: boolean
    originalIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    serviceId: string
    iconId?: string | null
  }

  export type UserLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    useOriginalIcon?: BoolFieldUpdateOperationsInput | boolean
    originalIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    useOriginalIcon?: BoolFieldUpdateOperationsInput | boolean
    originalIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    iconId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserYoutubeSettingsCreateInput = {
    id?: string
    channelId?: string | null
    displayCount?: number
    lastFetchedAt?: Date | string | null
    pickupVideo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutYoutubeSettingsInput
    videos?: UserYoutubeVideoCreateNestedManyWithoutSettingsInput
  }

  export type UserYoutubeSettingsUncheckedCreateInput = {
    id?: string
    channelId?: string | null
    displayCount?: number
    lastFetchedAt?: Date | string | null
    pickupVideo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    videos?: UserYoutubeVideoUncheckedCreateNestedManyWithoutSettingsInput
  }

  export type UserYoutubeSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    displayCount?: IntFieldUpdateOperationsInput | number
    lastFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupVideo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutYoutubeSettingsNestedInput
    videos?: UserYoutubeVideoUpdateManyWithoutSettingsNestedInput
  }

  export type UserYoutubeSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    displayCount?: IntFieldUpdateOperationsInput | number
    lastFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupVideo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    videos?: UserYoutubeVideoUncheckedUpdateManyWithoutSettingsNestedInput
  }

  export type UserYoutubeSettingsCreateManyInput = {
    id?: string
    channelId?: string | null
    displayCount?: number
    lastFetchedAt?: Date | string | null
    pickupVideo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type UserYoutubeSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    displayCount?: IntFieldUpdateOperationsInput | number
    lastFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupVideo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserYoutubeSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    displayCount?: IntFieldUpdateOperationsInput | number
    lastFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupVideo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserImageBannerCreateInput = {
    id?: string
    url?: string | null
    imgUrl: string
    alt?: string | null
    sortOrder?: number
    user: UserCreateNestedOneWithoutImageBannersInput
  }

  export type UserImageBannerUncheckedCreateInput = {
    id?: string
    url?: string | null
    imgUrl: string
    alt?: string | null
    sortOrder?: number
    userId: string
  }

  export type UserImageBannerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    imgUrl?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutImageBannersNestedInput
  }

  export type UserImageBannerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    imgUrl?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserImageBannerCreateManyInput = {
    id?: string
    url?: string | null
    imgUrl: string
    alt?: string | null
    sortOrder?: number
    userId: string
  }

  export type UserImageBannerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    imgUrl?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type UserImageBannerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    imgUrl?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserYoutubeVideoCreateInput = {
    id?: string
    url: string
    thumbnailUrl?: string | null
    title?: string | null
    description?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    settings: UserYoutubeSettingsCreateNestedOneWithoutVideosInput
  }

  export type UserYoutubeVideoUncheckedCreateInput = {
    id?: string
    url: string
    thumbnailUrl?: string | null
    title?: string | null
    description?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    settingsId: string
  }

  export type UserYoutubeVideoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: UserYoutubeSettingsUpdateOneRequiredWithoutVideosNestedInput
  }

  export type UserYoutubeVideoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settingsId?: StringFieldUpdateOperationsInput | string
  }

  export type UserYoutubeVideoCreateManyInput = {
    id?: string
    url: string
    thumbnailUrl?: string | null
    title?: string | null
    description?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    settingsId: string
  }

  export type UserYoutubeVideoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserYoutubeVideoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settingsId?: StringFieldUpdateOperationsInput | string
  }

  export type UserRecommendYoutubeCreateInput = {
    id?: string
    url: string
    thumbnailUrl?: string | null
    title?: string | null
    description?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRecommendYoutubesInput
  }

  export type UserRecommendYoutubeUncheckedCreateInput = {
    id?: string
    url: string
    thumbnailUrl?: string | null
    title?: string | null
    description?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type UserRecommendYoutubeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRecommendYoutubesNestedInput
  }

  export type UserRecommendYoutubeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserRecommendYoutubeCreateManyInput = {
    id?: string
    url: string
    thumbnailUrl?: string | null
    title?: string | null
    description?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type UserRecommendYoutubeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRecommendYoutubeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserPopupSettingsCreateInput = {
    id?: string
    bellTitle?: string | null
    bellText?: string | null
    bellImageUrl?: string | null
    bellUrl?: string | null
    bellLastUpdated?: Date | string | null
    emailTitle?: string | null
    emailText?: string | null
    popup1ImageUrl?: string | null
    popup1Url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPopupSettingsInput
  }

  export type UserPopupSettingsUncheckedCreateInput = {
    id?: string
    bellTitle?: string | null
    bellText?: string | null
    bellImageUrl?: string | null
    bellUrl?: string | null
    bellLastUpdated?: Date | string | null
    emailTitle?: string | null
    emailText?: string | null
    popup1ImageUrl?: string | null
    popup1Url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type UserPopupSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bellTitle?: NullableStringFieldUpdateOperationsInput | string | null
    bellText?: NullableStringFieldUpdateOperationsInput | string | null
    bellImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bellUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bellLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailTitle?: NullableStringFieldUpdateOperationsInput | string | null
    emailText?: NullableStringFieldUpdateOperationsInput | string | null
    popup1ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    popup1Url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPopupSettingsNestedInput
  }

  export type UserPopupSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bellTitle?: NullableStringFieldUpdateOperationsInput | string | null
    bellText?: NullableStringFieldUpdateOperationsInput | string | null
    bellImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bellUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bellLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailTitle?: NullableStringFieldUpdateOperationsInput | string | null
    emailText?: NullableStringFieldUpdateOperationsInput | string | null
    popup1ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    popup1Url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserPopupSettingsCreateManyInput = {
    id?: string
    bellTitle?: string | null
    bellText?: string | null
    bellImageUrl?: string | null
    bellUrl?: string | null
    bellLastUpdated?: Date | string | null
    emailTitle?: string | null
    emailText?: string | null
    popup1ImageUrl?: string | null
    popup1Url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type UserPopupSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bellTitle?: NullableStringFieldUpdateOperationsInput | string | null
    bellText?: NullableStringFieldUpdateOperationsInput | string | null
    bellImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bellUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bellLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailTitle?: NullableStringFieldUpdateOperationsInput | string | null
    emailText?: NullableStringFieldUpdateOperationsInput | string | null
    popup1ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    popup1Url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPopupSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bellTitle?: NullableStringFieldUpdateOperationsInput | string | null
    bellText?: NullableStringFieldUpdateOperationsInput | string | null
    bellImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bellUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bellLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailTitle?: NullableStringFieldUpdateOperationsInput | string | null
    emailText?: NullableStringFieldUpdateOperationsInput | string | null
    popup1ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    popup1Url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserOGPCreateInput = {
    id?: string
    imgUrl?: string | null
    title?: string | null
    description?: string | null
    user: UserCreateNestedOneWithoutOgpInput
  }

  export type UserOGPUncheckedCreateInput = {
    id?: string
    imgUrl?: string | null
    title?: string | null
    description?: string | null
    userId: string
  }

  export type UserOGPUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    imgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutOgpNestedInput
  }

  export type UserOGPUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    imgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserOGPCreateManyInput = {
    id?: string
    imgUrl?: string | null
    title?: string | null
    description?: string | null
    userId: string
  }

  export type UserOGPUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    imgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserOGPUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    imgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserCustomQuestionCreateInput = {
    id?: string
    question: string
    answer: string
    sortOrder?: number
    user: UserCreateNestedOneWithoutCustomQuestionsInput
  }

  export type UserCustomQuestionUncheckedCreateInput = {
    id?: string
    question: string
    answer: string
    sortOrder?: number
    userId: string
  }

  export type UserCustomQuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutCustomQuestionsNestedInput
  }

  export type UserCustomQuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserCustomQuestionCreateManyInput = {
    id?: string
    question: string
    answer: string
    sortOrder?: number
    userId: string
  }

  export type UserCustomQuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type UserCustomQuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserImageCarouselCreateInput = {
    id?: string
    url?: string | null
    imgUrl: string
    alt?: string | null
    sortOrder?: number
    user: UserCreateNestedOneWithoutImageCarouselsInput
  }

  export type UserImageCarouselUncheckedCreateInput = {
    id?: string
    url?: string | null
    imgUrl: string
    alt?: string | null
    sortOrder?: number
    userId: string
  }

  export type UserImageCarouselUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    imgUrl?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutImageCarouselsNestedInput
  }

  export type UserImageCarouselUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    imgUrl?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserImageCarouselCreateManyInput = {
    id?: string
    url?: string | null
    imgUrl: string
    alt?: string | null
    sortOrder?: number
    userId: string
  }

  export type UserImageCarouselUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    imgUrl?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type UserImageCarouselUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    imgUrl?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserImageSidebarCreateInput = {
    id?: string
    url?: string | null
    imgUrl: string
    alt?: string | null
    sortOrder?: number
    user: UserCreateNestedOneWithoutImageSidebarsInput
  }

  export type UserImageSidebarUncheckedCreateInput = {
    id?: string
    url?: string | null
    imgUrl: string
    alt?: string | null
    sortOrder?: number
    userId: string
  }

  export type UserImageSidebarUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    imgUrl?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutImageSidebarsNestedInput
  }

  export type UserImageSidebarUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    imgUrl?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserImageSidebarCreateManyInput = {
    id?: string
    url?: string | null
    imgUrl: string
    alt?: string | null
    sortOrder?: number
    userId: string
  }

  export type UserImageSidebarUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    imgUrl?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type UserImageSidebarUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    imgUrl?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserDisplaySettingsCreateInput = {
    id?: string
    displayYoutube?: boolean
    displayDevice?: boolean
    displayFaq?: boolean
    displayPopup1?: boolean
    displayPopupBell?: boolean
    displayPopupEmail?: boolean
    displayUserList?: boolean
    displayOwnPage?: boolean
    user: UserCreateNestedOneWithoutDisplaySettingsInput
  }

  export type UserDisplaySettingsUncheckedCreateInput = {
    id?: string
    displayYoutube?: boolean
    displayDevice?: boolean
    displayFaq?: boolean
    displayPopup1?: boolean
    displayPopupBell?: boolean
    displayPopupEmail?: boolean
    displayUserList?: boolean
    displayOwnPage?: boolean
    userId: string
  }

  export type UserDisplaySettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayYoutube?: BoolFieldUpdateOperationsInput | boolean
    displayDevice?: BoolFieldUpdateOperationsInput | boolean
    displayFaq?: BoolFieldUpdateOperationsInput | boolean
    displayPopup1?: BoolFieldUpdateOperationsInput | boolean
    displayPopupBell?: BoolFieldUpdateOperationsInput | boolean
    displayPopupEmail?: BoolFieldUpdateOperationsInput | boolean
    displayUserList?: BoolFieldUpdateOperationsInput | boolean
    displayOwnPage?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutDisplaySettingsNestedInput
  }

  export type UserDisplaySettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayYoutube?: BoolFieldUpdateOperationsInput | boolean
    displayDevice?: BoolFieldUpdateOperationsInput | boolean
    displayFaq?: BoolFieldUpdateOperationsInput | boolean
    displayPopup1?: BoolFieldUpdateOperationsInput | boolean
    displayPopupBell?: BoolFieldUpdateOperationsInput | boolean
    displayPopupEmail?: BoolFieldUpdateOperationsInput | boolean
    displayUserList?: BoolFieldUpdateOperationsInput | boolean
    displayOwnPage?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserDisplaySettingsCreateManyInput = {
    id?: string
    displayYoutube?: boolean
    displayDevice?: boolean
    displayFaq?: boolean
    displayPopup1?: boolean
    displayPopupBell?: boolean
    displayPopupEmail?: boolean
    displayUserList?: boolean
    displayOwnPage?: boolean
    userId: string
  }

  export type UserDisplaySettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayYoutube?: BoolFieldUpdateOperationsInput | boolean
    displayDevice?: BoolFieldUpdateOperationsInput | boolean
    displayFaq?: BoolFieldUpdateOperationsInput | boolean
    displayPopup1?: BoolFieldUpdateOperationsInput | boolean
    displayPopupBell?: BoolFieldUpdateOperationsInput | boolean
    displayPopupEmail?: BoolFieldUpdateOperationsInput | boolean
    displayUserList?: BoolFieldUpdateOperationsInput | boolean
    displayOwnPage?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserDisplaySettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayYoutube?: BoolFieldUpdateOperationsInput | boolean
    displayDevice?: BoolFieldUpdateOperationsInput | boolean
    displayFaq?: BoolFieldUpdateOperationsInput | boolean
    displayPopup1?: BoolFieldUpdateOperationsInput | boolean
    displayPopupBell?: BoolFieldUpdateOperationsInput | boolean
    displayPopupEmail?: BoolFieldUpdateOperationsInput | boolean
    displayUserList?: BoolFieldUpdateOperationsInput | boolean
    displayOwnPage?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type LinkServiceCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    baseUrl?: string | null
    allowOriginalIcon?: boolean
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    icons?: ServiceIconCreateNestedManyWithoutServiceInput
    links?: UserLinkCreateNestedManyWithoutServiceInput
  }

  export type LinkServiceUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    baseUrl?: string | null
    allowOriginalIcon?: boolean
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    icons?: ServiceIconUncheckedCreateNestedManyWithoutServiceInput
    links?: UserLinkUncheckedCreateNestedManyWithoutServiceInput
  }

  export type LinkServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    allowOriginalIcon?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    icons?: ServiceIconUpdateManyWithoutServiceNestedInput
    links?: UserLinkUpdateManyWithoutServiceNestedInput
  }

  export type LinkServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    allowOriginalIcon?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    icons?: ServiceIconUncheckedUpdateManyWithoutServiceNestedInput
    links?: UserLinkUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type LinkServiceCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    baseUrl?: string | null
    allowOriginalIcon?: boolean
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LinkServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    allowOriginalIcon?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    allowOriginalIcon?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceIconCreateInput = {
    id?: string
    name: string
    fileName: string
    filePath: string
    style: $Enums.IconStyle
    colorScheme: $Enums.IconColor
    description?: string | null
    isActive?: boolean
    sortOrder?: number
    uploadedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service: LinkServiceCreateNestedOneWithoutIconsInput
    links?: UserLinkCreateNestedManyWithoutIconInput
  }

  export type ServiceIconUncheckedCreateInput = {
    id?: string
    name: string
    fileName: string
    filePath: string
    style: $Enums.IconStyle
    colorScheme: $Enums.IconColor
    description?: string | null
    isActive?: boolean
    sortOrder?: number
    uploadedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceId: string
    links?: UserLinkUncheckedCreateNestedManyWithoutIconInput
  }

  export type ServiceIconUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    style?: EnumIconStyleFieldUpdateOperationsInput | $Enums.IconStyle
    colorScheme?: EnumIconColorFieldUpdateOperationsInput | $Enums.IconColor
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: LinkServiceUpdateOneRequiredWithoutIconsNestedInput
    links?: UserLinkUpdateManyWithoutIconNestedInput
  }

  export type ServiceIconUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    style?: EnumIconStyleFieldUpdateOperationsInput | $Enums.IconStyle
    colorScheme?: EnumIconColorFieldUpdateOperationsInput | $Enums.IconColor
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceId?: StringFieldUpdateOperationsInput | string
    links?: UserLinkUncheckedUpdateManyWithoutIconNestedInput
  }

  export type ServiceIconCreateManyInput = {
    id?: string
    name: string
    fileName: string
    filePath: string
    style: $Enums.IconStyle
    colorScheme: $Enums.IconColor
    description?: string | null
    isActive?: boolean
    sortOrder?: number
    uploadedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceId: string
  }

  export type ServiceIconUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    style?: EnumIconStyleFieldUpdateOperationsInput | $Enums.IconStyle
    colorScheme?: EnumIconColorFieldUpdateOperationsInput | $Enums.IconColor
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceIconUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    style?: EnumIconStyleFieldUpdateOperationsInput | $Enums.IconStyle
    colorScheme?: EnumIconColorFieldUpdateOperationsInput | $Enums.IconColor
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthorCreateInput = {
    id?: string
    bio?: string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAuthorInput
    articles?: ArticleCreateNestedManyWithoutAuthorInput
  }

  export type AuthorUncheckedCreateInput = {
    id?: string
    bio?: string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    articles?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type AuthorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuthorNestedInput
    articles?: ArticleUpdateManyWithoutAuthorNestedInput
  }

  export type AuthorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    articles?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type AuthorCreateManyInput = {
    id?: string
    bio?: string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type AuthorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    articles?: ArticleCategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    articles?: ArticleCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    articles?: ArticleCategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    articles?: ArticleCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    articles?: ArticleTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    articles?: ArticleTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: ArticleTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: ArticleTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleCreateInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    featuredImage?: string | null
    status?: $Enums.ArticleStatus
    viewCount?: number
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: AuthorCreateNestedOneWithoutArticlesInput
    categories?: ArticleCategoryCreateNestedManyWithoutArticleInput
    tags?: ArticleTagCreateNestedManyWithoutArticleInput
    comments?: CommentCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    featuredImage?: string | null
    status?: $Enums.ArticleStatus
    viewCount?: number
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    categories?: ArticleCategoryUncheckedCreateNestedManyWithoutArticleInput
    tags?: ArticleTagUncheckedCreateNestedManyWithoutArticleInput
    comments?: CommentUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumArticleStatusFieldUpdateOperationsInput | $Enums.ArticleStatus
    viewCount?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: AuthorUpdateOneRequiredWithoutArticlesNestedInput
    categories?: ArticleCategoryUpdateManyWithoutArticleNestedInput
    tags?: ArticleTagUpdateManyWithoutArticleNestedInput
    comments?: CommentUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumArticleStatusFieldUpdateOperationsInput | $Enums.ArticleStatus
    viewCount?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    categories?: ArticleCategoryUncheckedUpdateManyWithoutArticleNestedInput
    tags?: ArticleTagUncheckedUpdateManyWithoutArticleNestedInput
    comments?: CommentUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type ArticleCreateManyInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    featuredImage?: string | null
    status?: $Enums.ArticleStatus
    viewCount?: number
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
  }

  export type ArticleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumArticleStatusFieldUpdateOperationsInput | $Enums.ArticleStatus
    viewCount?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumArticleStatusFieldUpdateOperationsInput | $Enums.ArticleStatus
    viewCount?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
  }

  export type ArticleCategoryCreateInput = {
    article: ArticleCreateNestedOneWithoutCategoriesInput
    category: CategoryCreateNestedOneWithoutArticlesInput
  }

  export type ArticleCategoryUncheckedCreateInput = {
    articleId: string
    categoryId: string
  }

  export type ArticleCategoryUpdateInput = {
    article?: ArticleUpdateOneRequiredWithoutCategoriesNestedInput
    category?: CategoryUpdateOneRequiredWithoutArticlesNestedInput
  }

  export type ArticleCategoryUncheckedUpdateInput = {
    articleId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type ArticleCategoryCreateManyInput = {
    articleId: string
    categoryId: string
  }

  export type ArticleCategoryUpdateManyMutationInput = {

  }

  export type ArticleCategoryUncheckedUpdateManyInput = {
    articleId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type ArticleTagCreateInput = {
    article: ArticleCreateNestedOneWithoutTagsInput
    tag: TagCreateNestedOneWithoutArticlesInput
  }

  export type ArticleTagUncheckedCreateInput = {
    articleId: string
    tagId: string
  }

  export type ArticleTagUpdateInput = {
    article?: ArticleUpdateOneRequiredWithoutTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutArticlesNestedInput
  }

  export type ArticleTagUncheckedUpdateInput = {
    articleId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type ArticleTagCreateManyInput = {
    articleId: string
    tagId: string
  }

  export type ArticleTagUpdateManyMutationInput = {

  }

  export type ArticleTagUncheckedUpdateManyInput = {
    articleId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type CommentCreateInput = {
    id?: string
    content: string
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: CommentCreateNestedOneWithoutChildrenInput
    children?: CommentCreateNestedManyWithoutParentInput
    article: ArticleCreateNestedOneWithoutCommentsInput
    user?: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    content: string
    parentId?: string | null
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    articleId: string
    userId?: string | null
    children?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: CommentUpdateOneWithoutChildrenNestedInput
    children?: CommentUpdateManyWithoutParentNestedInput
    article?: ArticleUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articleId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: string
    content: string
    parentId?: string | null
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    articleId: string
    userId?: string | null
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articleId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type UserOGPNullableScalarRelationFilter = {
    is?: UserOGPWhereInput | null
    isNot?: UserOGPWhereInput | null
  }

  export type UserLinkListRelationFilter = {
    every?: UserLinkWhereInput
    some?: UserLinkWhereInput
    none?: UserLinkWhereInput
  }

  export type UserImageBannerListRelationFilter = {
    every?: UserImageBannerWhereInput
    some?: UserImageBannerWhereInput
    none?: UserImageBannerWhereInput
  }

  export type UserImageCarouselListRelationFilter = {
    every?: UserImageCarouselWhereInput
    some?: UserImageCarouselWhereInput
    none?: UserImageCarouselWhereInput
  }

  export type UserImageSidebarListRelationFilter = {
    every?: UserImageSidebarWhereInput
    some?: UserImageSidebarWhereInput
    none?: UserImageSidebarWhereInput
  }

  export type UserCustomQuestionListRelationFilter = {
    every?: UserCustomQuestionWhereInput
    some?: UserCustomQuestionWhereInput
    none?: UserCustomQuestionWhereInput
  }

  export type UserYoutubeSettingsNullableScalarRelationFilter = {
    is?: UserYoutubeSettingsWhereInput | null
    isNot?: UserYoutubeSettingsWhereInput | null
  }

  export type UserRecommendYoutubeListRelationFilter = {
    every?: UserRecommendYoutubeWhereInput
    some?: UserRecommendYoutubeWhereInput
    none?: UserRecommendYoutubeWhereInput
  }

  export type UserPopupSettingsNullableScalarRelationFilter = {
    is?: UserPopupSettingsWhereInput | null
    isNot?: UserPopupSettingsWhereInput | null
  }

  export type UserDisplaySettingsNullableScalarRelationFilter = {
    is?: UserDisplaySettingsWhereInput | null
    isNot?: UserDisplaySettingsWhereInput | null
  }

  export type NotificationSettingsNullableScalarRelationFilter = {
    is?: NotificationSettingsWhereInput | null
    isNot?: NotificationSettingsWhereInput | null
  }

  export type AuthorNullableScalarRelationFilter = {
    is?: AuthorWhereInput | null
    isNot?: AuthorWhereInput | null
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserImageBannerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserImageCarouselOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserImageSidebarOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCustomQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserRecommendYoutubeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    characterName?: SortOrder
    subname?: SortOrder
    bio?: SortOrder
    birthday?: SortOrder
    gender?: SortOrder
    iconUrl?: SortOrder
    bannerUrl?: SortOrder
    handle?: SortOrder
    handleChangeCount?: SortOrder
    handleChangeTokens?: SortOrder
    isPremiumUser?: SortOrder
    role?: SortOrder
    subscriptionStatus?: SortOrder
    emailVerified?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    handleChangeCount?: SortOrder
    handleChangeTokens?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    characterName?: SortOrder
    subname?: SortOrder
    bio?: SortOrder
    birthday?: SortOrder
    gender?: SortOrder
    iconUrl?: SortOrder
    bannerUrl?: SortOrder
    handle?: SortOrder
    handleChangeCount?: SortOrder
    handleChangeTokens?: SortOrder
    isPremiumUser?: SortOrder
    role?: SortOrder
    subscriptionStatus?: SortOrder
    emailVerified?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    characterName?: SortOrder
    subname?: SortOrder
    bio?: SortOrder
    birthday?: SortOrder
    gender?: SortOrder
    iconUrl?: SortOrder
    bannerUrl?: SortOrder
    handle?: SortOrder
    handleChangeCount?: SortOrder
    handleChangeTokens?: SortOrder
    isPremiumUser?: SortOrder
    role?: SortOrder
    subscriptionStatus?: SortOrder
    emailVerified?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    handleChangeCount?: SortOrder
    handleChangeTokens?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type NotificationSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    pushNotifications?: SortOrder
    userId?: SortOrder
  }

  export type NotificationSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    pushNotifications?: SortOrder
    userId?: SortOrder
  }

  export type NotificationSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    pushNotifications?: SortOrder
    userId?: SortOrder
  }

  export type LinkServiceScalarRelationFilter = {
    is?: LinkServiceWhereInput
    isNot?: LinkServiceWhereInput
  }

  export type ServiceIconNullableScalarRelationFilter = {
    is?: ServiceIconWhereInput | null
    isNot?: ServiceIconWhereInput | null
  }

  export type UserLinkCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    title?: SortOrder
    description?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    useOriginalIcon?: SortOrder
    originalIconUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    iconId?: SortOrder
  }

  export type UserLinkAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type UserLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    title?: SortOrder
    description?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    useOriginalIcon?: SortOrder
    originalIconUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    iconId?: SortOrder
  }

  export type UserLinkMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    title?: SortOrder
    description?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    useOriginalIcon?: SortOrder
    originalIconUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    iconId?: SortOrder
  }

  export type UserLinkSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type UserYoutubeVideoListRelationFilter = {
    every?: UserYoutubeVideoWhereInput
    some?: UserYoutubeVideoWhereInput
    none?: UserYoutubeVideoWhereInput
  }

  export type UserYoutubeVideoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserYoutubeSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    displayCount?: SortOrder
    lastFetchedAt?: SortOrder
    pickupVideo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type UserYoutubeSettingsAvgOrderByAggregateInput = {
    displayCount?: SortOrder
  }

  export type UserYoutubeSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    displayCount?: SortOrder
    lastFetchedAt?: SortOrder
    pickupVideo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type UserYoutubeSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    displayCount?: SortOrder
    lastFetchedAt?: SortOrder
    pickupVideo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type UserYoutubeSettingsSumOrderByAggregateInput = {
    displayCount?: SortOrder
  }

  export type UserImageBannerCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    imgUrl?: SortOrder
    alt?: SortOrder
    sortOrder?: SortOrder
    userId?: SortOrder
  }

  export type UserImageBannerAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type UserImageBannerMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    imgUrl?: SortOrder
    alt?: SortOrder
    sortOrder?: SortOrder
    userId?: SortOrder
  }

  export type UserImageBannerMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    imgUrl?: SortOrder
    alt?: SortOrder
    sortOrder?: SortOrder
    userId?: SortOrder
  }

  export type UserImageBannerSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type UserYoutubeSettingsScalarRelationFilter = {
    is?: UserYoutubeSettingsWhereInput
    isNot?: UserYoutubeSettingsWhereInput
  }

  export type UserYoutubeVideoCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    title?: SortOrder
    description?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    settingsId?: SortOrder
  }

  export type UserYoutubeVideoMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    title?: SortOrder
    description?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    settingsId?: SortOrder
  }

  export type UserYoutubeVideoMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    title?: SortOrder
    description?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    settingsId?: SortOrder
  }

  export type UserRecommendYoutubeCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    title?: SortOrder
    description?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type UserRecommendYoutubeAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type UserRecommendYoutubeMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    title?: SortOrder
    description?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type UserRecommendYoutubeMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    title?: SortOrder
    description?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type UserRecommendYoutubeSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type UserPopupSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    bellTitle?: SortOrder
    bellText?: SortOrder
    bellImageUrl?: SortOrder
    bellUrl?: SortOrder
    bellLastUpdated?: SortOrder
    emailTitle?: SortOrder
    emailText?: SortOrder
    popup1ImageUrl?: SortOrder
    popup1Url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type UserPopupSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    bellTitle?: SortOrder
    bellText?: SortOrder
    bellImageUrl?: SortOrder
    bellUrl?: SortOrder
    bellLastUpdated?: SortOrder
    emailTitle?: SortOrder
    emailText?: SortOrder
    popup1ImageUrl?: SortOrder
    popup1Url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type UserPopupSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    bellTitle?: SortOrder
    bellText?: SortOrder
    bellImageUrl?: SortOrder
    bellUrl?: SortOrder
    bellLastUpdated?: SortOrder
    emailTitle?: SortOrder
    emailText?: SortOrder
    popup1ImageUrl?: SortOrder
    popup1Url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type UserOGPCountOrderByAggregateInput = {
    id?: SortOrder
    imgUrl?: SortOrder
    title?: SortOrder
    description?: SortOrder
    userId?: SortOrder
  }

  export type UserOGPMaxOrderByAggregateInput = {
    id?: SortOrder
    imgUrl?: SortOrder
    title?: SortOrder
    description?: SortOrder
    userId?: SortOrder
  }

  export type UserOGPMinOrderByAggregateInput = {
    id?: SortOrder
    imgUrl?: SortOrder
    title?: SortOrder
    description?: SortOrder
    userId?: SortOrder
  }

  export type UserCustomQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    sortOrder?: SortOrder
    userId?: SortOrder
  }

  export type UserCustomQuestionAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type UserCustomQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    sortOrder?: SortOrder
    userId?: SortOrder
  }

  export type UserCustomQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    sortOrder?: SortOrder
    userId?: SortOrder
  }

  export type UserCustomQuestionSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type UserImageCarouselCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    imgUrl?: SortOrder
    alt?: SortOrder
    sortOrder?: SortOrder
    userId?: SortOrder
  }

  export type UserImageCarouselAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type UserImageCarouselMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    imgUrl?: SortOrder
    alt?: SortOrder
    sortOrder?: SortOrder
    userId?: SortOrder
  }

  export type UserImageCarouselMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    imgUrl?: SortOrder
    alt?: SortOrder
    sortOrder?: SortOrder
    userId?: SortOrder
  }

  export type UserImageCarouselSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type UserImageSidebarCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    imgUrl?: SortOrder
    alt?: SortOrder
    sortOrder?: SortOrder
    userId?: SortOrder
  }

  export type UserImageSidebarAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type UserImageSidebarMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    imgUrl?: SortOrder
    alt?: SortOrder
    sortOrder?: SortOrder
    userId?: SortOrder
  }

  export type UserImageSidebarMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    imgUrl?: SortOrder
    alt?: SortOrder
    sortOrder?: SortOrder
    userId?: SortOrder
  }

  export type UserImageSidebarSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type UserDisplaySettingsCountOrderByAggregateInput = {
    id?: SortOrder
    displayYoutube?: SortOrder
    displayDevice?: SortOrder
    displayFaq?: SortOrder
    displayPopup1?: SortOrder
    displayPopupBell?: SortOrder
    displayPopupEmail?: SortOrder
    displayUserList?: SortOrder
    displayOwnPage?: SortOrder
    userId?: SortOrder
  }

  export type UserDisplaySettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    displayYoutube?: SortOrder
    displayDevice?: SortOrder
    displayFaq?: SortOrder
    displayPopup1?: SortOrder
    displayPopupBell?: SortOrder
    displayPopupEmail?: SortOrder
    displayUserList?: SortOrder
    displayOwnPage?: SortOrder
    userId?: SortOrder
  }

  export type UserDisplaySettingsMinOrderByAggregateInput = {
    id?: SortOrder
    displayYoutube?: SortOrder
    displayDevice?: SortOrder
    displayFaq?: SortOrder
    displayPopup1?: SortOrder
    displayPopupBell?: SortOrder
    displayPopupEmail?: SortOrder
    displayUserList?: SortOrder
    displayOwnPage?: SortOrder
    userId?: SortOrder
  }

  export type ServiceIconListRelationFilter = {
    every?: ServiceIconWhereInput
    some?: ServiceIconWhereInput
    none?: ServiceIconWhereInput
  }

  export type ServiceIconOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LinkServiceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    baseUrl?: SortOrder
    allowOriginalIcon?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LinkServiceAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type LinkServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    baseUrl?: SortOrder
    allowOriginalIcon?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LinkServiceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    baseUrl?: SortOrder
    allowOriginalIcon?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LinkServiceSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type EnumIconStyleFilter<$PrismaModel = never> = {
    equals?: $Enums.IconStyle | EnumIconStyleFieldRefInput<$PrismaModel>
    in?: $Enums.IconStyle[] | ListEnumIconStyleFieldRefInput<$PrismaModel>
    notIn?: $Enums.IconStyle[] | ListEnumIconStyleFieldRefInput<$PrismaModel>
    not?: NestedEnumIconStyleFilter<$PrismaModel> | $Enums.IconStyle
  }

  export type EnumIconColorFilter<$PrismaModel = never> = {
    equals?: $Enums.IconColor | EnumIconColorFieldRefInput<$PrismaModel>
    in?: $Enums.IconColor[] | ListEnumIconColorFieldRefInput<$PrismaModel>
    notIn?: $Enums.IconColor[] | ListEnumIconColorFieldRefInput<$PrismaModel>
    not?: NestedEnumIconColorFilter<$PrismaModel> | $Enums.IconColor
  }

  export type ServiceIconCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    style?: SortOrder
    colorScheme?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceId?: SortOrder
  }

  export type ServiceIconAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type ServiceIconMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    style?: SortOrder
    colorScheme?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceId?: SortOrder
  }

  export type ServiceIconMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    style?: SortOrder
    colorScheme?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    serviceId?: SortOrder
  }

  export type ServiceIconSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type EnumIconStyleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IconStyle | EnumIconStyleFieldRefInput<$PrismaModel>
    in?: $Enums.IconStyle[] | ListEnumIconStyleFieldRefInput<$PrismaModel>
    notIn?: $Enums.IconStyle[] | ListEnumIconStyleFieldRefInput<$PrismaModel>
    not?: NestedEnumIconStyleWithAggregatesFilter<$PrismaModel> | $Enums.IconStyle
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIconStyleFilter<$PrismaModel>
    _max?: NestedEnumIconStyleFilter<$PrismaModel>
  }

  export type EnumIconColorWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IconColor | EnumIconColorFieldRefInput<$PrismaModel>
    in?: $Enums.IconColor[] | ListEnumIconColorFieldRefInput<$PrismaModel>
    notIn?: $Enums.IconColor[] | ListEnumIconColorFieldRefInput<$PrismaModel>
    not?: NestedEnumIconColorWithAggregatesFilter<$PrismaModel> | $Enums.IconColor
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIconColorFilter<$PrismaModel>
    _max?: NestedEnumIconColorFilter<$PrismaModel>
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type ArticleListRelationFilter = {
    every?: ArticleWhereInput
    some?: ArticleWhereInput
    none?: ArticleWhereInput
  }

  export type ArticleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuthorCountOrderByAggregateInput = {
    id?: SortOrder
    bio?: SortOrder
    profileImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type AuthorMaxOrderByAggregateInput = {
    id?: SortOrder
    bio?: SortOrder
    profileImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type AuthorMinOrderByAggregateInput = {
    id?: SortOrder
    bio?: SortOrder
    profileImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type CategoryNullableScalarRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type ArticleCategoryListRelationFilter = {
    every?: ArticleCategoryWhereInput
    some?: ArticleCategoryWhereInput
    none?: ArticleCategoryWhereInput
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArticleCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArticleTagListRelationFilter = {
    every?: ArticleTagWhereInput
    some?: ArticleTagWhereInput
    none?: ArticleTagWhereInput
  }

  export type ArticleTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumArticleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ArticleStatus | EnumArticleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ArticleStatus[] | ListEnumArticleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArticleStatus[] | ListEnumArticleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumArticleStatusFilter<$PrismaModel> | $Enums.ArticleStatus
  }

  export type AuthorScalarRelationFilter = {
    is?: AuthorWhereInput
    isNot?: AuthorWhereInput
  }

  export type ArticleCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    featuredImage?: SortOrder
    status?: SortOrder
    viewCount?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
  }

  export type ArticleAvgOrderByAggregateInput = {
    viewCount?: SortOrder
  }

  export type ArticleMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    featuredImage?: SortOrder
    status?: SortOrder
    viewCount?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
  }

  export type ArticleMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    featuredImage?: SortOrder
    status?: SortOrder
    viewCount?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorId?: SortOrder
  }

  export type ArticleSumOrderByAggregateInput = {
    viewCount?: SortOrder
  }

  export type EnumArticleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ArticleStatus | EnumArticleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ArticleStatus[] | ListEnumArticleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArticleStatus[] | ListEnumArticleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumArticleStatusWithAggregatesFilter<$PrismaModel> | $Enums.ArticleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumArticleStatusFilter<$PrismaModel>
    _max?: NestedEnumArticleStatusFilter<$PrismaModel>
  }

  export type ArticleScalarRelationFilter = {
    is?: ArticleWhereInput
    isNot?: ArticleWhereInput
  }

  export type CategoryScalarRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type ArticleCategoryArticleIdCategoryIdCompoundUniqueInput = {
    articleId: string
    categoryId: string
  }

  export type ArticleCategoryCountOrderByAggregateInput = {
    articleId?: SortOrder
    categoryId?: SortOrder
  }

  export type ArticleCategoryMaxOrderByAggregateInput = {
    articleId?: SortOrder
    categoryId?: SortOrder
  }

  export type ArticleCategoryMinOrderByAggregateInput = {
    articleId?: SortOrder
    categoryId?: SortOrder
  }

  export type TagScalarRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type ArticleTagArticleIdTagIdCompoundUniqueInput = {
    articleId: string
    tagId: string
  }

  export type ArticleTagCountOrderByAggregateInput = {
    articleId?: SortOrder
    tagId?: SortOrder
  }

  export type ArticleTagMaxOrderByAggregateInput = {
    articleId?: SortOrder
    tagId?: SortOrder
  }

  export type ArticleTagMinOrderByAggregateInput = {
    articleId?: SortOrder
    tagId?: SortOrder
  }

  export type CommentNullableScalarRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    parentId?: SortOrder
    isApproved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    articleId?: SortOrder
    userId?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    parentId?: SortOrder
    isApproved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    articleId?: SortOrder
    userId?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    parentId?: SortOrder
    isApproved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    articleId?: SortOrder
    userId?: SortOrder
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type UserOGPCreateNestedOneWithoutUserInput = {
    create?: XOR<UserOGPCreateWithoutUserInput, UserOGPUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserOGPCreateOrConnectWithoutUserInput
    connect?: UserOGPWhereUniqueInput
  }

  export type UserLinkCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLinkCreateWithoutUserInput, UserLinkUncheckedCreateWithoutUserInput> | UserLinkCreateWithoutUserInput[] | UserLinkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLinkCreateOrConnectWithoutUserInput | UserLinkCreateOrConnectWithoutUserInput[]
    createMany?: UserLinkCreateManyUserInputEnvelope
    connect?: UserLinkWhereUniqueInput | UserLinkWhereUniqueInput[]
  }

  export type UserImageBannerCreateNestedManyWithoutUserInput = {
    create?: XOR<UserImageBannerCreateWithoutUserInput, UserImageBannerUncheckedCreateWithoutUserInput> | UserImageBannerCreateWithoutUserInput[] | UserImageBannerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserImageBannerCreateOrConnectWithoutUserInput | UserImageBannerCreateOrConnectWithoutUserInput[]
    createMany?: UserImageBannerCreateManyUserInputEnvelope
    connect?: UserImageBannerWhereUniqueInput | UserImageBannerWhereUniqueInput[]
  }

  export type UserImageCarouselCreateNestedManyWithoutUserInput = {
    create?: XOR<UserImageCarouselCreateWithoutUserInput, UserImageCarouselUncheckedCreateWithoutUserInput> | UserImageCarouselCreateWithoutUserInput[] | UserImageCarouselUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserImageCarouselCreateOrConnectWithoutUserInput | UserImageCarouselCreateOrConnectWithoutUserInput[]
    createMany?: UserImageCarouselCreateManyUserInputEnvelope
    connect?: UserImageCarouselWhereUniqueInput | UserImageCarouselWhereUniqueInput[]
  }

  export type UserImageSidebarCreateNestedManyWithoutUserInput = {
    create?: XOR<UserImageSidebarCreateWithoutUserInput, UserImageSidebarUncheckedCreateWithoutUserInput> | UserImageSidebarCreateWithoutUserInput[] | UserImageSidebarUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserImageSidebarCreateOrConnectWithoutUserInput | UserImageSidebarCreateOrConnectWithoutUserInput[]
    createMany?: UserImageSidebarCreateManyUserInputEnvelope
    connect?: UserImageSidebarWhereUniqueInput | UserImageSidebarWhereUniqueInput[]
  }

  export type UserCustomQuestionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCustomQuestionCreateWithoutUserInput, UserCustomQuestionUncheckedCreateWithoutUserInput> | UserCustomQuestionCreateWithoutUserInput[] | UserCustomQuestionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCustomQuestionCreateOrConnectWithoutUserInput | UserCustomQuestionCreateOrConnectWithoutUserInput[]
    createMany?: UserCustomQuestionCreateManyUserInputEnvelope
    connect?: UserCustomQuestionWhereUniqueInput | UserCustomQuestionWhereUniqueInput[]
  }

  export type UserYoutubeSettingsCreateNestedOneWithoutUserInput = {
    create?: XOR<UserYoutubeSettingsCreateWithoutUserInput, UserYoutubeSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserYoutubeSettingsCreateOrConnectWithoutUserInput
    connect?: UserYoutubeSettingsWhereUniqueInput
  }

  export type UserRecommendYoutubeCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRecommendYoutubeCreateWithoutUserInput, UserRecommendYoutubeUncheckedCreateWithoutUserInput> | UserRecommendYoutubeCreateWithoutUserInput[] | UserRecommendYoutubeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRecommendYoutubeCreateOrConnectWithoutUserInput | UserRecommendYoutubeCreateOrConnectWithoutUserInput[]
    createMany?: UserRecommendYoutubeCreateManyUserInputEnvelope
    connect?: UserRecommendYoutubeWhereUniqueInput | UserRecommendYoutubeWhereUniqueInput[]
  }

  export type UserPopupSettingsCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPopupSettingsCreateWithoutUserInput, UserPopupSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPopupSettingsCreateOrConnectWithoutUserInput
    connect?: UserPopupSettingsWhereUniqueInput
  }

  export type UserDisplaySettingsCreateNestedOneWithoutUserInput = {
    create?: XOR<UserDisplaySettingsCreateWithoutUserInput, UserDisplaySettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserDisplaySettingsCreateOrConnectWithoutUserInput
    connect?: UserDisplaySettingsWhereUniqueInput
  }

  export type NotificationSettingsCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationSettingsCreateWithoutUserInput, NotificationSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutUserInput
    connect?: NotificationSettingsWhereUniqueInput
  }

  export type AuthorCreateNestedOneWithoutUserInput = {
    create?: XOR<AuthorCreateWithoutUserInput, AuthorUncheckedCreateWithoutUserInput>
    connectOrCreate?: AuthorCreateOrConnectWithoutUserInput
    connect?: AuthorWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type UserOGPUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserOGPCreateWithoutUserInput, UserOGPUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserOGPCreateOrConnectWithoutUserInput
    connect?: UserOGPWhereUniqueInput
  }

  export type UserLinkUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserLinkCreateWithoutUserInput, UserLinkUncheckedCreateWithoutUserInput> | UserLinkCreateWithoutUserInput[] | UserLinkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLinkCreateOrConnectWithoutUserInput | UserLinkCreateOrConnectWithoutUserInput[]
    createMany?: UserLinkCreateManyUserInputEnvelope
    connect?: UserLinkWhereUniqueInput | UserLinkWhereUniqueInput[]
  }

  export type UserImageBannerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserImageBannerCreateWithoutUserInput, UserImageBannerUncheckedCreateWithoutUserInput> | UserImageBannerCreateWithoutUserInput[] | UserImageBannerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserImageBannerCreateOrConnectWithoutUserInput | UserImageBannerCreateOrConnectWithoutUserInput[]
    createMany?: UserImageBannerCreateManyUserInputEnvelope
    connect?: UserImageBannerWhereUniqueInput | UserImageBannerWhereUniqueInput[]
  }

  export type UserImageCarouselUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserImageCarouselCreateWithoutUserInput, UserImageCarouselUncheckedCreateWithoutUserInput> | UserImageCarouselCreateWithoutUserInput[] | UserImageCarouselUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserImageCarouselCreateOrConnectWithoutUserInput | UserImageCarouselCreateOrConnectWithoutUserInput[]
    createMany?: UserImageCarouselCreateManyUserInputEnvelope
    connect?: UserImageCarouselWhereUniqueInput | UserImageCarouselWhereUniqueInput[]
  }

  export type UserImageSidebarUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserImageSidebarCreateWithoutUserInput, UserImageSidebarUncheckedCreateWithoutUserInput> | UserImageSidebarCreateWithoutUserInput[] | UserImageSidebarUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserImageSidebarCreateOrConnectWithoutUserInput | UserImageSidebarCreateOrConnectWithoutUserInput[]
    createMany?: UserImageSidebarCreateManyUserInputEnvelope
    connect?: UserImageSidebarWhereUniqueInput | UserImageSidebarWhereUniqueInput[]
  }

  export type UserCustomQuestionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCustomQuestionCreateWithoutUserInput, UserCustomQuestionUncheckedCreateWithoutUserInput> | UserCustomQuestionCreateWithoutUserInput[] | UserCustomQuestionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCustomQuestionCreateOrConnectWithoutUserInput | UserCustomQuestionCreateOrConnectWithoutUserInput[]
    createMany?: UserCustomQuestionCreateManyUserInputEnvelope
    connect?: UserCustomQuestionWhereUniqueInput | UserCustomQuestionWhereUniqueInput[]
  }

  export type UserYoutubeSettingsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserYoutubeSettingsCreateWithoutUserInput, UserYoutubeSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserYoutubeSettingsCreateOrConnectWithoutUserInput
    connect?: UserYoutubeSettingsWhereUniqueInput
  }

  export type UserRecommendYoutubeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRecommendYoutubeCreateWithoutUserInput, UserRecommendYoutubeUncheckedCreateWithoutUserInput> | UserRecommendYoutubeCreateWithoutUserInput[] | UserRecommendYoutubeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRecommendYoutubeCreateOrConnectWithoutUserInput | UserRecommendYoutubeCreateOrConnectWithoutUserInput[]
    createMany?: UserRecommendYoutubeCreateManyUserInputEnvelope
    connect?: UserRecommendYoutubeWhereUniqueInput | UserRecommendYoutubeWhereUniqueInput[]
  }

  export type UserPopupSettingsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPopupSettingsCreateWithoutUserInput, UserPopupSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPopupSettingsCreateOrConnectWithoutUserInput
    connect?: UserPopupSettingsWhereUniqueInput
  }

  export type UserDisplaySettingsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserDisplaySettingsCreateWithoutUserInput, UserDisplaySettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserDisplaySettingsCreateOrConnectWithoutUserInput
    connect?: UserDisplaySettingsWhereUniqueInput
  }

  export type NotificationSettingsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationSettingsCreateWithoutUserInput, NotificationSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutUserInput
    connect?: NotificationSettingsWhereUniqueInput
  }

  export type AuthorUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AuthorCreateWithoutUserInput, AuthorUncheckedCreateWithoutUserInput>
    connectOrCreate?: AuthorCreateOrConnectWithoutUserInput
    connect?: AuthorWhereUniqueInput
  }

  export type CommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type UserOGPUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserOGPCreateWithoutUserInput, UserOGPUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserOGPCreateOrConnectWithoutUserInput
    upsert?: UserOGPUpsertWithoutUserInput
    disconnect?: UserOGPWhereInput | boolean
    delete?: UserOGPWhereInput | boolean
    connect?: UserOGPWhereUniqueInput
    update?: XOR<XOR<UserOGPUpdateToOneWithWhereWithoutUserInput, UserOGPUpdateWithoutUserInput>, UserOGPUncheckedUpdateWithoutUserInput>
  }

  export type UserLinkUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLinkCreateWithoutUserInput, UserLinkUncheckedCreateWithoutUserInput> | UserLinkCreateWithoutUserInput[] | UserLinkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLinkCreateOrConnectWithoutUserInput | UserLinkCreateOrConnectWithoutUserInput[]
    upsert?: UserLinkUpsertWithWhereUniqueWithoutUserInput | UserLinkUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLinkCreateManyUserInputEnvelope
    set?: UserLinkWhereUniqueInput | UserLinkWhereUniqueInput[]
    disconnect?: UserLinkWhereUniqueInput | UserLinkWhereUniqueInput[]
    delete?: UserLinkWhereUniqueInput | UserLinkWhereUniqueInput[]
    connect?: UserLinkWhereUniqueInput | UserLinkWhereUniqueInput[]
    update?: UserLinkUpdateWithWhereUniqueWithoutUserInput | UserLinkUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLinkUpdateManyWithWhereWithoutUserInput | UserLinkUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLinkScalarWhereInput | UserLinkScalarWhereInput[]
  }

  export type UserImageBannerUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserImageBannerCreateWithoutUserInput, UserImageBannerUncheckedCreateWithoutUserInput> | UserImageBannerCreateWithoutUserInput[] | UserImageBannerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserImageBannerCreateOrConnectWithoutUserInput | UserImageBannerCreateOrConnectWithoutUserInput[]
    upsert?: UserImageBannerUpsertWithWhereUniqueWithoutUserInput | UserImageBannerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserImageBannerCreateManyUserInputEnvelope
    set?: UserImageBannerWhereUniqueInput | UserImageBannerWhereUniqueInput[]
    disconnect?: UserImageBannerWhereUniqueInput | UserImageBannerWhereUniqueInput[]
    delete?: UserImageBannerWhereUniqueInput | UserImageBannerWhereUniqueInput[]
    connect?: UserImageBannerWhereUniqueInput | UserImageBannerWhereUniqueInput[]
    update?: UserImageBannerUpdateWithWhereUniqueWithoutUserInput | UserImageBannerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserImageBannerUpdateManyWithWhereWithoutUserInput | UserImageBannerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserImageBannerScalarWhereInput | UserImageBannerScalarWhereInput[]
  }

  export type UserImageCarouselUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserImageCarouselCreateWithoutUserInput, UserImageCarouselUncheckedCreateWithoutUserInput> | UserImageCarouselCreateWithoutUserInput[] | UserImageCarouselUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserImageCarouselCreateOrConnectWithoutUserInput | UserImageCarouselCreateOrConnectWithoutUserInput[]
    upsert?: UserImageCarouselUpsertWithWhereUniqueWithoutUserInput | UserImageCarouselUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserImageCarouselCreateManyUserInputEnvelope
    set?: UserImageCarouselWhereUniqueInput | UserImageCarouselWhereUniqueInput[]
    disconnect?: UserImageCarouselWhereUniqueInput | UserImageCarouselWhereUniqueInput[]
    delete?: UserImageCarouselWhereUniqueInput | UserImageCarouselWhereUniqueInput[]
    connect?: UserImageCarouselWhereUniqueInput | UserImageCarouselWhereUniqueInput[]
    update?: UserImageCarouselUpdateWithWhereUniqueWithoutUserInput | UserImageCarouselUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserImageCarouselUpdateManyWithWhereWithoutUserInput | UserImageCarouselUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserImageCarouselScalarWhereInput | UserImageCarouselScalarWhereInput[]
  }

  export type UserImageSidebarUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserImageSidebarCreateWithoutUserInput, UserImageSidebarUncheckedCreateWithoutUserInput> | UserImageSidebarCreateWithoutUserInput[] | UserImageSidebarUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserImageSidebarCreateOrConnectWithoutUserInput | UserImageSidebarCreateOrConnectWithoutUserInput[]
    upsert?: UserImageSidebarUpsertWithWhereUniqueWithoutUserInput | UserImageSidebarUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserImageSidebarCreateManyUserInputEnvelope
    set?: UserImageSidebarWhereUniqueInput | UserImageSidebarWhereUniqueInput[]
    disconnect?: UserImageSidebarWhereUniqueInput | UserImageSidebarWhereUniqueInput[]
    delete?: UserImageSidebarWhereUniqueInput | UserImageSidebarWhereUniqueInput[]
    connect?: UserImageSidebarWhereUniqueInput | UserImageSidebarWhereUniqueInput[]
    update?: UserImageSidebarUpdateWithWhereUniqueWithoutUserInput | UserImageSidebarUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserImageSidebarUpdateManyWithWhereWithoutUserInput | UserImageSidebarUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserImageSidebarScalarWhereInput | UserImageSidebarScalarWhereInput[]
  }

  export type UserCustomQuestionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCustomQuestionCreateWithoutUserInput, UserCustomQuestionUncheckedCreateWithoutUserInput> | UserCustomQuestionCreateWithoutUserInput[] | UserCustomQuestionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCustomQuestionCreateOrConnectWithoutUserInput | UserCustomQuestionCreateOrConnectWithoutUserInput[]
    upsert?: UserCustomQuestionUpsertWithWhereUniqueWithoutUserInput | UserCustomQuestionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCustomQuestionCreateManyUserInputEnvelope
    set?: UserCustomQuestionWhereUniqueInput | UserCustomQuestionWhereUniqueInput[]
    disconnect?: UserCustomQuestionWhereUniqueInput | UserCustomQuestionWhereUniqueInput[]
    delete?: UserCustomQuestionWhereUniqueInput | UserCustomQuestionWhereUniqueInput[]
    connect?: UserCustomQuestionWhereUniqueInput | UserCustomQuestionWhereUniqueInput[]
    update?: UserCustomQuestionUpdateWithWhereUniqueWithoutUserInput | UserCustomQuestionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserCustomQuestionUpdateManyWithWhereWithoutUserInput | UserCustomQuestionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserCustomQuestionScalarWhereInput | UserCustomQuestionScalarWhereInput[]
  }

  export type UserYoutubeSettingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserYoutubeSettingsCreateWithoutUserInput, UserYoutubeSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserYoutubeSettingsCreateOrConnectWithoutUserInput
    upsert?: UserYoutubeSettingsUpsertWithoutUserInput
    disconnect?: UserYoutubeSettingsWhereInput | boolean
    delete?: UserYoutubeSettingsWhereInput | boolean
    connect?: UserYoutubeSettingsWhereUniqueInput
    update?: XOR<XOR<UserYoutubeSettingsUpdateToOneWithWhereWithoutUserInput, UserYoutubeSettingsUpdateWithoutUserInput>, UserYoutubeSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserRecommendYoutubeUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRecommendYoutubeCreateWithoutUserInput, UserRecommendYoutubeUncheckedCreateWithoutUserInput> | UserRecommendYoutubeCreateWithoutUserInput[] | UserRecommendYoutubeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRecommendYoutubeCreateOrConnectWithoutUserInput | UserRecommendYoutubeCreateOrConnectWithoutUserInput[]
    upsert?: UserRecommendYoutubeUpsertWithWhereUniqueWithoutUserInput | UserRecommendYoutubeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRecommendYoutubeCreateManyUserInputEnvelope
    set?: UserRecommendYoutubeWhereUniqueInput | UserRecommendYoutubeWhereUniqueInput[]
    disconnect?: UserRecommendYoutubeWhereUniqueInput | UserRecommendYoutubeWhereUniqueInput[]
    delete?: UserRecommendYoutubeWhereUniqueInput | UserRecommendYoutubeWhereUniqueInput[]
    connect?: UserRecommendYoutubeWhereUniqueInput | UserRecommendYoutubeWhereUniqueInput[]
    update?: UserRecommendYoutubeUpdateWithWhereUniqueWithoutUserInput | UserRecommendYoutubeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRecommendYoutubeUpdateManyWithWhereWithoutUserInput | UserRecommendYoutubeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRecommendYoutubeScalarWhereInput | UserRecommendYoutubeScalarWhereInput[]
  }

  export type UserPopupSettingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPopupSettingsCreateWithoutUserInput, UserPopupSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPopupSettingsCreateOrConnectWithoutUserInput
    upsert?: UserPopupSettingsUpsertWithoutUserInput
    disconnect?: UserPopupSettingsWhereInput | boolean
    delete?: UserPopupSettingsWhereInput | boolean
    connect?: UserPopupSettingsWhereUniqueInput
    update?: XOR<XOR<UserPopupSettingsUpdateToOneWithWhereWithoutUserInput, UserPopupSettingsUpdateWithoutUserInput>, UserPopupSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserDisplaySettingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserDisplaySettingsCreateWithoutUserInput, UserDisplaySettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserDisplaySettingsCreateOrConnectWithoutUserInput
    upsert?: UserDisplaySettingsUpsertWithoutUserInput
    disconnect?: UserDisplaySettingsWhereInput | boolean
    delete?: UserDisplaySettingsWhereInput | boolean
    connect?: UserDisplaySettingsWhereUniqueInput
    update?: XOR<XOR<UserDisplaySettingsUpdateToOneWithWhereWithoutUserInput, UserDisplaySettingsUpdateWithoutUserInput>, UserDisplaySettingsUncheckedUpdateWithoutUserInput>
  }

  export type NotificationSettingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationSettingsCreateWithoutUserInput, NotificationSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutUserInput
    upsert?: NotificationSettingsUpsertWithoutUserInput
    disconnect?: NotificationSettingsWhereInput | boolean
    delete?: NotificationSettingsWhereInput | boolean
    connect?: NotificationSettingsWhereUniqueInput
    update?: XOR<XOR<NotificationSettingsUpdateToOneWithWhereWithoutUserInput, NotificationSettingsUpdateWithoutUserInput>, NotificationSettingsUncheckedUpdateWithoutUserInput>
  }

  export type AuthorUpdateOneWithoutUserNestedInput = {
    create?: XOR<AuthorCreateWithoutUserInput, AuthorUncheckedCreateWithoutUserInput>
    connectOrCreate?: AuthorCreateOrConnectWithoutUserInput
    upsert?: AuthorUpsertWithoutUserInput
    disconnect?: AuthorWhereInput | boolean
    delete?: AuthorWhereInput | boolean
    connect?: AuthorWhereUniqueInput
    update?: XOR<XOR<AuthorUpdateToOneWithWhereWithoutUserInput, AuthorUpdateWithoutUserInput>, AuthorUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type UserOGPUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserOGPCreateWithoutUserInput, UserOGPUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserOGPCreateOrConnectWithoutUserInput
    upsert?: UserOGPUpsertWithoutUserInput
    disconnect?: UserOGPWhereInput | boolean
    delete?: UserOGPWhereInput | boolean
    connect?: UserOGPWhereUniqueInput
    update?: XOR<XOR<UserOGPUpdateToOneWithWhereWithoutUserInput, UserOGPUpdateWithoutUserInput>, UserOGPUncheckedUpdateWithoutUserInput>
  }

  export type UserLinkUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserLinkCreateWithoutUserInput, UserLinkUncheckedCreateWithoutUserInput> | UserLinkCreateWithoutUserInput[] | UserLinkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserLinkCreateOrConnectWithoutUserInput | UserLinkCreateOrConnectWithoutUserInput[]
    upsert?: UserLinkUpsertWithWhereUniqueWithoutUserInput | UserLinkUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserLinkCreateManyUserInputEnvelope
    set?: UserLinkWhereUniqueInput | UserLinkWhereUniqueInput[]
    disconnect?: UserLinkWhereUniqueInput | UserLinkWhereUniqueInput[]
    delete?: UserLinkWhereUniqueInput | UserLinkWhereUniqueInput[]
    connect?: UserLinkWhereUniqueInput | UserLinkWhereUniqueInput[]
    update?: UserLinkUpdateWithWhereUniqueWithoutUserInput | UserLinkUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserLinkUpdateManyWithWhereWithoutUserInput | UserLinkUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserLinkScalarWhereInput | UserLinkScalarWhereInput[]
  }

  export type UserImageBannerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserImageBannerCreateWithoutUserInput, UserImageBannerUncheckedCreateWithoutUserInput> | UserImageBannerCreateWithoutUserInput[] | UserImageBannerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserImageBannerCreateOrConnectWithoutUserInput | UserImageBannerCreateOrConnectWithoutUserInput[]
    upsert?: UserImageBannerUpsertWithWhereUniqueWithoutUserInput | UserImageBannerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserImageBannerCreateManyUserInputEnvelope
    set?: UserImageBannerWhereUniqueInput | UserImageBannerWhereUniqueInput[]
    disconnect?: UserImageBannerWhereUniqueInput | UserImageBannerWhereUniqueInput[]
    delete?: UserImageBannerWhereUniqueInput | UserImageBannerWhereUniqueInput[]
    connect?: UserImageBannerWhereUniqueInput | UserImageBannerWhereUniqueInput[]
    update?: UserImageBannerUpdateWithWhereUniqueWithoutUserInput | UserImageBannerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserImageBannerUpdateManyWithWhereWithoutUserInput | UserImageBannerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserImageBannerScalarWhereInput | UserImageBannerScalarWhereInput[]
  }

  export type UserImageCarouselUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserImageCarouselCreateWithoutUserInput, UserImageCarouselUncheckedCreateWithoutUserInput> | UserImageCarouselCreateWithoutUserInput[] | UserImageCarouselUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserImageCarouselCreateOrConnectWithoutUserInput | UserImageCarouselCreateOrConnectWithoutUserInput[]
    upsert?: UserImageCarouselUpsertWithWhereUniqueWithoutUserInput | UserImageCarouselUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserImageCarouselCreateManyUserInputEnvelope
    set?: UserImageCarouselWhereUniqueInput | UserImageCarouselWhereUniqueInput[]
    disconnect?: UserImageCarouselWhereUniqueInput | UserImageCarouselWhereUniqueInput[]
    delete?: UserImageCarouselWhereUniqueInput | UserImageCarouselWhereUniqueInput[]
    connect?: UserImageCarouselWhereUniqueInput | UserImageCarouselWhereUniqueInput[]
    update?: UserImageCarouselUpdateWithWhereUniqueWithoutUserInput | UserImageCarouselUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserImageCarouselUpdateManyWithWhereWithoutUserInput | UserImageCarouselUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserImageCarouselScalarWhereInput | UserImageCarouselScalarWhereInput[]
  }

  export type UserImageSidebarUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserImageSidebarCreateWithoutUserInput, UserImageSidebarUncheckedCreateWithoutUserInput> | UserImageSidebarCreateWithoutUserInput[] | UserImageSidebarUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserImageSidebarCreateOrConnectWithoutUserInput | UserImageSidebarCreateOrConnectWithoutUserInput[]
    upsert?: UserImageSidebarUpsertWithWhereUniqueWithoutUserInput | UserImageSidebarUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserImageSidebarCreateManyUserInputEnvelope
    set?: UserImageSidebarWhereUniqueInput | UserImageSidebarWhereUniqueInput[]
    disconnect?: UserImageSidebarWhereUniqueInput | UserImageSidebarWhereUniqueInput[]
    delete?: UserImageSidebarWhereUniqueInput | UserImageSidebarWhereUniqueInput[]
    connect?: UserImageSidebarWhereUniqueInput | UserImageSidebarWhereUniqueInput[]
    update?: UserImageSidebarUpdateWithWhereUniqueWithoutUserInput | UserImageSidebarUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserImageSidebarUpdateManyWithWhereWithoutUserInput | UserImageSidebarUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserImageSidebarScalarWhereInput | UserImageSidebarScalarWhereInput[]
  }

  export type UserCustomQuestionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCustomQuestionCreateWithoutUserInput, UserCustomQuestionUncheckedCreateWithoutUserInput> | UserCustomQuestionCreateWithoutUserInput[] | UserCustomQuestionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCustomQuestionCreateOrConnectWithoutUserInput | UserCustomQuestionCreateOrConnectWithoutUserInput[]
    upsert?: UserCustomQuestionUpsertWithWhereUniqueWithoutUserInput | UserCustomQuestionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCustomQuestionCreateManyUserInputEnvelope
    set?: UserCustomQuestionWhereUniqueInput | UserCustomQuestionWhereUniqueInput[]
    disconnect?: UserCustomQuestionWhereUniqueInput | UserCustomQuestionWhereUniqueInput[]
    delete?: UserCustomQuestionWhereUniqueInput | UserCustomQuestionWhereUniqueInput[]
    connect?: UserCustomQuestionWhereUniqueInput | UserCustomQuestionWhereUniqueInput[]
    update?: UserCustomQuestionUpdateWithWhereUniqueWithoutUserInput | UserCustomQuestionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserCustomQuestionUpdateManyWithWhereWithoutUserInput | UserCustomQuestionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserCustomQuestionScalarWhereInput | UserCustomQuestionScalarWhereInput[]
  }

  export type UserYoutubeSettingsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserYoutubeSettingsCreateWithoutUserInput, UserYoutubeSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserYoutubeSettingsCreateOrConnectWithoutUserInput
    upsert?: UserYoutubeSettingsUpsertWithoutUserInput
    disconnect?: UserYoutubeSettingsWhereInput | boolean
    delete?: UserYoutubeSettingsWhereInput | boolean
    connect?: UserYoutubeSettingsWhereUniqueInput
    update?: XOR<XOR<UserYoutubeSettingsUpdateToOneWithWhereWithoutUserInput, UserYoutubeSettingsUpdateWithoutUserInput>, UserYoutubeSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserRecommendYoutubeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRecommendYoutubeCreateWithoutUserInput, UserRecommendYoutubeUncheckedCreateWithoutUserInput> | UserRecommendYoutubeCreateWithoutUserInput[] | UserRecommendYoutubeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRecommendYoutubeCreateOrConnectWithoutUserInput | UserRecommendYoutubeCreateOrConnectWithoutUserInput[]
    upsert?: UserRecommendYoutubeUpsertWithWhereUniqueWithoutUserInput | UserRecommendYoutubeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRecommendYoutubeCreateManyUserInputEnvelope
    set?: UserRecommendYoutubeWhereUniqueInput | UserRecommendYoutubeWhereUniqueInput[]
    disconnect?: UserRecommendYoutubeWhereUniqueInput | UserRecommendYoutubeWhereUniqueInput[]
    delete?: UserRecommendYoutubeWhereUniqueInput | UserRecommendYoutubeWhereUniqueInput[]
    connect?: UserRecommendYoutubeWhereUniqueInput | UserRecommendYoutubeWhereUniqueInput[]
    update?: UserRecommendYoutubeUpdateWithWhereUniqueWithoutUserInput | UserRecommendYoutubeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRecommendYoutubeUpdateManyWithWhereWithoutUserInput | UserRecommendYoutubeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRecommendYoutubeScalarWhereInput | UserRecommendYoutubeScalarWhereInput[]
  }

  export type UserPopupSettingsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPopupSettingsCreateWithoutUserInput, UserPopupSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPopupSettingsCreateOrConnectWithoutUserInput
    upsert?: UserPopupSettingsUpsertWithoutUserInput
    disconnect?: UserPopupSettingsWhereInput | boolean
    delete?: UserPopupSettingsWhereInput | boolean
    connect?: UserPopupSettingsWhereUniqueInput
    update?: XOR<XOR<UserPopupSettingsUpdateToOneWithWhereWithoutUserInput, UserPopupSettingsUpdateWithoutUserInput>, UserPopupSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserDisplaySettingsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserDisplaySettingsCreateWithoutUserInput, UserDisplaySettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserDisplaySettingsCreateOrConnectWithoutUserInput
    upsert?: UserDisplaySettingsUpsertWithoutUserInput
    disconnect?: UserDisplaySettingsWhereInput | boolean
    delete?: UserDisplaySettingsWhereInput | boolean
    connect?: UserDisplaySettingsWhereUniqueInput
    update?: XOR<XOR<UserDisplaySettingsUpdateToOneWithWhereWithoutUserInput, UserDisplaySettingsUpdateWithoutUserInput>, UserDisplaySettingsUncheckedUpdateWithoutUserInput>
  }

  export type NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationSettingsCreateWithoutUserInput, NotificationSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutUserInput
    upsert?: NotificationSettingsUpsertWithoutUserInput
    disconnect?: NotificationSettingsWhereInput | boolean
    delete?: NotificationSettingsWhereInput | boolean
    connect?: NotificationSettingsWhereUniqueInput
    update?: XOR<XOR<NotificationSettingsUpdateToOneWithWhereWithoutUserInput, NotificationSettingsUpdateWithoutUserInput>, NotificationSettingsUncheckedUpdateWithoutUserInput>
  }

  export type AuthorUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AuthorCreateWithoutUserInput, AuthorUncheckedCreateWithoutUserInput>
    connectOrCreate?: AuthorCreateOrConnectWithoutUserInput
    upsert?: AuthorUpsertWithoutUserInput
    disconnect?: AuthorWhereInput | boolean
    delete?: AuthorWhereInput | boolean
    connect?: AuthorWhereUniqueInput
    update?: XOR<XOR<AuthorUpdateToOneWithWhereWithoutUserInput, AuthorUpdateWithoutUserInput>, AuthorUncheckedUpdateWithoutUserInput>
  }

  export type CommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutNotificationSettingsInput = {
    create?: XOR<UserCreateWithoutNotificationSettingsInput, UserUncheckedCreateWithoutNotificationSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationSettingsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationSettingsInput, UserUncheckedCreateWithoutNotificationSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationSettingsInput
    upsert?: UserUpsertWithoutNotificationSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationSettingsInput, UserUpdateWithoutNotificationSettingsInput>, UserUncheckedUpdateWithoutNotificationSettingsInput>
  }

  export type UserCreateNestedOneWithoutLinksInput = {
    create?: XOR<UserCreateWithoutLinksInput, UserUncheckedCreateWithoutLinksInput>
    connectOrCreate?: UserCreateOrConnectWithoutLinksInput
    connect?: UserWhereUniqueInput
  }

  export type LinkServiceCreateNestedOneWithoutLinksInput = {
    create?: XOR<LinkServiceCreateWithoutLinksInput, LinkServiceUncheckedCreateWithoutLinksInput>
    connectOrCreate?: LinkServiceCreateOrConnectWithoutLinksInput
    connect?: LinkServiceWhereUniqueInput
  }

  export type ServiceIconCreateNestedOneWithoutLinksInput = {
    create?: XOR<ServiceIconCreateWithoutLinksInput, ServiceIconUncheckedCreateWithoutLinksInput>
    connectOrCreate?: ServiceIconCreateOrConnectWithoutLinksInput
    connect?: ServiceIconWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLinksNestedInput = {
    create?: XOR<UserCreateWithoutLinksInput, UserUncheckedCreateWithoutLinksInput>
    connectOrCreate?: UserCreateOrConnectWithoutLinksInput
    upsert?: UserUpsertWithoutLinksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLinksInput, UserUpdateWithoutLinksInput>, UserUncheckedUpdateWithoutLinksInput>
  }

  export type LinkServiceUpdateOneRequiredWithoutLinksNestedInput = {
    create?: XOR<LinkServiceCreateWithoutLinksInput, LinkServiceUncheckedCreateWithoutLinksInput>
    connectOrCreate?: LinkServiceCreateOrConnectWithoutLinksInput
    upsert?: LinkServiceUpsertWithoutLinksInput
    connect?: LinkServiceWhereUniqueInput
    update?: XOR<XOR<LinkServiceUpdateToOneWithWhereWithoutLinksInput, LinkServiceUpdateWithoutLinksInput>, LinkServiceUncheckedUpdateWithoutLinksInput>
  }

  export type ServiceIconUpdateOneWithoutLinksNestedInput = {
    create?: XOR<ServiceIconCreateWithoutLinksInput, ServiceIconUncheckedCreateWithoutLinksInput>
    connectOrCreate?: ServiceIconCreateOrConnectWithoutLinksInput
    upsert?: ServiceIconUpsertWithoutLinksInput
    disconnect?: ServiceIconWhereInput | boolean
    delete?: ServiceIconWhereInput | boolean
    connect?: ServiceIconWhereUniqueInput
    update?: XOR<XOR<ServiceIconUpdateToOneWithWhereWithoutLinksInput, ServiceIconUpdateWithoutLinksInput>, ServiceIconUncheckedUpdateWithoutLinksInput>
  }

  export type UserCreateNestedOneWithoutYoutubeSettingsInput = {
    create?: XOR<UserCreateWithoutYoutubeSettingsInput, UserUncheckedCreateWithoutYoutubeSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutYoutubeSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserYoutubeVideoCreateNestedManyWithoutSettingsInput = {
    create?: XOR<UserYoutubeVideoCreateWithoutSettingsInput, UserYoutubeVideoUncheckedCreateWithoutSettingsInput> | UserYoutubeVideoCreateWithoutSettingsInput[] | UserYoutubeVideoUncheckedCreateWithoutSettingsInput[]
    connectOrCreate?: UserYoutubeVideoCreateOrConnectWithoutSettingsInput | UserYoutubeVideoCreateOrConnectWithoutSettingsInput[]
    createMany?: UserYoutubeVideoCreateManySettingsInputEnvelope
    connect?: UserYoutubeVideoWhereUniqueInput | UserYoutubeVideoWhereUniqueInput[]
  }

  export type UserYoutubeVideoUncheckedCreateNestedManyWithoutSettingsInput = {
    create?: XOR<UserYoutubeVideoCreateWithoutSettingsInput, UserYoutubeVideoUncheckedCreateWithoutSettingsInput> | UserYoutubeVideoCreateWithoutSettingsInput[] | UserYoutubeVideoUncheckedCreateWithoutSettingsInput[]
    connectOrCreate?: UserYoutubeVideoCreateOrConnectWithoutSettingsInput | UserYoutubeVideoCreateOrConnectWithoutSettingsInput[]
    createMany?: UserYoutubeVideoCreateManySettingsInputEnvelope
    connect?: UserYoutubeVideoWhereUniqueInput | UserYoutubeVideoWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutYoutubeSettingsNestedInput = {
    create?: XOR<UserCreateWithoutYoutubeSettingsInput, UserUncheckedCreateWithoutYoutubeSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutYoutubeSettingsInput
    upsert?: UserUpsertWithoutYoutubeSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutYoutubeSettingsInput, UserUpdateWithoutYoutubeSettingsInput>, UserUncheckedUpdateWithoutYoutubeSettingsInput>
  }

  export type UserYoutubeVideoUpdateManyWithoutSettingsNestedInput = {
    create?: XOR<UserYoutubeVideoCreateWithoutSettingsInput, UserYoutubeVideoUncheckedCreateWithoutSettingsInput> | UserYoutubeVideoCreateWithoutSettingsInput[] | UserYoutubeVideoUncheckedCreateWithoutSettingsInput[]
    connectOrCreate?: UserYoutubeVideoCreateOrConnectWithoutSettingsInput | UserYoutubeVideoCreateOrConnectWithoutSettingsInput[]
    upsert?: UserYoutubeVideoUpsertWithWhereUniqueWithoutSettingsInput | UserYoutubeVideoUpsertWithWhereUniqueWithoutSettingsInput[]
    createMany?: UserYoutubeVideoCreateManySettingsInputEnvelope
    set?: UserYoutubeVideoWhereUniqueInput | UserYoutubeVideoWhereUniqueInput[]
    disconnect?: UserYoutubeVideoWhereUniqueInput | UserYoutubeVideoWhereUniqueInput[]
    delete?: UserYoutubeVideoWhereUniqueInput | UserYoutubeVideoWhereUniqueInput[]
    connect?: UserYoutubeVideoWhereUniqueInput | UserYoutubeVideoWhereUniqueInput[]
    update?: UserYoutubeVideoUpdateWithWhereUniqueWithoutSettingsInput | UserYoutubeVideoUpdateWithWhereUniqueWithoutSettingsInput[]
    updateMany?: UserYoutubeVideoUpdateManyWithWhereWithoutSettingsInput | UserYoutubeVideoUpdateManyWithWhereWithoutSettingsInput[]
    deleteMany?: UserYoutubeVideoScalarWhereInput | UserYoutubeVideoScalarWhereInput[]
  }

  export type UserYoutubeVideoUncheckedUpdateManyWithoutSettingsNestedInput = {
    create?: XOR<UserYoutubeVideoCreateWithoutSettingsInput, UserYoutubeVideoUncheckedCreateWithoutSettingsInput> | UserYoutubeVideoCreateWithoutSettingsInput[] | UserYoutubeVideoUncheckedCreateWithoutSettingsInput[]
    connectOrCreate?: UserYoutubeVideoCreateOrConnectWithoutSettingsInput | UserYoutubeVideoCreateOrConnectWithoutSettingsInput[]
    upsert?: UserYoutubeVideoUpsertWithWhereUniqueWithoutSettingsInput | UserYoutubeVideoUpsertWithWhereUniqueWithoutSettingsInput[]
    createMany?: UserYoutubeVideoCreateManySettingsInputEnvelope
    set?: UserYoutubeVideoWhereUniqueInput | UserYoutubeVideoWhereUniqueInput[]
    disconnect?: UserYoutubeVideoWhereUniqueInput | UserYoutubeVideoWhereUniqueInput[]
    delete?: UserYoutubeVideoWhereUniqueInput | UserYoutubeVideoWhereUniqueInput[]
    connect?: UserYoutubeVideoWhereUniqueInput | UserYoutubeVideoWhereUniqueInput[]
    update?: UserYoutubeVideoUpdateWithWhereUniqueWithoutSettingsInput | UserYoutubeVideoUpdateWithWhereUniqueWithoutSettingsInput[]
    updateMany?: UserYoutubeVideoUpdateManyWithWhereWithoutSettingsInput | UserYoutubeVideoUpdateManyWithWhereWithoutSettingsInput[]
    deleteMany?: UserYoutubeVideoScalarWhereInput | UserYoutubeVideoScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutImageBannersInput = {
    create?: XOR<UserCreateWithoutImageBannersInput, UserUncheckedCreateWithoutImageBannersInput>
    connectOrCreate?: UserCreateOrConnectWithoutImageBannersInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutImageBannersNestedInput = {
    create?: XOR<UserCreateWithoutImageBannersInput, UserUncheckedCreateWithoutImageBannersInput>
    connectOrCreate?: UserCreateOrConnectWithoutImageBannersInput
    upsert?: UserUpsertWithoutImageBannersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutImageBannersInput, UserUpdateWithoutImageBannersInput>, UserUncheckedUpdateWithoutImageBannersInput>
  }

  export type UserYoutubeSettingsCreateNestedOneWithoutVideosInput = {
    create?: XOR<UserYoutubeSettingsCreateWithoutVideosInput, UserYoutubeSettingsUncheckedCreateWithoutVideosInput>
    connectOrCreate?: UserYoutubeSettingsCreateOrConnectWithoutVideosInput
    connect?: UserYoutubeSettingsWhereUniqueInput
  }

  export type UserYoutubeSettingsUpdateOneRequiredWithoutVideosNestedInput = {
    create?: XOR<UserYoutubeSettingsCreateWithoutVideosInput, UserYoutubeSettingsUncheckedCreateWithoutVideosInput>
    connectOrCreate?: UserYoutubeSettingsCreateOrConnectWithoutVideosInput
    upsert?: UserYoutubeSettingsUpsertWithoutVideosInput
    connect?: UserYoutubeSettingsWhereUniqueInput
    update?: XOR<XOR<UserYoutubeSettingsUpdateToOneWithWhereWithoutVideosInput, UserYoutubeSettingsUpdateWithoutVideosInput>, UserYoutubeSettingsUncheckedUpdateWithoutVideosInput>
  }

  export type UserCreateNestedOneWithoutRecommendYoutubesInput = {
    create?: XOR<UserCreateWithoutRecommendYoutubesInput, UserUncheckedCreateWithoutRecommendYoutubesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecommendYoutubesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRecommendYoutubesNestedInput = {
    create?: XOR<UserCreateWithoutRecommendYoutubesInput, UserUncheckedCreateWithoutRecommendYoutubesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecommendYoutubesInput
    upsert?: UserUpsertWithoutRecommendYoutubesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRecommendYoutubesInput, UserUpdateWithoutRecommendYoutubesInput>, UserUncheckedUpdateWithoutRecommendYoutubesInput>
  }

  export type UserCreateNestedOneWithoutPopupSettingsInput = {
    create?: XOR<UserCreateWithoutPopupSettingsInput, UserUncheckedCreateWithoutPopupSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPopupSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPopupSettingsNestedInput = {
    create?: XOR<UserCreateWithoutPopupSettingsInput, UserUncheckedCreateWithoutPopupSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPopupSettingsInput
    upsert?: UserUpsertWithoutPopupSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPopupSettingsInput, UserUpdateWithoutPopupSettingsInput>, UserUncheckedUpdateWithoutPopupSettingsInput>
  }

  export type UserCreateNestedOneWithoutOgpInput = {
    create?: XOR<UserCreateWithoutOgpInput, UserUncheckedCreateWithoutOgpInput>
    connectOrCreate?: UserCreateOrConnectWithoutOgpInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutOgpNestedInput = {
    create?: XOR<UserCreateWithoutOgpInput, UserUncheckedCreateWithoutOgpInput>
    connectOrCreate?: UserCreateOrConnectWithoutOgpInput
    upsert?: UserUpsertWithoutOgpInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOgpInput, UserUpdateWithoutOgpInput>, UserUncheckedUpdateWithoutOgpInput>
  }

  export type UserCreateNestedOneWithoutCustomQuestionsInput = {
    create?: XOR<UserCreateWithoutCustomQuestionsInput, UserUncheckedCreateWithoutCustomQuestionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomQuestionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCustomQuestionsNestedInput = {
    create?: XOR<UserCreateWithoutCustomQuestionsInput, UserUncheckedCreateWithoutCustomQuestionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomQuestionsInput
    upsert?: UserUpsertWithoutCustomQuestionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCustomQuestionsInput, UserUpdateWithoutCustomQuestionsInput>, UserUncheckedUpdateWithoutCustomQuestionsInput>
  }

  export type UserCreateNestedOneWithoutImageCarouselsInput = {
    create?: XOR<UserCreateWithoutImageCarouselsInput, UserUncheckedCreateWithoutImageCarouselsInput>
    connectOrCreate?: UserCreateOrConnectWithoutImageCarouselsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutImageCarouselsNestedInput = {
    create?: XOR<UserCreateWithoutImageCarouselsInput, UserUncheckedCreateWithoutImageCarouselsInput>
    connectOrCreate?: UserCreateOrConnectWithoutImageCarouselsInput
    upsert?: UserUpsertWithoutImageCarouselsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutImageCarouselsInput, UserUpdateWithoutImageCarouselsInput>, UserUncheckedUpdateWithoutImageCarouselsInput>
  }

  export type UserCreateNestedOneWithoutImageSidebarsInput = {
    create?: XOR<UserCreateWithoutImageSidebarsInput, UserUncheckedCreateWithoutImageSidebarsInput>
    connectOrCreate?: UserCreateOrConnectWithoutImageSidebarsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutImageSidebarsNestedInput = {
    create?: XOR<UserCreateWithoutImageSidebarsInput, UserUncheckedCreateWithoutImageSidebarsInput>
    connectOrCreate?: UserCreateOrConnectWithoutImageSidebarsInput
    upsert?: UserUpsertWithoutImageSidebarsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutImageSidebarsInput, UserUpdateWithoutImageSidebarsInput>, UserUncheckedUpdateWithoutImageSidebarsInput>
  }

  export type UserCreateNestedOneWithoutDisplaySettingsInput = {
    create?: XOR<UserCreateWithoutDisplaySettingsInput, UserUncheckedCreateWithoutDisplaySettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDisplaySettingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDisplaySettingsNestedInput = {
    create?: XOR<UserCreateWithoutDisplaySettingsInput, UserUncheckedCreateWithoutDisplaySettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDisplaySettingsInput
    upsert?: UserUpsertWithoutDisplaySettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDisplaySettingsInput, UserUpdateWithoutDisplaySettingsInput>, UserUncheckedUpdateWithoutDisplaySettingsInput>
  }

  export type ServiceIconCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceIconCreateWithoutServiceInput, ServiceIconUncheckedCreateWithoutServiceInput> | ServiceIconCreateWithoutServiceInput[] | ServiceIconUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceIconCreateOrConnectWithoutServiceInput | ServiceIconCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceIconCreateManyServiceInputEnvelope
    connect?: ServiceIconWhereUniqueInput | ServiceIconWhereUniqueInput[]
  }

  export type UserLinkCreateNestedManyWithoutServiceInput = {
    create?: XOR<UserLinkCreateWithoutServiceInput, UserLinkUncheckedCreateWithoutServiceInput> | UserLinkCreateWithoutServiceInput[] | UserLinkUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: UserLinkCreateOrConnectWithoutServiceInput | UserLinkCreateOrConnectWithoutServiceInput[]
    createMany?: UserLinkCreateManyServiceInputEnvelope
    connect?: UserLinkWhereUniqueInput | UserLinkWhereUniqueInput[]
  }

  export type ServiceIconUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceIconCreateWithoutServiceInput, ServiceIconUncheckedCreateWithoutServiceInput> | ServiceIconCreateWithoutServiceInput[] | ServiceIconUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceIconCreateOrConnectWithoutServiceInput | ServiceIconCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceIconCreateManyServiceInputEnvelope
    connect?: ServiceIconWhereUniqueInput | ServiceIconWhereUniqueInput[]
  }

  export type UserLinkUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<UserLinkCreateWithoutServiceInput, UserLinkUncheckedCreateWithoutServiceInput> | UserLinkCreateWithoutServiceInput[] | UserLinkUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: UserLinkCreateOrConnectWithoutServiceInput | UserLinkCreateOrConnectWithoutServiceInput[]
    createMany?: UserLinkCreateManyServiceInputEnvelope
    connect?: UserLinkWhereUniqueInput | UserLinkWhereUniqueInput[]
  }

  export type ServiceIconUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceIconCreateWithoutServiceInput, ServiceIconUncheckedCreateWithoutServiceInput> | ServiceIconCreateWithoutServiceInput[] | ServiceIconUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceIconCreateOrConnectWithoutServiceInput | ServiceIconCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceIconUpsertWithWhereUniqueWithoutServiceInput | ServiceIconUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceIconCreateManyServiceInputEnvelope
    set?: ServiceIconWhereUniqueInput | ServiceIconWhereUniqueInput[]
    disconnect?: ServiceIconWhereUniqueInput | ServiceIconWhereUniqueInput[]
    delete?: ServiceIconWhereUniqueInput | ServiceIconWhereUniqueInput[]
    connect?: ServiceIconWhereUniqueInput | ServiceIconWhereUniqueInput[]
    update?: ServiceIconUpdateWithWhereUniqueWithoutServiceInput | ServiceIconUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceIconUpdateManyWithWhereWithoutServiceInput | ServiceIconUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceIconScalarWhereInput | ServiceIconScalarWhereInput[]
  }

  export type UserLinkUpdateManyWithoutServiceNestedInput = {
    create?: XOR<UserLinkCreateWithoutServiceInput, UserLinkUncheckedCreateWithoutServiceInput> | UserLinkCreateWithoutServiceInput[] | UserLinkUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: UserLinkCreateOrConnectWithoutServiceInput | UserLinkCreateOrConnectWithoutServiceInput[]
    upsert?: UserLinkUpsertWithWhereUniqueWithoutServiceInput | UserLinkUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: UserLinkCreateManyServiceInputEnvelope
    set?: UserLinkWhereUniqueInput | UserLinkWhereUniqueInput[]
    disconnect?: UserLinkWhereUniqueInput | UserLinkWhereUniqueInput[]
    delete?: UserLinkWhereUniqueInput | UserLinkWhereUniqueInput[]
    connect?: UserLinkWhereUniqueInput | UserLinkWhereUniqueInput[]
    update?: UserLinkUpdateWithWhereUniqueWithoutServiceInput | UserLinkUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: UserLinkUpdateManyWithWhereWithoutServiceInput | UserLinkUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: UserLinkScalarWhereInput | UserLinkScalarWhereInput[]
  }

  export type ServiceIconUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceIconCreateWithoutServiceInput, ServiceIconUncheckedCreateWithoutServiceInput> | ServiceIconCreateWithoutServiceInput[] | ServiceIconUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceIconCreateOrConnectWithoutServiceInput | ServiceIconCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceIconUpsertWithWhereUniqueWithoutServiceInput | ServiceIconUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceIconCreateManyServiceInputEnvelope
    set?: ServiceIconWhereUniqueInput | ServiceIconWhereUniqueInput[]
    disconnect?: ServiceIconWhereUniqueInput | ServiceIconWhereUniqueInput[]
    delete?: ServiceIconWhereUniqueInput | ServiceIconWhereUniqueInput[]
    connect?: ServiceIconWhereUniqueInput | ServiceIconWhereUniqueInput[]
    update?: ServiceIconUpdateWithWhereUniqueWithoutServiceInput | ServiceIconUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceIconUpdateManyWithWhereWithoutServiceInput | ServiceIconUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceIconScalarWhereInput | ServiceIconScalarWhereInput[]
  }

  export type UserLinkUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<UserLinkCreateWithoutServiceInput, UserLinkUncheckedCreateWithoutServiceInput> | UserLinkCreateWithoutServiceInput[] | UserLinkUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: UserLinkCreateOrConnectWithoutServiceInput | UserLinkCreateOrConnectWithoutServiceInput[]
    upsert?: UserLinkUpsertWithWhereUniqueWithoutServiceInput | UserLinkUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: UserLinkCreateManyServiceInputEnvelope
    set?: UserLinkWhereUniqueInput | UserLinkWhereUniqueInput[]
    disconnect?: UserLinkWhereUniqueInput | UserLinkWhereUniqueInput[]
    delete?: UserLinkWhereUniqueInput | UserLinkWhereUniqueInput[]
    connect?: UserLinkWhereUniqueInput | UserLinkWhereUniqueInput[]
    update?: UserLinkUpdateWithWhereUniqueWithoutServiceInput | UserLinkUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: UserLinkUpdateManyWithWhereWithoutServiceInput | UserLinkUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: UserLinkScalarWhereInput | UserLinkScalarWhereInput[]
  }

  export type LinkServiceCreateNestedOneWithoutIconsInput = {
    create?: XOR<LinkServiceCreateWithoutIconsInput, LinkServiceUncheckedCreateWithoutIconsInput>
    connectOrCreate?: LinkServiceCreateOrConnectWithoutIconsInput
    connect?: LinkServiceWhereUniqueInput
  }

  export type UserLinkCreateNestedManyWithoutIconInput = {
    create?: XOR<UserLinkCreateWithoutIconInput, UserLinkUncheckedCreateWithoutIconInput> | UserLinkCreateWithoutIconInput[] | UserLinkUncheckedCreateWithoutIconInput[]
    connectOrCreate?: UserLinkCreateOrConnectWithoutIconInput | UserLinkCreateOrConnectWithoutIconInput[]
    createMany?: UserLinkCreateManyIconInputEnvelope
    connect?: UserLinkWhereUniqueInput | UserLinkWhereUniqueInput[]
  }

  export type UserLinkUncheckedCreateNestedManyWithoutIconInput = {
    create?: XOR<UserLinkCreateWithoutIconInput, UserLinkUncheckedCreateWithoutIconInput> | UserLinkCreateWithoutIconInput[] | UserLinkUncheckedCreateWithoutIconInput[]
    connectOrCreate?: UserLinkCreateOrConnectWithoutIconInput | UserLinkCreateOrConnectWithoutIconInput[]
    createMany?: UserLinkCreateManyIconInputEnvelope
    connect?: UserLinkWhereUniqueInput | UserLinkWhereUniqueInput[]
  }

  export type EnumIconStyleFieldUpdateOperationsInput = {
    set?: $Enums.IconStyle
  }

  export type EnumIconColorFieldUpdateOperationsInput = {
    set?: $Enums.IconColor
  }

  export type LinkServiceUpdateOneRequiredWithoutIconsNestedInput = {
    create?: XOR<LinkServiceCreateWithoutIconsInput, LinkServiceUncheckedCreateWithoutIconsInput>
    connectOrCreate?: LinkServiceCreateOrConnectWithoutIconsInput
    upsert?: LinkServiceUpsertWithoutIconsInput
    connect?: LinkServiceWhereUniqueInput
    update?: XOR<XOR<LinkServiceUpdateToOneWithWhereWithoutIconsInput, LinkServiceUpdateWithoutIconsInput>, LinkServiceUncheckedUpdateWithoutIconsInput>
  }

  export type UserLinkUpdateManyWithoutIconNestedInput = {
    create?: XOR<UserLinkCreateWithoutIconInput, UserLinkUncheckedCreateWithoutIconInput> | UserLinkCreateWithoutIconInput[] | UserLinkUncheckedCreateWithoutIconInput[]
    connectOrCreate?: UserLinkCreateOrConnectWithoutIconInput | UserLinkCreateOrConnectWithoutIconInput[]
    upsert?: UserLinkUpsertWithWhereUniqueWithoutIconInput | UserLinkUpsertWithWhereUniqueWithoutIconInput[]
    createMany?: UserLinkCreateManyIconInputEnvelope
    set?: UserLinkWhereUniqueInput | UserLinkWhereUniqueInput[]
    disconnect?: UserLinkWhereUniqueInput | UserLinkWhereUniqueInput[]
    delete?: UserLinkWhereUniqueInput | UserLinkWhereUniqueInput[]
    connect?: UserLinkWhereUniqueInput | UserLinkWhereUniqueInput[]
    update?: UserLinkUpdateWithWhereUniqueWithoutIconInput | UserLinkUpdateWithWhereUniqueWithoutIconInput[]
    updateMany?: UserLinkUpdateManyWithWhereWithoutIconInput | UserLinkUpdateManyWithWhereWithoutIconInput[]
    deleteMany?: UserLinkScalarWhereInput | UserLinkScalarWhereInput[]
  }

  export type UserLinkUncheckedUpdateManyWithoutIconNestedInput = {
    create?: XOR<UserLinkCreateWithoutIconInput, UserLinkUncheckedCreateWithoutIconInput> | UserLinkCreateWithoutIconInput[] | UserLinkUncheckedCreateWithoutIconInput[]
    connectOrCreate?: UserLinkCreateOrConnectWithoutIconInput | UserLinkCreateOrConnectWithoutIconInput[]
    upsert?: UserLinkUpsertWithWhereUniqueWithoutIconInput | UserLinkUpsertWithWhereUniqueWithoutIconInput[]
    createMany?: UserLinkCreateManyIconInputEnvelope
    set?: UserLinkWhereUniqueInput | UserLinkWhereUniqueInput[]
    disconnect?: UserLinkWhereUniqueInput | UserLinkWhereUniqueInput[]
    delete?: UserLinkWhereUniqueInput | UserLinkWhereUniqueInput[]
    connect?: UserLinkWhereUniqueInput | UserLinkWhereUniqueInput[]
    update?: UserLinkUpdateWithWhereUniqueWithoutIconInput | UserLinkUpdateWithWhereUniqueWithoutIconInput[]
    updateMany?: UserLinkUpdateManyWithWhereWithoutIconInput | UserLinkUpdateManyWithWhereWithoutIconInput[]
    deleteMany?: UserLinkScalarWhereInput | UserLinkScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAuthorInput = {
    create?: XOR<UserCreateWithoutAuthorInput, UserUncheckedCreateWithoutAuthorInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthorInput
    connect?: UserWhereUniqueInput
  }

  export type ArticleCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ArticleCreateWithoutAuthorInput, ArticleUncheckedCreateWithoutAuthorInput> | ArticleCreateWithoutAuthorInput[] | ArticleUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutAuthorInput | ArticleCreateOrConnectWithoutAuthorInput[]
    createMany?: ArticleCreateManyAuthorInputEnvelope
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
  }

  export type ArticleUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ArticleCreateWithoutAuthorInput, ArticleUncheckedCreateWithoutAuthorInput> | ArticleCreateWithoutAuthorInput[] | ArticleUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutAuthorInput | ArticleCreateOrConnectWithoutAuthorInput[]
    createMany?: ArticleCreateManyAuthorInputEnvelope
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutAuthorNestedInput = {
    create?: XOR<UserCreateWithoutAuthorInput, UserUncheckedCreateWithoutAuthorInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthorInput
    upsert?: UserUpsertWithoutAuthorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuthorInput, UserUpdateWithoutAuthorInput>, UserUncheckedUpdateWithoutAuthorInput>
  }

  export type ArticleUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ArticleCreateWithoutAuthorInput, ArticleUncheckedCreateWithoutAuthorInput> | ArticleCreateWithoutAuthorInput[] | ArticleUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutAuthorInput | ArticleCreateOrConnectWithoutAuthorInput[]
    upsert?: ArticleUpsertWithWhereUniqueWithoutAuthorInput | ArticleUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ArticleCreateManyAuthorInputEnvelope
    set?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    disconnect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    delete?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    update?: ArticleUpdateWithWhereUniqueWithoutAuthorInput | ArticleUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ArticleUpdateManyWithWhereWithoutAuthorInput | ArticleUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ArticleScalarWhereInput | ArticleScalarWhereInput[]
  }

  export type ArticleUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ArticleCreateWithoutAuthorInput, ArticleUncheckedCreateWithoutAuthorInput> | ArticleCreateWithoutAuthorInput[] | ArticleUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ArticleCreateOrConnectWithoutAuthorInput | ArticleCreateOrConnectWithoutAuthorInput[]
    upsert?: ArticleUpsertWithWhereUniqueWithoutAuthorInput | ArticleUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ArticleCreateManyAuthorInputEnvelope
    set?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    disconnect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    delete?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    connect?: ArticleWhereUniqueInput | ArticleWhereUniqueInput[]
    update?: ArticleUpdateWithWhereUniqueWithoutAuthorInput | ArticleUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ArticleUpdateManyWithWhereWithoutAuthorInput | ArticleUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ArticleScalarWhereInput | ArticleScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutChildrenInput = {
    create?: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput
    connect?: CategoryWhereUniqueInput
  }

  export type CategoryCreateNestedManyWithoutParentInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type ArticleCategoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ArticleCategoryCreateWithoutCategoryInput, ArticleCategoryUncheckedCreateWithoutCategoryInput> | ArticleCategoryCreateWithoutCategoryInput[] | ArticleCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ArticleCategoryCreateOrConnectWithoutCategoryInput | ArticleCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: ArticleCategoryCreateManyCategoryInputEnvelope
    connect?: ArticleCategoryWhereUniqueInput | ArticleCategoryWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type ArticleCategoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ArticleCategoryCreateWithoutCategoryInput, ArticleCategoryUncheckedCreateWithoutCategoryInput> | ArticleCategoryCreateWithoutCategoryInput[] | ArticleCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ArticleCategoryCreateOrConnectWithoutCategoryInput | ArticleCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: ArticleCategoryCreateManyCategoryInputEnvelope
    connect?: ArticleCategoryWhereUniqueInput | ArticleCategoryWhereUniqueInput[]
  }

  export type CategoryUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput
    upsert?: CategoryUpsertWithoutChildrenInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutChildrenInput, CategoryUpdateWithoutChildrenInput>, CategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type CategoryUpdateManyWithoutParentNestedInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutParentInput | CategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutParentInput | CategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutParentInput | CategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type ArticleCategoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ArticleCategoryCreateWithoutCategoryInput, ArticleCategoryUncheckedCreateWithoutCategoryInput> | ArticleCategoryCreateWithoutCategoryInput[] | ArticleCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ArticleCategoryCreateOrConnectWithoutCategoryInput | ArticleCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: ArticleCategoryUpsertWithWhereUniqueWithoutCategoryInput | ArticleCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ArticleCategoryCreateManyCategoryInputEnvelope
    set?: ArticleCategoryWhereUniqueInput | ArticleCategoryWhereUniqueInput[]
    disconnect?: ArticleCategoryWhereUniqueInput | ArticleCategoryWhereUniqueInput[]
    delete?: ArticleCategoryWhereUniqueInput | ArticleCategoryWhereUniqueInput[]
    connect?: ArticleCategoryWhereUniqueInput | ArticleCategoryWhereUniqueInput[]
    update?: ArticleCategoryUpdateWithWhereUniqueWithoutCategoryInput | ArticleCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ArticleCategoryUpdateManyWithWhereWithoutCategoryInput | ArticleCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ArticleCategoryScalarWhereInput | ArticleCategoryScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutParentInput | CategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutParentInput | CategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutParentInput | CategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type ArticleCategoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ArticleCategoryCreateWithoutCategoryInput, ArticleCategoryUncheckedCreateWithoutCategoryInput> | ArticleCategoryCreateWithoutCategoryInput[] | ArticleCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ArticleCategoryCreateOrConnectWithoutCategoryInput | ArticleCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: ArticleCategoryUpsertWithWhereUniqueWithoutCategoryInput | ArticleCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ArticleCategoryCreateManyCategoryInputEnvelope
    set?: ArticleCategoryWhereUniqueInput | ArticleCategoryWhereUniqueInput[]
    disconnect?: ArticleCategoryWhereUniqueInput | ArticleCategoryWhereUniqueInput[]
    delete?: ArticleCategoryWhereUniqueInput | ArticleCategoryWhereUniqueInput[]
    connect?: ArticleCategoryWhereUniqueInput | ArticleCategoryWhereUniqueInput[]
    update?: ArticleCategoryUpdateWithWhereUniqueWithoutCategoryInput | ArticleCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ArticleCategoryUpdateManyWithWhereWithoutCategoryInput | ArticleCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ArticleCategoryScalarWhereInput | ArticleCategoryScalarWhereInput[]
  }

  export type ArticleTagCreateNestedManyWithoutTagInput = {
    create?: XOR<ArticleTagCreateWithoutTagInput, ArticleTagUncheckedCreateWithoutTagInput> | ArticleTagCreateWithoutTagInput[] | ArticleTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ArticleTagCreateOrConnectWithoutTagInput | ArticleTagCreateOrConnectWithoutTagInput[]
    createMany?: ArticleTagCreateManyTagInputEnvelope
    connect?: ArticleTagWhereUniqueInput | ArticleTagWhereUniqueInput[]
  }

  export type ArticleTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<ArticleTagCreateWithoutTagInput, ArticleTagUncheckedCreateWithoutTagInput> | ArticleTagCreateWithoutTagInput[] | ArticleTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ArticleTagCreateOrConnectWithoutTagInput | ArticleTagCreateOrConnectWithoutTagInput[]
    createMany?: ArticleTagCreateManyTagInputEnvelope
    connect?: ArticleTagWhereUniqueInput | ArticleTagWhereUniqueInput[]
  }

  export type ArticleTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<ArticleTagCreateWithoutTagInput, ArticleTagUncheckedCreateWithoutTagInput> | ArticleTagCreateWithoutTagInput[] | ArticleTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ArticleTagCreateOrConnectWithoutTagInput | ArticleTagCreateOrConnectWithoutTagInput[]
    upsert?: ArticleTagUpsertWithWhereUniqueWithoutTagInput | ArticleTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: ArticleTagCreateManyTagInputEnvelope
    set?: ArticleTagWhereUniqueInput | ArticleTagWhereUniqueInput[]
    disconnect?: ArticleTagWhereUniqueInput | ArticleTagWhereUniqueInput[]
    delete?: ArticleTagWhereUniqueInput | ArticleTagWhereUniqueInput[]
    connect?: ArticleTagWhereUniqueInput | ArticleTagWhereUniqueInput[]
    update?: ArticleTagUpdateWithWhereUniqueWithoutTagInput | ArticleTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: ArticleTagUpdateManyWithWhereWithoutTagInput | ArticleTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: ArticleTagScalarWhereInput | ArticleTagScalarWhereInput[]
  }

  export type ArticleTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<ArticleTagCreateWithoutTagInput, ArticleTagUncheckedCreateWithoutTagInput> | ArticleTagCreateWithoutTagInput[] | ArticleTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ArticleTagCreateOrConnectWithoutTagInput | ArticleTagCreateOrConnectWithoutTagInput[]
    upsert?: ArticleTagUpsertWithWhereUniqueWithoutTagInput | ArticleTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: ArticleTagCreateManyTagInputEnvelope
    set?: ArticleTagWhereUniqueInput | ArticleTagWhereUniqueInput[]
    disconnect?: ArticleTagWhereUniqueInput | ArticleTagWhereUniqueInput[]
    delete?: ArticleTagWhereUniqueInput | ArticleTagWhereUniqueInput[]
    connect?: ArticleTagWhereUniqueInput | ArticleTagWhereUniqueInput[]
    update?: ArticleTagUpdateWithWhereUniqueWithoutTagInput | ArticleTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: ArticleTagUpdateManyWithWhereWithoutTagInput | ArticleTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: ArticleTagScalarWhereInput | ArticleTagScalarWhereInput[]
  }

  export type AuthorCreateNestedOneWithoutArticlesInput = {
    create?: XOR<AuthorCreateWithoutArticlesInput, AuthorUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: AuthorCreateOrConnectWithoutArticlesInput
    connect?: AuthorWhereUniqueInput
  }

  export type ArticleCategoryCreateNestedManyWithoutArticleInput = {
    create?: XOR<ArticleCategoryCreateWithoutArticleInput, ArticleCategoryUncheckedCreateWithoutArticleInput> | ArticleCategoryCreateWithoutArticleInput[] | ArticleCategoryUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: ArticleCategoryCreateOrConnectWithoutArticleInput | ArticleCategoryCreateOrConnectWithoutArticleInput[]
    createMany?: ArticleCategoryCreateManyArticleInputEnvelope
    connect?: ArticleCategoryWhereUniqueInput | ArticleCategoryWhereUniqueInput[]
  }

  export type ArticleTagCreateNestedManyWithoutArticleInput = {
    create?: XOR<ArticleTagCreateWithoutArticleInput, ArticleTagUncheckedCreateWithoutArticleInput> | ArticleTagCreateWithoutArticleInput[] | ArticleTagUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: ArticleTagCreateOrConnectWithoutArticleInput | ArticleTagCreateOrConnectWithoutArticleInput[]
    createMany?: ArticleTagCreateManyArticleInputEnvelope
    connect?: ArticleTagWhereUniqueInput | ArticleTagWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutArticleInput = {
    create?: XOR<CommentCreateWithoutArticleInput, CommentUncheckedCreateWithoutArticleInput> | CommentCreateWithoutArticleInput[] | CommentUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutArticleInput | CommentCreateOrConnectWithoutArticleInput[]
    createMany?: CommentCreateManyArticleInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ArticleCategoryUncheckedCreateNestedManyWithoutArticleInput = {
    create?: XOR<ArticleCategoryCreateWithoutArticleInput, ArticleCategoryUncheckedCreateWithoutArticleInput> | ArticleCategoryCreateWithoutArticleInput[] | ArticleCategoryUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: ArticleCategoryCreateOrConnectWithoutArticleInput | ArticleCategoryCreateOrConnectWithoutArticleInput[]
    createMany?: ArticleCategoryCreateManyArticleInputEnvelope
    connect?: ArticleCategoryWhereUniqueInput | ArticleCategoryWhereUniqueInput[]
  }

  export type ArticleTagUncheckedCreateNestedManyWithoutArticleInput = {
    create?: XOR<ArticleTagCreateWithoutArticleInput, ArticleTagUncheckedCreateWithoutArticleInput> | ArticleTagCreateWithoutArticleInput[] | ArticleTagUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: ArticleTagCreateOrConnectWithoutArticleInput | ArticleTagCreateOrConnectWithoutArticleInput[]
    createMany?: ArticleTagCreateManyArticleInputEnvelope
    connect?: ArticleTagWhereUniqueInput | ArticleTagWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutArticleInput = {
    create?: XOR<CommentCreateWithoutArticleInput, CommentUncheckedCreateWithoutArticleInput> | CommentCreateWithoutArticleInput[] | CommentUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutArticleInput | CommentCreateOrConnectWithoutArticleInput[]
    createMany?: CommentCreateManyArticleInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type EnumArticleStatusFieldUpdateOperationsInput = {
    set?: $Enums.ArticleStatus
  }

  export type AuthorUpdateOneRequiredWithoutArticlesNestedInput = {
    create?: XOR<AuthorCreateWithoutArticlesInput, AuthorUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: AuthorCreateOrConnectWithoutArticlesInput
    upsert?: AuthorUpsertWithoutArticlesInput
    connect?: AuthorWhereUniqueInput
    update?: XOR<XOR<AuthorUpdateToOneWithWhereWithoutArticlesInput, AuthorUpdateWithoutArticlesInput>, AuthorUncheckedUpdateWithoutArticlesInput>
  }

  export type ArticleCategoryUpdateManyWithoutArticleNestedInput = {
    create?: XOR<ArticleCategoryCreateWithoutArticleInput, ArticleCategoryUncheckedCreateWithoutArticleInput> | ArticleCategoryCreateWithoutArticleInput[] | ArticleCategoryUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: ArticleCategoryCreateOrConnectWithoutArticleInput | ArticleCategoryCreateOrConnectWithoutArticleInput[]
    upsert?: ArticleCategoryUpsertWithWhereUniqueWithoutArticleInput | ArticleCategoryUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: ArticleCategoryCreateManyArticleInputEnvelope
    set?: ArticleCategoryWhereUniqueInput | ArticleCategoryWhereUniqueInput[]
    disconnect?: ArticleCategoryWhereUniqueInput | ArticleCategoryWhereUniqueInput[]
    delete?: ArticleCategoryWhereUniqueInput | ArticleCategoryWhereUniqueInput[]
    connect?: ArticleCategoryWhereUniqueInput | ArticleCategoryWhereUniqueInput[]
    update?: ArticleCategoryUpdateWithWhereUniqueWithoutArticleInput | ArticleCategoryUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: ArticleCategoryUpdateManyWithWhereWithoutArticleInput | ArticleCategoryUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: ArticleCategoryScalarWhereInput | ArticleCategoryScalarWhereInput[]
  }

  export type ArticleTagUpdateManyWithoutArticleNestedInput = {
    create?: XOR<ArticleTagCreateWithoutArticleInput, ArticleTagUncheckedCreateWithoutArticleInput> | ArticleTagCreateWithoutArticleInput[] | ArticleTagUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: ArticleTagCreateOrConnectWithoutArticleInput | ArticleTagCreateOrConnectWithoutArticleInput[]
    upsert?: ArticleTagUpsertWithWhereUniqueWithoutArticleInput | ArticleTagUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: ArticleTagCreateManyArticleInputEnvelope
    set?: ArticleTagWhereUniqueInput | ArticleTagWhereUniqueInput[]
    disconnect?: ArticleTagWhereUniqueInput | ArticleTagWhereUniqueInput[]
    delete?: ArticleTagWhereUniqueInput | ArticleTagWhereUniqueInput[]
    connect?: ArticleTagWhereUniqueInput | ArticleTagWhereUniqueInput[]
    update?: ArticleTagUpdateWithWhereUniqueWithoutArticleInput | ArticleTagUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: ArticleTagUpdateManyWithWhereWithoutArticleInput | ArticleTagUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: ArticleTagScalarWhereInput | ArticleTagScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutArticleNestedInput = {
    create?: XOR<CommentCreateWithoutArticleInput, CommentUncheckedCreateWithoutArticleInput> | CommentCreateWithoutArticleInput[] | CommentUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutArticleInput | CommentCreateOrConnectWithoutArticleInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutArticleInput | CommentUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: CommentCreateManyArticleInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutArticleInput | CommentUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutArticleInput | CommentUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ArticleCategoryUncheckedUpdateManyWithoutArticleNestedInput = {
    create?: XOR<ArticleCategoryCreateWithoutArticleInput, ArticleCategoryUncheckedCreateWithoutArticleInput> | ArticleCategoryCreateWithoutArticleInput[] | ArticleCategoryUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: ArticleCategoryCreateOrConnectWithoutArticleInput | ArticleCategoryCreateOrConnectWithoutArticleInput[]
    upsert?: ArticleCategoryUpsertWithWhereUniqueWithoutArticleInput | ArticleCategoryUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: ArticleCategoryCreateManyArticleInputEnvelope
    set?: ArticleCategoryWhereUniqueInput | ArticleCategoryWhereUniqueInput[]
    disconnect?: ArticleCategoryWhereUniqueInput | ArticleCategoryWhereUniqueInput[]
    delete?: ArticleCategoryWhereUniqueInput | ArticleCategoryWhereUniqueInput[]
    connect?: ArticleCategoryWhereUniqueInput | ArticleCategoryWhereUniqueInput[]
    update?: ArticleCategoryUpdateWithWhereUniqueWithoutArticleInput | ArticleCategoryUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: ArticleCategoryUpdateManyWithWhereWithoutArticleInput | ArticleCategoryUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: ArticleCategoryScalarWhereInput | ArticleCategoryScalarWhereInput[]
  }

  export type ArticleTagUncheckedUpdateManyWithoutArticleNestedInput = {
    create?: XOR<ArticleTagCreateWithoutArticleInput, ArticleTagUncheckedCreateWithoutArticleInput> | ArticleTagCreateWithoutArticleInput[] | ArticleTagUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: ArticleTagCreateOrConnectWithoutArticleInput | ArticleTagCreateOrConnectWithoutArticleInput[]
    upsert?: ArticleTagUpsertWithWhereUniqueWithoutArticleInput | ArticleTagUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: ArticleTagCreateManyArticleInputEnvelope
    set?: ArticleTagWhereUniqueInput | ArticleTagWhereUniqueInput[]
    disconnect?: ArticleTagWhereUniqueInput | ArticleTagWhereUniqueInput[]
    delete?: ArticleTagWhereUniqueInput | ArticleTagWhereUniqueInput[]
    connect?: ArticleTagWhereUniqueInput | ArticleTagWhereUniqueInput[]
    update?: ArticleTagUpdateWithWhereUniqueWithoutArticleInput | ArticleTagUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: ArticleTagUpdateManyWithWhereWithoutArticleInput | ArticleTagUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: ArticleTagScalarWhereInput | ArticleTagScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutArticleNestedInput = {
    create?: XOR<CommentCreateWithoutArticleInput, CommentUncheckedCreateWithoutArticleInput> | CommentCreateWithoutArticleInput[] | CommentUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutArticleInput | CommentCreateOrConnectWithoutArticleInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutArticleInput | CommentUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: CommentCreateManyArticleInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutArticleInput | CommentUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutArticleInput | CommentUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ArticleCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<ArticleCreateWithoutCategoriesInput, ArticleUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutCategoriesInput
    connect?: ArticleWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutArticlesInput = {
    create?: XOR<CategoryCreateWithoutArticlesInput, CategoryUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutArticlesInput
    connect?: CategoryWhereUniqueInput
  }

  export type ArticleUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<ArticleCreateWithoutCategoriesInput, ArticleUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutCategoriesInput
    upsert?: ArticleUpsertWithoutCategoriesInput
    connect?: ArticleWhereUniqueInput
    update?: XOR<XOR<ArticleUpdateToOneWithWhereWithoutCategoriesInput, ArticleUpdateWithoutCategoriesInput>, ArticleUncheckedUpdateWithoutCategoriesInput>
  }

  export type CategoryUpdateOneRequiredWithoutArticlesNestedInput = {
    create?: XOR<CategoryCreateWithoutArticlesInput, CategoryUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutArticlesInput
    upsert?: CategoryUpsertWithoutArticlesInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutArticlesInput, CategoryUpdateWithoutArticlesInput>, CategoryUncheckedUpdateWithoutArticlesInput>
  }

  export type ArticleCreateNestedOneWithoutTagsInput = {
    create?: XOR<ArticleCreateWithoutTagsInput, ArticleUncheckedCreateWithoutTagsInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutTagsInput
    connect?: ArticleWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutArticlesInput = {
    create?: XOR<TagCreateWithoutArticlesInput, TagUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: TagCreateOrConnectWithoutArticlesInput
    connect?: TagWhereUniqueInput
  }

  export type ArticleUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<ArticleCreateWithoutTagsInput, ArticleUncheckedCreateWithoutTagsInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutTagsInput
    upsert?: ArticleUpsertWithoutTagsInput
    connect?: ArticleWhereUniqueInput
    update?: XOR<XOR<ArticleUpdateToOneWithWhereWithoutTagsInput, ArticleUpdateWithoutTagsInput>, ArticleUncheckedUpdateWithoutTagsInput>
  }

  export type TagUpdateOneRequiredWithoutArticlesNestedInput = {
    create?: XOR<TagCreateWithoutArticlesInput, TagUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: TagCreateOrConnectWithoutArticlesInput
    upsert?: TagUpsertWithoutArticlesInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutArticlesInput, TagUpdateWithoutArticlesInput>, TagUncheckedUpdateWithoutArticlesInput>
  }

  export type CommentCreateNestedOneWithoutChildrenInput = {
    create?: XOR<CommentCreateWithoutChildrenInput, CommentUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CommentCreateOrConnectWithoutChildrenInput
    connect?: CommentWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutParentInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ArticleCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ArticleCreateWithoutCommentsInput, ArticleUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutCommentsInput
    connect?: ArticleWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type CommentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<CommentCreateWithoutChildrenInput, CommentUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CommentCreateOrConnectWithoutChildrenInput
    upsert?: CommentUpsertWithoutChildrenInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutChildrenInput, CommentUpdateWithoutChildrenInput>, CommentUncheckedUpdateWithoutChildrenInput>
  }

  export type CommentUpdateManyWithoutParentNestedInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentInput | CommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentInput | CommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentInput | CommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ArticleUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<ArticleCreateWithoutCommentsInput, ArticleUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutCommentsInput
    upsert?: ArticleUpsertWithoutCommentsInput
    connect?: ArticleWhereUniqueInput
    update?: XOR<XOR<ArticleUpdateToOneWithWhereWithoutCommentsInput, ArticleUpdateWithoutCommentsInput>, ArticleUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type CommentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentInput | CommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentInput | CommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentInput | CommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumIconStyleFilter<$PrismaModel = never> = {
    equals?: $Enums.IconStyle | EnumIconStyleFieldRefInput<$PrismaModel>
    in?: $Enums.IconStyle[] | ListEnumIconStyleFieldRefInput<$PrismaModel>
    notIn?: $Enums.IconStyle[] | ListEnumIconStyleFieldRefInput<$PrismaModel>
    not?: NestedEnumIconStyleFilter<$PrismaModel> | $Enums.IconStyle
  }

  export type NestedEnumIconColorFilter<$PrismaModel = never> = {
    equals?: $Enums.IconColor | EnumIconColorFieldRefInput<$PrismaModel>
    in?: $Enums.IconColor[] | ListEnumIconColorFieldRefInput<$PrismaModel>
    notIn?: $Enums.IconColor[] | ListEnumIconColorFieldRefInput<$PrismaModel>
    not?: NestedEnumIconColorFilter<$PrismaModel> | $Enums.IconColor
  }

  export type NestedEnumIconStyleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IconStyle | EnumIconStyleFieldRefInput<$PrismaModel>
    in?: $Enums.IconStyle[] | ListEnumIconStyleFieldRefInput<$PrismaModel>
    notIn?: $Enums.IconStyle[] | ListEnumIconStyleFieldRefInput<$PrismaModel>
    not?: NestedEnumIconStyleWithAggregatesFilter<$PrismaModel> | $Enums.IconStyle
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIconStyleFilter<$PrismaModel>
    _max?: NestedEnumIconStyleFilter<$PrismaModel>
  }

  export type NestedEnumIconColorWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IconColor | EnumIconColorFieldRefInput<$PrismaModel>
    in?: $Enums.IconColor[] | ListEnumIconColorFieldRefInput<$PrismaModel>
    notIn?: $Enums.IconColor[] | ListEnumIconColorFieldRefInput<$PrismaModel>
    not?: NestedEnumIconColorWithAggregatesFilter<$PrismaModel> | $Enums.IconColor
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIconColorFilter<$PrismaModel>
    _max?: NestedEnumIconColorFilter<$PrismaModel>
  }

  export type NestedEnumArticleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ArticleStatus | EnumArticleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ArticleStatus[] | ListEnumArticleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArticleStatus[] | ListEnumArticleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumArticleStatusFilter<$PrismaModel> | $Enums.ArticleStatus
  }

  export type NestedEnumArticleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ArticleStatus | EnumArticleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ArticleStatus[] | ListEnumArticleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArticleStatus[] | ListEnumArticleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumArticleStatusWithAggregatesFilter<$PrismaModel> | $Enums.ArticleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumArticleStatusFilter<$PrismaModel>
    _max?: NestedEnumArticleStatusFilter<$PrismaModel>
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserOGPCreateWithoutUserInput = {
    id?: string
    imgUrl?: string | null
    title?: string | null
    description?: string | null
  }

  export type UserOGPUncheckedCreateWithoutUserInput = {
    id?: string
    imgUrl?: string | null
    title?: string | null
    description?: string | null
  }

  export type UserOGPCreateOrConnectWithoutUserInput = {
    where: UserOGPWhereUniqueInput
    create: XOR<UserOGPCreateWithoutUserInput, UserOGPUncheckedCreateWithoutUserInput>
  }

  export type UserLinkCreateWithoutUserInput = {
    id?: string
    url: string
    title?: string | null
    description?: string | null
    sortOrder?: number
    isActive?: boolean
    useOriginalIcon?: boolean
    originalIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service: LinkServiceCreateNestedOneWithoutLinksInput
    icon?: ServiceIconCreateNestedOneWithoutLinksInput
  }

  export type UserLinkUncheckedCreateWithoutUserInput = {
    id?: string
    url: string
    title?: string | null
    description?: string | null
    sortOrder?: number
    isActive?: boolean
    useOriginalIcon?: boolean
    originalIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceId: string
    iconId?: string | null
  }

  export type UserLinkCreateOrConnectWithoutUserInput = {
    where: UserLinkWhereUniqueInput
    create: XOR<UserLinkCreateWithoutUserInput, UserLinkUncheckedCreateWithoutUserInput>
  }

  export type UserLinkCreateManyUserInputEnvelope = {
    data: UserLinkCreateManyUserInput | UserLinkCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserImageBannerCreateWithoutUserInput = {
    id?: string
    url?: string | null
    imgUrl: string
    alt?: string | null
    sortOrder?: number
  }

  export type UserImageBannerUncheckedCreateWithoutUserInput = {
    id?: string
    url?: string | null
    imgUrl: string
    alt?: string | null
    sortOrder?: number
  }

  export type UserImageBannerCreateOrConnectWithoutUserInput = {
    where: UserImageBannerWhereUniqueInput
    create: XOR<UserImageBannerCreateWithoutUserInput, UserImageBannerUncheckedCreateWithoutUserInput>
  }

  export type UserImageBannerCreateManyUserInputEnvelope = {
    data: UserImageBannerCreateManyUserInput | UserImageBannerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserImageCarouselCreateWithoutUserInput = {
    id?: string
    url?: string | null
    imgUrl: string
    alt?: string | null
    sortOrder?: number
  }

  export type UserImageCarouselUncheckedCreateWithoutUserInput = {
    id?: string
    url?: string | null
    imgUrl: string
    alt?: string | null
    sortOrder?: number
  }

  export type UserImageCarouselCreateOrConnectWithoutUserInput = {
    where: UserImageCarouselWhereUniqueInput
    create: XOR<UserImageCarouselCreateWithoutUserInput, UserImageCarouselUncheckedCreateWithoutUserInput>
  }

  export type UserImageCarouselCreateManyUserInputEnvelope = {
    data: UserImageCarouselCreateManyUserInput | UserImageCarouselCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserImageSidebarCreateWithoutUserInput = {
    id?: string
    url?: string | null
    imgUrl: string
    alt?: string | null
    sortOrder?: number
  }

  export type UserImageSidebarUncheckedCreateWithoutUserInput = {
    id?: string
    url?: string | null
    imgUrl: string
    alt?: string | null
    sortOrder?: number
  }

  export type UserImageSidebarCreateOrConnectWithoutUserInput = {
    where: UserImageSidebarWhereUniqueInput
    create: XOR<UserImageSidebarCreateWithoutUserInput, UserImageSidebarUncheckedCreateWithoutUserInput>
  }

  export type UserImageSidebarCreateManyUserInputEnvelope = {
    data: UserImageSidebarCreateManyUserInput | UserImageSidebarCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserCustomQuestionCreateWithoutUserInput = {
    id?: string
    question: string
    answer: string
    sortOrder?: number
  }

  export type UserCustomQuestionUncheckedCreateWithoutUserInput = {
    id?: string
    question: string
    answer: string
    sortOrder?: number
  }

  export type UserCustomQuestionCreateOrConnectWithoutUserInput = {
    where: UserCustomQuestionWhereUniqueInput
    create: XOR<UserCustomQuestionCreateWithoutUserInput, UserCustomQuestionUncheckedCreateWithoutUserInput>
  }

  export type UserCustomQuestionCreateManyUserInputEnvelope = {
    data: UserCustomQuestionCreateManyUserInput | UserCustomQuestionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserYoutubeSettingsCreateWithoutUserInput = {
    id?: string
    channelId?: string | null
    displayCount?: number
    lastFetchedAt?: Date | string | null
    pickupVideo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    videos?: UserYoutubeVideoCreateNestedManyWithoutSettingsInput
  }

  export type UserYoutubeSettingsUncheckedCreateWithoutUserInput = {
    id?: string
    channelId?: string | null
    displayCount?: number
    lastFetchedAt?: Date | string | null
    pickupVideo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    videos?: UserYoutubeVideoUncheckedCreateNestedManyWithoutSettingsInput
  }

  export type UserYoutubeSettingsCreateOrConnectWithoutUserInput = {
    where: UserYoutubeSettingsWhereUniqueInput
    create: XOR<UserYoutubeSettingsCreateWithoutUserInput, UserYoutubeSettingsUncheckedCreateWithoutUserInput>
  }

  export type UserRecommendYoutubeCreateWithoutUserInput = {
    id?: string
    url: string
    thumbnailUrl?: string | null
    title?: string | null
    description?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRecommendYoutubeUncheckedCreateWithoutUserInput = {
    id?: string
    url: string
    thumbnailUrl?: string | null
    title?: string | null
    description?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserRecommendYoutubeCreateOrConnectWithoutUserInput = {
    where: UserRecommendYoutubeWhereUniqueInput
    create: XOR<UserRecommendYoutubeCreateWithoutUserInput, UserRecommendYoutubeUncheckedCreateWithoutUserInput>
  }

  export type UserRecommendYoutubeCreateManyUserInputEnvelope = {
    data: UserRecommendYoutubeCreateManyUserInput | UserRecommendYoutubeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserPopupSettingsCreateWithoutUserInput = {
    id?: string
    bellTitle?: string | null
    bellText?: string | null
    bellImageUrl?: string | null
    bellUrl?: string | null
    bellLastUpdated?: Date | string | null
    emailTitle?: string | null
    emailText?: string | null
    popup1ImageUrl?: string | null
    popup1Url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPopupSettingsUncheckedCreateWithoutUserInput = {
    id?: string
    bellTitle?: string | null
    bellText?: string | null
    bellImageUrl?: string | null
    bellUrl?: string | null
    bellLastUpdated?: Date | string | null
    emailTitle?: string | null
    emailText?: string | null
    popup1ImageUrl?: string | null
    popup1Url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPopupSettingsCreateOrConnectWithoutUserInput = {
    where: UserPopupSettingsWhereUniqueInput
    create: XOR<UserPopupSettingsCreateWithoutUserInput, UserPopupSettingsUncheckedCreateWithoutUserInput>
  }

  export type UserDisplaySettingsCreateWithoutUserInput = {
    id?: string
    displayYoutube?: boolean
    displayDevice?: boolean
    displayFaq?: boolean
    displayPopup1?: boolean
    displayPopupBell?: boolean
    displayPopupEmail?: boolean
    displayUserList?: boolean
    displayOwnPage?: boolean
  }

  export type UserDisplaySettingsUncheckedCreateWithoutUserInput = {
    id?: string
    displayYoutube?: boolean
    displayDevice?: boolean
    displayFaq?: boolean
    displayPopup1?: boolean
    displayPopupBell?: boolean
    displayPopupEmail?: boolean
    displayUserList?: boolean
    displayOwnPage?: boolean
  }

  export type UserDisplaySettingsCreateOrConnectWithoutUserInput = {
    where: UserDisplaySettingsWhereUniqueInput
    create: XOR<UserDisplaySettingsCreateWithoutUserInput, UserDisplaySettingsUncheckedCreateWithoutUserInput>
  }

  export type NotificationSettingsCreateWithoutUserInput = {
    id?: string
    pushNotifications?: boolean
  }

  export type NotificationSettingsUncheckedCreateWithoutUserInput = {
    id?: string
    pushNotifications?: boolean
  }

  export type NotificationSettingsCreateOrConnectWithoutUserInput = {
    where: NotificationSettingsWhereUniqueInput
    create: XOR<NotificationSettingsCreateWithoutUserInput, NotificationSettingsUncheckedCreateWithoutUserInput>
  }

  export type AuthorCreateWithoutUserInput = {
    id?: string
    bio?: string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    articles?: ArticleCreateNestedManyWithoutAuthorInput
  }

  export type AuthorUncheckedCreateWithoutUserInput = {
    id?: string
    bio?: string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    articles?: ArticleUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type AuthorCreateOrConnectWithoutUserInput = {
    where: AuthorWhereUniqueInput
    create: XOR<AuthorCreateWithoutUserInput, AuthorUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateWithoutUserInput = {
    id?: string
    content: string
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: CommentCreateNestedOneWithoutChildrenInput
    children?: CommentCreateNestedManyWithoutParentInput
    article: ArticleCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutUserInput = {
    id?: string
    content: string
    parentId?: string | null
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    articleId: string
    children?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateManyUserInputEnvelope = {
    data: CommentCreateManyUserInput | CommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type UserOGPUpsertWithoutUserInput = {
    update: XOR<UserOGPUpdateWithoutUserInput, UserOGPUncheckedUpdateWithoutUserInput>
    create: XOR<UserOGPCreateWithoutUserInput, UserOGPUncheckedCreateWithoutUserInput>
    where?: UserOGPWhereInput
  }

  export type UserOGPUpdateToOneWithWhereWithoutUserInput = {
    where?: UserOGPWhereInput
    data: XOR<UserOGPUpdateWithoutUserInput, UserOGPUncheckedUpdateWithoutUserInput>
  }

  export type UserOGPUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    imgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserOGPUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    imgUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserLinkUpsertWithWhereUniqueWithoutUserInput = {
    where: UserLinkWhereUniqueInput
    update: XOR<UserLinkUpdateWithoutUserInput, UserLinkUncheckedUpdateWithoutUserInput>
    create: XOR<UserLinkCreateWithoutUserInput, UserLinkUncheckedCreateWithoutUserInput>
  }

  export type UserLinkUpdateWithWhereUniqueWithoutUserInput = {
    where: UserLinkWhereUniqueInput
    data: XOR<UserLinkUpdateWithoutUserInput, UserLinkUncheckedUpdateWithoutUserInput>
  }

  export type UserLinkUpdateManyWithWhereWithoutUserInput = {
    where: UserLinkScalarWhereInput
    data: XOR<UserLinkUpdateManyMutationInput, UserLinkUncheckedUpdateManyWithoutUserInput>
  }

  export type UserLinkScalarWhereInput = {
    AND?: UserLinkScalarWhereInput | UserLinkScalarWhereInput[]
    OR?: UserLinkScalarWhereInput[]
    NOT?: UserLinkScalarWhereInput | UserLinkScalarWhereInput[]
    id?: StringFilter<"UserLink"> | string
    url?: StringFilter<"UserLink"> | string
    title?: StringNullableFilter<"UserLink"> | string | null
    description?: StringNullableFilter<"UserLink"> | string | null
    sortOrder?: IntFilter<"UserLink"> | number
    isActive?: BoolFilter<"UserLink"> | boolean
    useOriginalIcon?: BoolFilter<"UserLink"> | boolean
    originalIconUrl?: StringNullableFilter<"UserLink"> | string | null
    createdAt?: DateTimeFilter<"UserLink"> | Date | string
    updatedAt?: DateTimeFilter<"UserLink"> | Date | string
    userId?: StringFilter<"UserLink"> | string
    serviceId?: StringFilter<"UserLink"> | string
    iconId?: StringNullableFilter<"UserLink"> | string | null
  }

  export type UserImageBannerUpsertWithWhereUniqueWithoutUserInput = {
    where: UserImageBannerWhereUniqueInput
    update: XOR<UserImageBannerUpdateWithoutUserInput, UserImageBannerUncheckedUpdateWithoutUserInput>
    create: XOR<UserImageBannerCreateWithoutUserInput, UserImageBannerUncheckedCreateWithoutUserInput>
  }

  export type UserImageBannerUpdateWithWhereUniqueWithoutUserInput = {
    where: UserImageBannerWhereUniqueInput
    data: XOR<UserImageBannerUpdateWithoutUserInput, UserImageBannerUncheckedUpdateWithoutUserInput>
  }

  export type UserImageBannerUpdateManyWithWhereWithoutUserInput = {
    where: UserImageBannerScalarWhereInput
    data: XOR<UserImageBannerUpdateManyMutationInput, UserImageBannerUncheckedUpdateManyWithoutUserInput>
  }

  export type UserImageBannerScalarWhereInput = {
    AND?: UserImageBannerScalarWhereInput | UserImageBannerScalarWhereInput[]
    OR?: UserImageBannerScalarWhereInput[]
    NOT?: UserImageBannerScalarWhereInput | UserImageBannerScalarWhereInput[]
    id?: StringFilter<"UserImageBanner"> | string
    url?: StringNullableFilter<"UserImageBanner"> | string | null
    imgUrl?: StringFilter<"UserImageBanner"> | string
    alt?: StringNullableFilter<"UserImageBanner"> | string | null
    sortOrder?: IntFilter<"UserImageBanner"> | number
    userId?: StringFilter<"UserImageBanner"> | string
  }

  export type UserImageCarouselUpsertWithWhereUniqueWithoutUserInput = {
    where: UserImageCarouselWhereUniqueInput
    update: XOR<UserImageCarouselUpdateWithoutUserInput, UserImageCarouselUncheckedUpdateWithoutUserInput>
    create: XOR<UserImageCarouselCreateWithoutUserInput, UserImageCarouselUncheckedCreateWithoutUserInput>
  }

  export type UserImageCarouselUpdateWithWhereUniqueWithoutUserInput = {
    where: UserImageCarouselWhereUniqueInput
    data: XOR<UserImageCarouselUpdateWithoutUserInput, UserImageCarouselUncheckedUpdateWithoutUserInput>
  }

  export type UserImageCarouselUpdateManyWithWhereWithoutUserInput = {
    where: UserImageCarouselScalarWhereInput
    data: XOR<UserImageCarouselUpdateManyMutationInput, UserImageCarouselUncheckedUpdateManyWithoutUserInput>
  }

  export type UserImageCarouselScalarWhereInput = {
    AND?: UserImageCarouselScalarWhereInput | UserImageCarouselScalarWhereInput[]
    OR?: UserImageCarouselScalarWhereInput[]
    NOT?: UserImageCarouselScalarWhereInput | UserImageCarouselScalarWhereInput[]
    id?: StringFilter<"UserImageCarousel"> | string
    url?: StringNullableFilter<"UserImageCarousel"> | string | null
    imgUrl?: StringFilter<"UserImageCarousel"> | string
    alt?: StringNullableFilter<"UserImageCarousel"> | string | null
    sortOrder?: IntFilter<"UserImageCarousel"> | number
    userId?: StringFilter<"UserImageCarousel"> | string
  }

  export type UserImageSidebarUpsertWithWhereUniqueWithoutUserInput = {
    where: UserImageSidebarWhereUniqueInput
    update: XOR<UserImageSidebarUpdateWithoutUserInput, UserImageSidebarUncheckedUpdateWithoutUserInput>
    create: XOR<UserImageSidebarCreateWithoutUserInput, UserImageSidebarUncheckedCreateWithoutUserInput>
  }

  export type UserImageSidebarUpdateWithWhereUniqueWithoutUserInput = {
    where: UserImageSidebarWhereUniqueInput
    data: XOR<UserImageSidebarUpdateWithoutUserInput, UserImageSidebarUncheckedUpdateWithoutUserInput>
  }

  export type UserImageSidebarUpdateManyWithWhereWithoutUserInput = {
    where: UserImageSidebarScalarWhereInput
    data: XOR<UserImageSidebarUpdateManyMutationInput, UserImageSidebarUncheckedUpdateManyWithoutUserInput>
  }

  export type UserImageSidebarScalarWhereInput = {
    AND?: UserImageSidebarScalarWhereInput | UserImageSidebarScalarWhereInput[]
    OR?: UserImageSidebarScalarWhereInput[]
    NOT?: UserImageSidebarScalarWhereInput | UserImageSidebarScalarWhereInput[]
    id?: StringFilter<"UserImageSidebar"> | string
    url?: StringNullableFilter<"UserImageSidebar"> | string | null
    imgUrl?: StringFilter<"UserImageSidebar"> | string
    alt?: StringNullableFilter<"UserImageSidebar"> | string | null
    sortOrder?: IntFilter<"UserImageSidebar"> | number
    userId?: StringFilter<"UserImageSidebar"> | string
  }

  export type UserCustomQuestionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserCustomQuestionWhereUniqueInput
    update: XOR<UserCustomQuestionUpdateWithoutUserInput, UserCustomQuestionUncheckedUpdateWithoutUserInput>
    create: XOR<UserCustomQuestionCreateWithoutUserInput, UserCustomQuestionUncheckedCreateWithoutUserInput>
  }

  export type UserCustomQuestionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserCustomQuestionWhereUniqueInput
    data: XOR<UserCustomQuestionUpdateWithoutUserInput, UserCustomQuestionUncheckedUpdateWithoutUserInput>
  }

  export type UserCustomQuestionUpdateManyWithWhereWithoutUserInput = {
    where: UserCustomQuestionScalarWhereInput
    data: XOR<UserCustomQuestionUpdateManyMutationInput, UserCustomQuestionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserCustomQuestionScalarWhereInput = {
    AND?: UserCustomQuestionScalarWhereInput | UserCustomQuestionScalarWhereInput[]
    OR?: UserCustomQuestionScalarWhereInput[]
    NOT?: UserCustomQuestionScalarWhereInput | UserCustomQuestionScalarWhereInput[]
    id?: StringFilter<"UserCustomQuestion"> | string
    question?: StringFilter<"UserCustomQuestion"> | string
    answer?: StringFilter<"UserCustomQuestion"> | string
    sortOrder?: IntFilter<"UserCustomQuestion"> | number
    userId?: StringFilter<"UserCustomQuestion"> | string
  }

  export type UserYoutubeSettingsUpsertWithoutUserInput = {
    update: XOR<UserYoutubeSettingsUpdateWithoutUserInput, UserYoutubeSettingsUncheckedUpdateWithoutUserInput>
    create: XOR<UserYoutubeSettingsCreateWithoutUserInput, UserYoutubeSettingsUncheckedCreateWithoutUserInput>
    where?: UserYoutubeSettingsWhereInput
  }

  export type UserYoutubeSettingsUpdateToOneWithWhereWithoutUserInput = {
    where?: UserYoutubeSettingsWhereInput
    data: XOR<UserYoutubeSettingsUpdateWithoutUserInput, UserYoutubeSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserYoutubeSettingsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    displayCount?: IntFieldUpdateOperationsInput | number
    lastFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupVideo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videos?: UserYoutubeVideoUpdateManyWithoutSettingsNestedInput
  }

  export type UserYoutubeSettingsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    displayCount?: IntFieldUpdateOperationsInput | number
    lastFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupVideo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    videos?: UserYoutubeVideoUncheckedUpdateManyWithoutSettingsNestedInput
  }

  export type UserRecommendYoutubeUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRecommendYoutubeWhereUniqueInput
    update: XOR<UserRecommendYoutubeUpdateWithoutUserInput, UserRecommendYoutubeUncheckedUpdateWithoutUserInput>
    create: XOR<UserRecommendYoutubeCreateWithoutUserInput, UserRecommendYoutubeUncheckedCreateWithoutUserInput>
  }

  export type UserRecommendYoutubeUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRecommendYoutubeWhereUniqueInput
    data: XOR<UserRecommendYoutubeUpdateWithoutUserInput, UserRecommendYoutubeUncheckedUpdateWithoutUserInput>
  }

  export type UserRecommendYoutubeUpdateManyWithWhereWithoutUserInput = {
    where: UserRecommendYoutubeScalarWhereInput
    data: XOR<UserRecommendYoutubeUpdateManyMutationInput, UserRecommendYoutubeUncheckedUpdateManyWithoutUserInput>
  }

  export type UserRecommendYoutubeScalarWhereInput = {
    AND?: UserRecommendYoutubeScalarWhereInput | UserRecommendYoutubeScalarWhereInput[]
    OR?: UserRecommendYoutubeScalarWhereInput[]
    NOT?: UserRecommendYoutubeScalarWhereInput | UserRecommendYoutubeScalarWhereInput[]
    id?: StringFilter<"UserRecommendYoutube"> | string
    url?: StringFilter<"UserRecommendYoutube"> | string
    thumbnailUrl?: StringNullableFilter<"UserRecommendYoutube"> | string | null
    title?: StringNullableFilter<"UserRecommendYoutube"> | string | null
    description?: StringNullableFilter<"UserRecommendYoutube"> | string | null
    sortOrder?: IntFilter<"UserRecommendYoutube"> | number
    createdAt?: DateTimeFilter<"UserRecommendYoutube"> | Date | string
    updatedAt?: DateTimeFilter<"UserRecommendYoutube"> | Date | string
    userId?: StringFilter<"UserRecommendYoutube"> | string
  }

  export type UserPopupSettingsUpsertWithoutUserInput = {
    update: XOR<UserPopupSettingsUpdateWithoutUserInput, UserPopupSettingsUncheckedUpdateWithoutUserInput>
    create: XOR<UserPopupSettingsCreateWithoutUserInput, UserPopupSettingsUncheckedCreateWithoutUserInput>
    where?: UserPopupSettingsWhereInput
  }

  export type UserPopupSettingsUpdateToOneWithWhereWithoutUserInput = {
    where?: UserPopupSettingsWhereInput
    data: XOR<UserPopupSettingsUpdateWithoutUserInput, UserPopupSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserPopupSettingsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bellTitle?: NullableStringFieldUpdateOperationsInput | string | null
    bellText?: NullableStringFieldUpdateOperationsInput | string | null
    bellImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bellUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bellLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailTitle?: NullableStringFieldUpdateOperationsInput | string | null
    emailText?: NullableStringFieldUpdateOperationsInput | string | null
    popup1ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    popup1Url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPopupSettingsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bellTitle?: NullableStringFieldUpdateOperationsInput | string | null
    bellText?: NullableStringFieldUpdateOperationsInput | string | null
    bellImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bellUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bellLastUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailTitle?: NullableStringFieldUpdateOperationsInput | string | null
    emailText?: NullableStringFieldUpdateOperationsInput | string | null
    popup1ImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    popup1Url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDisplaySettingsUpsertWithoutUserInput = {
    update: XOR<UserDisplaySettingsUpdateWithoutUserInput, UserDisplaySettingsUncheckedUpdateWithoutUserInput>
    create: XOR<UserDisplaySettingsCreateWithoutUserInput, UserDisplaySettingsUncheckedCreateWithoutUserInput>
    where?: UserDisplaySettingsWhereInput
  }

  export type UserDisplaySettingsUpdateToOneWithWhereWithoutUserInput = {
    where?: UserDisplaySettingsWhereInput
    data: XOR<UserDisplaySettingsUpdateWithoutUserInput, UserDisplaySettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserDisplaySettingsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayYoutube?: BoolFieldUpdateOperationsInput | boolean
    displayDevice?: BoolFieldUpdateOperationsInput | boolean
    displayFaq?: BoolFieldUpdateOperationsInput | boolean
    displayPopup1?: BoolFieldUpdateOperationsInput | boolean
    displayPopupBell?: BoolFieldUpdateOperationsInput | boolean
    displayPopupEmail?: BoolFieldUpdateOperationsInput | boolean
    displayUserList?: BoolFieldUpdateOperationsInput | boolean
    displayOwnPage?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserDisplaySettingsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayYoutube?: BoolFieldUpdateOperationsInput | boolean
    displayDevice?: BoolFieldUpdateOperationsInput | boolean
    displayFaq?: BoolFieldUpdateOperationsInput | boolean
    displayPopup1?: BoolFieldUpdateOperationsInput | boolean
    displayPopupBell?: BoolFieldUpdateOperationsInput | boolean
    displayPopupEmail?: BoolFieldUpdateOperationsInput | boolean
    displayUserList?: BoolFieldUpdateOperationsInput | boolean
    displayOwnPage?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationSettingsUpsertWithoutUserInput = {
    update: XOR<NotificationSettingsUpdateWithoutUserInput, NotificationSettingsUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationSettingsCreateWithoutUserInput, NotificationSettingsUncheckedCreateWithoutUserInput>
    where?: NotificationSettingsWhereInput
  }

  export type NotificationSettingsUpdateToOneWithWhereWithoutUserInput = {
    where?: NotificationSettingsWhereInput
    data: XOR<NotificationSettingsUpdateWithoutUserInput, NotificationSettingsUncheckedUpdateWithoutUserInput>
  }

  export type NotificationSettingsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationSettingsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    pushNotifications?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AuthorUpsertWithoutUserInput = {
    update: XOR<AuthorUpdateWithoutUserInput, AuthorUncheckedUpdateWithoutUserInput>
    create: XOR<AuthorCreateWithoutUserInput, AuthorUncheckedCreateWithoutUserInput>
    where?: AuthorWhereInput
  }

  export type AuthorUpdateToOneWithWhereWithoutUserInput = {
    where?: AuthorWhereInput
    data: XOR<AuthorUpdateWithoutUserInput, AuthorUncheckedUpdateWithoutUserInput>
  }

  export type AuthorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: ArticleUpdateManyWithoutAuthorNestedInput
  }

  export type AuthorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: ArticleUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    isApproved?: BoolFilter<"Comment"> | boolean
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    articleId?: StringFilter<"Comment"> | string
    userId?: StringNullableFilter<"Comment"> | string | null
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    email: string
    name?: string | null
    characterName?: string | null
    subname?: string | null
    bio?: string | null
    birthday?: Date | string | null
    gender?: string | null
    iconUrl?: string | null
    bannerUrl?: string | null
    handle?: string | null
    handleChangeCount?: number
    handleChangeTokens?: number
    isPremiumUser?: boolean
    role?: string
    subscriptionStatus?: string | null
    emailVerified?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    ogp?: UserOGPCreateNestedOneWithoutUserInput
    links?: UserLinkCreateNestedManyWithoutUserInput
    imageBanners?: UserImageBannerCreateNestedManyWithoutUserInput
    imageCarousels?: UserImageCarouselCreateNestedManyWithoutUserInput
    imageSidebars?: UserImageSidebarCreateNestedManyWithoutUserInput
    customQuestions?: UserCustomQuestionCreateNestedManyWithoutUserInput
    youtubeSettings?: UserYoutubeSettingsCreateNestedOneWithoutUserInput
    recommendYoutubes?: UserRecommendYoutubeCreateNestedManyWithoutUserInput
    popupSettings?: UserPopupSettingsCreateNestedOneWithoutUserInput
    displaySettings?: UserDisplaySettingsCreateNestedOneWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    author?: AuthorCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    email: string
    name?: string | null
    characterName?: string | null
    subname?: string | null
    bio?: string | null
    birthday?: Date | string | null
    gender?: string | null
    iconUrl?: string | null
    bannerUrl?: string | null
    handle?: string | null
    handleChangeCount?: number
    handleChangeTokens?: number
    isPremiumUser?: boolean
    role?: string
    subscriptionStatus?: string | null
    emailVerified?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    ogp?: UserOGPUncheckedCreateNestedOneWithoutUserInput
    links?: UserLinkUncheckedCreateNestedManyWithoutUserInput
    imageBanners?: UserImageBannerUncheckedCreateNestedManyWithoutUserInput
    imageCarousels?: UserImageCarouselUncheckedCreateNestedManyWithoutUserInput
    imageSidebars?: UserImageSidebarUncheckedCreateNestedManyWithoutUserInput
    customQuestions?: UserCustomQuestionUncheckedCreateNestedManyWithoutUserInput
    youtubeSettings?: UserYoutubeSettingsUncheckedCreateNestedOneWithoutUserInput
    recommendYoutubes?: UserRecommendYoutubeUncheckedCreateNestedManyWithoutUserInput
    popupSettings?: UserPopupSettingsUncheckedCreateNestedOneWithoutUserInput
    displaySettings?: UserDisplaySettingsUncheckedCreateNestedOneWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    author?: AuthorUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    characterName?: NullableStringFieldUpdateOperationsInput | string | null
    subname?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    handleChangeCount?: IntFieldUpdateOperationsInput | number
    handleChangeTokens?: IntFieldUpdateOperationsInput | number
    isPremiumUser?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    ogp?: UserOGPUpdateOneWithoutUserNestedInput
    links?: UserLinkUpdateManyWithoutUserNestedInput
    imageBanners?: UserImageBannerUpdateManyWithoutUserNestedInput
    imageCarousels?: UserImageCarouselUpdateManyWithoutUserNestedInput
    imageSidebars?: UserImageSidebarUpdateManyWithoutUserNestedInput
    customQuestions?: UserCustomQuestionUpdateManyWithoutUserNestedInput
    youtubeSettings?: UserYoutubeSettingsUpdateOneWithoutUserNestedInput
    recommendYoutubes?: UserRecommendYoutubeUpdateManyWithoutUserNestedInput
    popupSettings?: UserPopupSettingsUpdateOneWithoutUserNestedInput
    displaySettings?: UserDisplaySettingsUpdateOneWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    author?: AuthorUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    characterName?: NullableStringFieldUpdateOperationsInput | string | null
    subname?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    handleChangeCount?: IntFieldUpdateOperationsInput | number
    handleChangeTokens?: IntFieldUpdateOperationsInput | number
    isPremiumUser?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    ogp?: UserOGPUncheckedUpdateOneWithoutUserNestedInput
    links?: UserLinkUncheckedUpdateManyWithoutUserNestedInput
    imageBanners?: UserImageBannerUncheckedUpdateManyWithoutUserNestedInput
    imageCarousels?: UserImageCarouselUncheckedUpdateManyWithoutUserNestedInput
    imageSidebars?: UserImageSidebarUncheckedUpdateManyWithoutUserNestedInput
    customQuestions?: UserCustomQuestionUncheckedUpdateManyWithoutUserNestedInput
    youtubeSettings?: UserYoutubeSettingsUncheckedUpdateOneWithoutUserNestedInput
    recommendYoutubes?: UserRecommendYoutubeUncheckedUpdateManyWithoutUserNestedInput
    popupSettings?: UserPopupSettingsUncheckedUpdateOneWithoutUserNestedInput
    displaySettings?: UserDisplaySettingsUncheckedUpdateOneWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    author?: AuthorUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    name?: string | null
    characterName?: string | null
    subname?: string | null
    bio?: string | null
    birthday?: Date | string | null
    gender?: string | null
    iconUrl?: string | null
    bannerUrl?: string | null
    handle?: string | null
    handleChangeCount?: number
    handleChangeTokens?: number
    isPremiumUser?: boolean
    role?: string
    subscriptionStatus?: string | null
    emailVerified?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    ogp?: UserOGPCreateNestedOneWithoutUserInput
    links?: UserLinkCreateNestedManyWithoutUserInput
    imageBanners?: UserImageBannerCreateNestedManyWithoutUserInput
    imageCarousels?: UserImageCarouselCreateNestedManyWithoutUserInput
    imageSidebars?: UserImageSidebarCreateNestedManyWithoutUserInput
    customQuestions?: UserCustomQuestionCreateNestedManyWithoutUserInput
    youtubeSettings?: UserYoutubeSettingsCreateNestedOneWithoutUserInput
    recommendYoutubes?: UserRecommendYoutubeCreateNestedManyWithoutUserInput
    popupSettings?: UserPopupSettingsCreateNestedOneWithoutUserInput
    displaySettings?: UserDisplaySettingsCreateNestedOneWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    author?: AuthorCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    name?: string | null
    characterName?: string | null
    subname?: string | null
    bio?: string | null
    birthday?: Date | string | null
    gender?: string | null
    iconUrl?: string | null
    bannerUrl?: string | null
    handle?: string | null
    handleChangeCount?: number
    handleChangeTokens?: number
    isPremiumUser?: boolean
    role?: string
    subscriptionStatus?: string | null
    emailVerified?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    ogp?: UserOGPUncheckedCreateNestedOneWithoutUserInput
    links?: UserLinkUncheckedCreateNestedManyWithoutUserInput
    imageBanners?: UserImageBannerUncheckedCreateNestedManyWithoutUserInput
    imageCarousels?: UserImageCarouselUncheckedCreateNestedManyWithoutUserInput
    imageSidebars?: UserImageSidebarUncheckedCreateNestedManyWithoutUserInput
    customQuestions?: UserCustomQuestionUncheckedCreateNestedManyWithoutUserInput
    youtubeSettings?: UserYoutubeSettingsUncheckedCreateNestedOneWithoutUserInput
    recommendYoutubes?: UserRecommendYoutubeUncheckedCreateNestedManyWithoutUserInput
    popupSettings?: UserPopupSettingsUncheckedCreateNestedOneWithoutUserInput
    displaySettings?: UserDisplaySettingsUncheckedCreateNestedOneWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    author?: AuthorUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    characterName?: NullableStringFieldUpdateOperationsInput | string | null
    subname?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    handleChangeCount?: IntFieldUpdateOperationsInput | number
    handleChangeTokens?: IntFieldUpdateOperationsInput | number
    isPremiumUser?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    ogp?: UserOGPUpdateOneWithoutUserNestedInput
    links?: UserLinkUpdateManyWithoutUserNestedInput
    imageBanners?: UserImageBannerUpdateManyWithoutUserNestedInput
    imageCarousels?: UserImageCarouselUpdateManyWithoutUserNestedInput
    imageSidebars?: UserImageSidebarUpdateManyWithoutUserNestedInput
    customQuestions?: UserCustomQuestionUpdateManyWithoutUserNestedInput
    youtubeSettings?: UserYoutubeSettingsUpdateOneWithoutUserNestedInput
    recommendYoutubes?: UserRecommendYoutubeUpdateManyWithoutUserNestedInput
    popupSettings?: UserPopupSettingsUpdateOneWithoutUserNestedInput
    displaySettings?: UserDisplaySettingsUpdateOneWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    author?: AuthorUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    characterName?: NullableStringFieldUpdateOperationsInput | string | null
    subname?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    handleChangeCount?: IntFieldUpdateOperationsInput | number
    handleChangeTokens?: IntFieldUpdateOperationsInput | number
    isPremiumUser?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    ogp?: UserOGPUncheckedUpdateOneWithoutUserNestedInput
    links?: UserLinkUncheckedUpdateManyWithoutUserNestedInput
    imageBanners?: UserImageBannerUncheckedUpdateManyWithoutUserNestedInput
    imageCarousels?: UserImageCarouselUncheckedUpdateManyWithoutUserNestedInput
    imageSidebars?: UserImageSidebarUncheckedUpdateManyWithoutUserNestedInput
    customQuestions?: UserCustomQuestionUncheckedUpdateManyWithoutUserNestedInput
    youtubeSettings?: UserYoutubeSettingsUncheckedUpdateOneWithoutUserNestedInput
    recommendYoutubes?: UserRecommendYoutubeUncheckedUpdateManyWithoutUserNestedInput
    popupSettings?: UserPopupSettingsUncheckedUpdateOneWithoutUserNestedInput
    displaySettings?: UserDisplaySettingsUncheckedUpdateOneWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    author?: AuthorUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationSettingsInput = {
    id?: string
    email: string
    name?: string | null
    characterName?: string | null
    subname?: string | null
    bio?: string | null
    birthday?: Date | string | null
    gender?: string | null
    iconUrl?: string | null
    bannerUrl?: string | null
    handle?: string | null
    handleChangeCount?: number
    handleChangeTokens?: number
    isPremiumUser?: boolean
    role?: string
    subscriptionStatus?: string | null
    emailVerified?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    ogp?: UserOGPCreateNestedOneWithoutUserInput
    links?: UserLinkCreateNestedManyWithoutUserInput
    imageBanners?: UserImageBannerCreateNestedManyWithoutUserInput
    imageCarousels?: UserImageCarouselCreateNestedManyWithoutUserInput
    imageSidebars?: UserImageSidebarCreateNestedManyWithoutUserInput
    customQuestions?: UserCustomQuestionCreateNestedManyWithoutUserInput
    youtubeSettings?: UserYoutubeSettingsCreateNestedOneWithoutUserInput
    recommendYoutubes?: UserRecommendYoutubeCreateNestedManyWithoutUserInput
    popupSettings?: UserPopupSettingsCreateNestedOneWithoutUserInput
    displaySettings?: UserDisplaySettingsCreateNestedOneWithoutUserInput
    author?: AuthorCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationSettingsInput = {
    id?: string
    email: string
    name?: string | null
    characterName?: string | null
    subname?: string | null
    bio?: string | null
    birthday?: Date | string | null
    gender?: string | null
    iconUrl?: string | null
    bannerUrl?: string | null
    handle?: string | null
    handleChangeCount?: number
    handleChangeTokens?: number
    isPremiumUser?: boolean
    role?: string
    subscriptionStatus?: string | null
    emailVerified?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    ogp?: UserOGPUncheckedCreateNestedOneWithoutUserInput
    links?: UserLinkUncheckedCreateNestedManyWithoutUserInput
    imageBanners?: UserImageBannerUncheckedCreateNestedManyWithoutUserInput
    imageCarousels?: UserImageCarouselUncheckedCreateNestedManyWithoutUserInput
    imageSidebars?: UserImageSidebarUncheckedCreateNestedManyWithoutUserInput
    customQuestions?: UserCustomQuestionUncheckedCreateNestedManyWithoutUserInput
    youtubeSettings?: UserYoutubeSettingsUncheckedCreateNestedOneWithoutUserInput
    recommendYoutubes?: UserRecommendYoutubeUncheckedCreateNestedManyWithoutUserInput
    popupSettings?: UserPopupSettingsUncheckedCreateNestedOneWithoutUserInput
    displaySettings?: UserDisplaySettingsUncheckedCreateNestedOneWithoutUserInput
    author?: AuthorUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationSettingsInput, UserUncheckedCreateWithoutNotificationSettingsInput>
  }

  export type UserUpsertWithoutNotificationSettingsInput = {
    update: XOR<UserUpdateWithoutNotificationSettingsInput, UserUncheckedUpdateWithoutNotificationSettingsInput>
    create: XOR<UserCreateWithoutNotificationSettingsInput, UserUncheckedCreateWithoutNotificationSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationSettingsInput, UserUncheckedUpdateWithoutNotificationSettingsInput>
  }

  export type UserUpdateWithoutNotificationSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    characterName?: NullableStringFieldUpdateOperationsInput | string | null
    subname?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    handleChangeCount?: IntFieldUpdateOperationsInput | number
    handleChangeTokens?: IntFieldUpdateOperationsInput | number
    isPremiumUser?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    ogp?: UserOGPUpdateOneWithoutUserNestedInput
    links?: UserLinkUpdateManyWithoutUserNestedInput
    imageBanners?: UserImageBannerUpdateManyWithoutUserNestedInput
    imageCarousels?: UserImageCarouselUpdateManyWithoutUserNestedInput
    imageSidebars?: UserImageSidebarUpdateManyWithoutUserNestedInput
    customQuestions?: UserCustomQuestionUpdateManyWithoutUserNestedInput
    youtubeSettings?: UserYoutubeSettingsUpdateOneWithoutUserNestedInput
    recommendYoutubes?: UserRecommendYoutubeUpdateManyWithoutUserNestedInput
    popupSettings?: UserPopupSettingsUpdateOneWithoutUserNestedInput
    displaySettings?: UserDisplaySettingsUpdateOneWithoutUserNestedInput
    author?: AuthorUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    characterName?: NullableStringFieldUpdateOperationsInput | string | null
    subname?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    handleChangeCount?: IntFieldUpdateOperationsInput | number
    handleChangeTokens?: IntFieldUpdateOperationsInput | number
    isPremiumUser?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    ogp?: UserOGPUncheckedUpdateOneWithoutUserNestedInput
    links?: UserLinkUncheckedUpdateManyWithoutUserNestedInput
    imageBanners?: UserImageBannerUncheckedUpdateManyWithoutUserNestedInput
    imageCarousels?: UserImageCarouselUncheckedUpdateManyWithoutUserNestedInput
    imageSidebars?: UserImageSidebarUncheckedUpdateManyWithoutUserNestedInput
    customQuestions?: UserCustomQuestionUncheckedUpdateManyWithoutUserNestedInput
    youtubeSettings?: UserYoutubeSettingsUncheckedUpdateOneWithoutUserNestedInput
    recommendYoutubes?: UserRecommendYoutubeUncheckedUpdateManyWithoutUserNestedInput
    popupSettings?: UserPopupSettingsUncheckedUpdateOneWithoutUserNestedInput
    displaySettings?: UserDisplaySettingsUncheckedUpdateOneWithoutUserNestedInput
    author?: AuthorUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutLinksInput = {
    id?: string
    email: string
    name?: string | null
    characterName?: string | null
    subname?: string | null
    bio?: string | null
    birthday?: Date | string | null
    gender?: string | null
    iconUrl?: string | null
    bannerUrl?: string | null
    handle?: string | null
    handleChangeCount?: number
    handleChangeTokens?: number
    isPremiumUser?: boolean
    role?: string
    subscriptionStatus?: string | null
    emailVerified?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    ogp?: UserOGPCreateNestedOneWithoutUserInput
    imageBanners?: UserImageBannerCreateNestedManyWithoutUserInput
    imageCarousels?: UserImageCarouselCreateNestedManyWithoutUserInput
    imageSidebars?: UserImageSidebarCreateNestedManyWithoutUserInput
    customQuestions?: UserCustomQuestionCreateNestedManyWithoutUserInput
    youtubeSettings?: UserYoutubeSettingsCreateNestedOneWithoutUserInput
    recommendYoutubes?: UserRecommendYoutubeCreateNestedManyWithoutUserInput
    popupSettings?: UserPopupSettingsCreateNestedOneWithoutUserInput
    displaySettings?: UserDisplaySettingsCreateNestedOneWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    author?: AuthorCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLinksInput = {
    id?: string
    email: string
    name?: string | null
    characterName?: string | null
    subname?: string | null
    bio?: string | null
    birthday?: Date | string | null
    gender?: string | null
    iconUrl?: string | null
    bannerUrl?: string | null
    handle?: string | null
    handleChangeCount?: number
    handleChangeTokens?: number
    isPremiumUser?: boolean
    role?: string
    subscriptionStatus?: string | null
    emailVerified?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    ogp?: UserOGPUncheckedCreateNestedOneWithoutUserInput
    imageBanners?: UserImageBannerUncheckedCreateNestedManyWithoutUserInput
    imageCarousels?: UserImageCarouselUncheckedCreateNestedManyWithoutUserInput
    imageSidebars?: UserImageSidebarUncheckedCreateNestedManyWithoutUserInput
    customQuestions?: UserCustomQuestionUncheckedCreateNestedManyWithoutUserInput
    youtubeSettings?: UserYoutubeSettingsUncheckedCreateNestedOneWithoutUserInput
    recommendYoutubes?: UserRecommendYoutubeUncheckedCreateNestedManyWithoutUserInput
    popupSettings?: UserPopupSettingsUncheckedCreateNestedOneWithoutUserInput
    displaySettings?: UserDisplaySettingsUncheckedCreateNestedOneWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    author?: AuthorUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLinksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLinksInput, UserUncheckedCreateWithoutLinksInput>
  }

  export type LinkServiceCreateWithoutLinksInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    baseUrl?: string | null
    allowOriginalIcon?: boolean
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    icons?: ServiceIconCreateNestedManyWithoutServiceInput
  }

  export type LinkServiceUncheckedCreateWithoutLinksInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    baseUrl?: string | null
    allowOriginalIcon?: boolean
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    icons?: ServiceIconUncheckedCreateNestedManyWithoutServiceInput
  }

  export type LinkServiceCreateOrConnectWithoutLinksInput = {
    where: LinkServiceWhereUniqueInput
    create: XOR<LinkServiceCreateWithoutLinksInput, LinkServiceUncheckedCreateWithoutLinksInput>
  }

  export type ServiceIconCreateWithoutLinksInput = {
    id?: string
    name: string
    fileName: string
    filePath: string
    style: $Enums.IconStyle
    colorScheme: $Enums.IconColor
    description?: string | null
    isActive?: boolean
    sortOrder?: number
    uploadedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service: LinkServiceCreateNestedOneWithoutIconsInput
  }

  export type ServiceIconUncheckedCreateWithoutLinksInput = {
    id?: string
    name: string
    fileName: string
    filePath: string
    style: $Enums.IconStyle
    colorScheme: $Enums.IconColor
    description?: string | null
    isActive?: boolean
    sortOrder?: number
    uploadedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceId: string
  }

  export type ServiceIconCreateOrConnectWithoutLinksInput = {
    where: ServiceIconWhereUniqueInput
    create: XOR<ServiceIconCreateWithoutLinksInput, ServiceIconUncheckedCreateWithoutLinksInput>
  }

  export type UserUpsertWithoutLinksInput = {
    update: XOR<UserUpdateWithoutLinksInput, UserUncheckedUpdateWithoutLinksInput>
    create: XOR<UserCreateWithoutLinksInput, UserUncheckedCreateWithoutLinksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLinksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLinksInput, UserUncheckedUpdateWithoutLinksInput>
  }

  export type UserUpdateWithoutLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    characterName?: NullableStringFieldUpdateOperationsInput | string | null
    subname?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    handleChangeCount?: IntFieldUpdateOperationsInput | number
    handleChangeTokens?: IntFieldUpdateOperationsInput | number
    isPremiumUser?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    ogp?: UserOGPUpdateOneWithoutUserNestedInput
    imageBanners?: UserImageBannerUpdateManyWithoutUserNestedInput
    imageCarousels?: UserImageCarouselUpdateManyWithoutUserNestedInput
    imageSidebars?: UserImageSidebarUpdateManyWithoutUserNestedInput
    customQuestions?: UserCustomQuestionUpdateManyWithoutUserNestedInput
    youtubeSettings?: UserYoutubeSettingsUpdateOneWithoutUserNestedInput
    recommendYoutubes?: UserRecommendYoutubeUpdateManyWithoutUserNestedInput
    popupSettings?: UserPopupSettingsUpdateOneWithoutUserNestedInput
    displaySettings?: UserDisplaySettingsUpdateOneWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    author?: AuthorUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    characterName?: NullableStringFieldUpdateOperationsInput | string | null
    subname?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    handleChangeCount?: IntFieldUpdateOperationsInput | number
    handleChangeTokens?: IntFieldUpdateOperationsInput | number
    isPremiumUser?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    ogp?: UserOGPUncheckedUpdateOneWithoutUserNestedInput
    imageBanners?: UserImageBannerUncheckedUpdateManyWithoutUserNestedInput
    imageCarousels?: UserImageCarouselUncheckedUpdateManyWithoutUserNestedInput
    imageSidebars?: UserImageSidebarUncheckedUpdateManyWithoutUserNestedInput
    customQuestions?: UserCustomQuestionUncheckedUpdateManyWithoutUserNestedInput
    youtubeSettings?: UserYoutubeSettingsUncheckedUpdateOneWithoutUserNestedInput
    recommendYoutubes?: UserRecommendYoutubeUncheckedUpdateManyWithoutUserNestedInput
    popupSettings?: UserPopupSettingsUncheckedUpdateOneWithoutUserNestedInput
    displaySettings?: UserDisplaySettingsUncheckedUpdateOneWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    author?: AuthorUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LinkServiceUpsertWithoutLinksInput = {
    update: XOR<LinkServiceUpdateWithoutLinksInput, LinkServiceUncheckedUpdateWithoutLinksInput>
    create: XOR<LinkServiceCreateWithoutLinksInput, LinkServiceUncheckedCreateWithoutLinksInput>
    where?: LinkServiceWhereInput
  }

  export type LinkServiceUpdateToOneWithWhereWithoutLinksInput = {
    where?: LinkServiceWhereInput
    data: XOR<LinkServiceUpdateWithoutLinksInput, LinkServiceUncheckedUpdateWithoutLinksInput>
  }

  export type LinkServiceUpdateWithoutLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    allowOriginalIcon?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    icons?: ServiceIconUpdateManyWithoutServiceNestedInput
  }

  export type LinkServiceUncheckedUpdateWithoutLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    allowOriginalIcon?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    icons?: ServiceIconUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceIconUpsertWithoutLinksInput = {
    update: XOR<ServiceIconUpdateWithoutLinksInput, ServiceIconUncheckedUpdateWithoutLinksInput>
    create: XOR<ServiceIconCreateWithoutLinksInput, ServiceIconUncheckedCreateWithoutLinksInput>
    where?: ServiceIconWhereInput
  }

  export type ServiceIconUpdateToOneWithWhereWithoutLinksInput = {
    where?: ServiceIconWhereInput
    data: XOR<ServiceIconUpdateWithoutLinksInput, ServiceIconUncheckedUpdateWithoutLinksInput>
  }

  export type ServiceIconUpdateWithoutLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    style?: EnumIconStyleFieldUpdateOperationsInput | $Enums.IconStyle
    colorScheme?: EnumIconColorFieldUpdateOperationsInput | $Enums.IconColor
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: LinkServiceUpdateOneRequiredWithoutIconsNestedInput
  }

  export type ServiceIconUncheckedUpdateWithoutLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    style?: EnumIconStyleFieldUpdateOperationsInput | $Enums.IconStyle
    colorScheme?: EnumIconColorFieldUpdateOperationsInput | $Enums.IconColor
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateWithoutYoutubeSettingsInput = {
    id?: string
    email: string
    name?: string | null
    characterName?: string | null
    subname?: string | null
    bio?: string | null
    birthday?: Date | string | null
    gender?: string | null
    iconUrl?: string | null
    bannerUrl?: string | null
    handle?: string | null
    handleChangeCount?: number
    handleChangeTokens?: number
    isPremiumUser?: boolean
    role?: string
    subscriptionStatus?: string | null
    emailVerified?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    ogp?: UserOGPCreateNestedOneWithoutUserInput
    links?: UserLinkCreateNestedManyWithoutUserInput
    imageBanners?: UserImageBannerCreateNestedManyWithoutUserInput
    imageCarousels?: UserImageCarouselCreateNestedManyWithoutUserInput
    imageSidebars?: UserImageSidebarCreateNestedManyWithoutUserInput
    customQuestions?: UserCustomQuestionCreateNestedManyWithoutUserInput
    recommendYoutubes?: UserRecommendYoutubeCreateNestedManyWithoutUserInput
    popupSettings?: UserPopupSettingsCreateNestedOneWithoutUserInput
    displaySettings?: UserDisplaySettingsCreateNestedOneWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    author?: AuthorCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutYoutubeSettingsInput = {
    id?: string
    email: string
    name?: string | null
    characterName?: string | null
    subname?: string | null
    bio?: string | null
    birthday?: Date | string | null
    gender?: string | null
    iconUrl?: string | null
    bannerUrl?: string | null
    handle?: string | null
    handleChangeCount?: number
    handleChangeTokens?: number
    isPremiumUser?: boolean
    role?: string
    subscriptionStatus?: string | null
    emailVerified?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    ogp?: UserOGPUncheckedCreateNestedOneWithoutUserInput
    links?: UserLinkUncheckedCreateNestedManyWithoutUserInput
    imageBanners?: UserImageBannerUncheckedCreateNestedManyWithoutUserInput
    imageCarousels?: UserImageCarouselUncheckedCreateNestedManyWithoutUserInput
    imageSidebars?: UserImageSidebarUncheckedCreateNestedManyWithoutUserInput
    customQuestions?: UserCustomQuestionUncheckedCreateNestedManyWithoutUserInput
    recommendYoutubes?: UserRecommendYoutubeUncheckedCreateNestedManyWithoutUserInput
    popupSettings?: UserPopupSettingsUncheckedCreateNestedOneWithoutUserInput
    displaySettings?: UserDisplaySettingsUncheckedCreateNestedOneWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    author?: AuthorUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutYoutubeSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutYoutubeSettingsInput, UserUncheckedCreateWithoutYoutubeSettingsInput>
  }

  export type UserYoutubeVideoCreateWithoutSettingsInput = {
    id?: string
    url: string
    thumbnailUrl?: string | null
    title?: string | null
    description?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserYoutubeVideoUncheckedCreateWithoutSettingsInput = {
    id?: string
    url: string
    thumbnailUrl?: string | null
    title?: string | null
    description?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserYoutubeVideoCreateOrConnectWithoutSettingsInput = {
    where: UserYoutubeVideoWhereUniqueInput
    create: XOR<UserYoutubeVideoCreateWithoutSettingsInput, UserYoutubeVideoUncheckedCreateWithoutSettingsInput>
  }

  export type UserYoutubeVideoCreateManySettingsInputEnvelope = {
    data: UserYoutubeVideoCreateManySettingsInput | UserYoutubeVideoCreateManySettingsInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutYoutubeSettingsInput = {
    update: XOR<UserUpdateWithoutYoutubeSettingsInput, UserUncheckedUpdateWithoutYoutubeSettingsInput>
    create: XOR<UserCreateWithoutYoutubeSettingsInput, UserUncheckedCreateWithoutYoutubeSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutYoutubeSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutYoutubeSettingsInput, UserUncheckedUpdateWithoutYoutubeSettingsInput>
  }

  export type UserUpdateWithoutYoutubeSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    characterName?: NullableStringFieldUpdateOperationsInput | string | null
    subname?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    handleChangeCount?: IntFieldUpdateOperationsInput | number
    handleChangeTokens?: IntFieldUpdateOperationsInput | number
    isPremiumUser?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    ogp?: UserOGPUpdateOneWithoutUserNestedInput
    links?: UserLinkUpdateManyWithoutUserNestedInput
    imageBanners?: UserImageBannerUpdateManyWithoutUserNestedInput
    imageCarousels?: UserImageCarouselUpdateManyWithoutUserNestedInput
    imageSidebars?: UserImageSidebarUpdateManyWithoutUserNestedInput
    customQuestions?: UserCustomQuestionUpdateManyWithoutUserNestedInput
    recommendYoutubes?: UserRecommendYoutubeUpdateManyWithoutUserNestedInput
    popupSettings?: UserPopupSettingsUpdateOneWithoutUserNestedInput
    displaySettings?: UserDisplaySettingsUpdateOneWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    author?: AuthorUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutYoutubeSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    characterName?: NullableStringFieldUpdateOperationsInput | string | null
    subname?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    handleChangeCount?: IntFieldUpdateOperationsInput | number
    handleChangeTokens?: IntFieldUpdateOperationsInput | number
    isPremiumUser?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    ogp?: UserOGPUncheckedUpdateOneWithoutUserNestedInput
    links?: UserLinkUncheckedUpdateManyWithoutUserNestedInput
    imageBanners?: UserImageBannerUncheckedUpdateManyWithoutUserNestedInput
    imageCarousels?: UserImageCarouselUncheckedUpdateManyWithoutUserNestedInput
    imageSidebars?: UserImageSidebarUncheckedUpdateManyWithoutUserNestedInput
    customQuestions?: UserCustomQuestionUncheckedUpdateManyWithoutUserNestedInput
    recommendYoutubes?: UserRecommendYoutubeUncheckedUpdateManyWithoutUserNestedInput
    popupSettings?: UserPopupSettingsUncheckedUpdateOneWithoutUserNestedInput
    displaySettings?: UserDisplaySettingsUncheckedUpdateOneWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    author?: AuthorUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserYoutubeVideoUpsertWithWhereUniqueWithoutSettingsInput = {
    where: UserYoutubeVideoWhereUniqueInput
    update: XOR<UserYoutubeVideoUpdateWithoutSettingsInput, UserYoutubeVideoUncheckedUpdateWithoutSettingsInput>
    create: XOR<UserYoutubeVideoCreateWithoutSettingsInput, UserYoutubeVideoUncheckedCreateWithoutSettingsInput>
  }

  export type UserYoutubeVideoUpdateWithWhereUniqueWithoutSettingsInput = {
    where: UserYoutubeVideoWhereUniqueInput
    data: XOR<UserYoutubeVideoUpdateWithoutSettingsInput, UserYoutubeVideoUncheckedUpdateWithoutSettingsInput>
  }

  export type UserYoutubeVideoUpdateManyWithWhereWithoutSettingsInput = {
    where: UserYoutubeVideoScalarWhereInput
    data: XOR<UserYoutubeVideoUpdateManyMutationInput, UserYoutubeVideoUncheckedUpdateManyWithoutSettingsInput>
  }

  export type UserYoutubeVideoScalarWhereInput = {
    AND?: UserYoutubeVideoScalarWhereInput | UserYoutubeVideoScalarWhereInput[]
    OR?: UserYoutubeVideoScalarWhereInput[]
    NOT?: UserYoutubeVideoScalarWhereInput | UserYoutubeVideoScalarWhereInput[]
    id?: StringFilter<"UserYoutubeVideo"> | string
    url?: StringFilter<"UserYoutubeVideo"> | string
    thumbnailUrl?: StringNullableFilter<"UserYoutubeVideo"> | string | null
    title?: StringNullableFilter<"UserYoutubeVideo"> | string | null
    description?: StringNullableFilter<"UserYoutubeVideo"> | string | null
    publishedAt?: DateTimeNullableFilter<"UserYoutubeVideo"> | Date | string | null
    createdAt?: DateTimeFilter<"UserYoutubeVideo"> | Date | string
    updatedAt?: DateTimeFilter<"UserYoutubeVideo"> | Date | string
    settingsId?: StringFilter<"UserYoutubeVideo"> | string
  }

  export type UserCreateWithoutImageBannersInput = {
    id?: string
    email: string
    name?: string | null
    characterName?: string | null
    subname?: string | null
    bio?: string | null
    birthday?: Date | string | null
    gender?: string | null
    iconUrl?: string | null
    bannerUrl?: string | null
    handle?: string | null
    handleChangeCount?: number
    handleChangeTokens?: number
    isPremiumUser?: boolean
    role?: string
    subscriptionStatus?: string | null
    emailVerified?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    ogp?: UserOGPCreateNestedOneWithoutUserInput
    links?: UserLinkCreateNestedManyWithoutUserInput
    imageCarousels?: UserImageCarouselCreateNestedManyWithoutUserInput
    imageSidebars?: UserImageSidebarCreateNestedManyWithoutUserInput
    customQuestions?: UserCustomQuestionCreateNestedManyWithoutUserInput
    youtubeSettings?: UserYoutubeSettingsCreateNestedOneWithoutUserInput
    recommendYoutubes?: UserRecommendYoutubeCreateNestedManyWithoutUserInput
    popupSettings?: UserPopupSettingsCreateNestedOneWithoutUserInput
    displaySettings?: UserDisplaySettingsCreateNestedOneWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    author?: AuthorCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutImageBannersInput = {
    id?: string
    email: string
    name?: string | null
    characterName?: string | null
    subname?: string | null
    bio?: string | null
    birthday?: Date | string | null
    gender?: string | null
    iconUrl?: string | null
    bannerUrl?: string | null
    handle?: string | null
    handleChangeCount?: number
    handleChangeTokens?: number
    isPremiumUser?: boolean
    role?: string
    subscriptionStatus?: string | null
    emailVerified?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    ogp?: UserOGPUncheckedCreateNestedOneWithoutUserInput
    links?: UserLinkUncheckedCreateNestedManyWithoutUserInput
    imageCarousels?: UserImageCarouselUncheckedCreateNestedManyWithoutUserInput
    imageSidebars?: UserImageSidebarUncheckedCreateNestedManyWithoutUserInput
    customQuestions?: UserCustomQuestionUncheckedCreateNestedManyWithoutUserInput
    youtubeSettings?: UserYoutubeSettingsUncheckedCreateNestedOneWithoutUserInput
    recommendYoutubes?: UserRecommendYoutubeUncheckedCreateNestedManyWithoutUserInput
    popupSettings?: UserPopupSettingsUncheckedCreateNestedOneWithoutUserInput
    displaySettings?: UserDisplaySettingsUncheckedCreateNestedOneWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    author?: AuthorUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutImageBannersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutImageBannersInput, UserUncheckedCreateWithoutImageBannersInput>
  }

  export type UserUpsertWithoutImageBannersInput = {
    update: XOR<UserUpdateWithoutImageBannersInput, UserUncheckedUpdateWithoutImageBannersInput>
    create: XOR<UserCreateWithoutImageBannersInput, UserUncheckedCreateWithoutImageBannersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutImageBannersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutImageBannersInput, UserUncheckedUpdateWithoutImageBannersInput>
  }

  export type UserUpdateWithoutImageBannersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    characterName?: NullableStringFieldUpdateOperationsInput | string | null
    subname?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    handleChangeCount?: IntFieldUpdateOperationsInput | number
    handleChangeTokens?: IntFieldUpdateOperationsInput | number
    isPremiumUser?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    ogp?: UserOGPUpdateOneWithoutUserNestedInput
    links?: UserLinkUpdateManyWithoutUserNestedInput
    imageCarousels?: UserImageCarouselUpdateManyWithoutUserNestedInput
    imageSidebars?: UserImageSidebarUpdateManyWithoutUserNestedInput
    customQuestions?: UserCustomQuestionUpdateManyWithoutUserNestedInput
    youtubeSettings?: UserYoutubeSettingsUpdateOneWithoutUserNestedInput
    recommendYoutubes?: UserRecommendYoutubeUpdateManyWithoutUserNestedInput
    popupSettings?: UserPopupSettingsUpdateOneWithoutUserNestedInput
    displaySettings?: UserDisplaySettingsUpdateOneWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    author?: AuthorUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutImageBannersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    characterName?: NullableStringFieldUpdateOperationsInput | string | null
    subname?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    handleChangeCount?: IntFieldUpdateOperationsInput | number
    handleChangeTokens?: IntFieldUpdateOperationsInput | number
    isPremiumUser?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    ogp?: UserOGPUncheckedUpdateOneWithoutUserNestedInput
    links?: UserLinkUncheckedUpdateManyWithoutUserNestedInput
    imageCarousels?: UserImageCarouselUncheckedUpdateManyWithoutUserNestedInput
    imageSidebars?: UserImageSidebarUncheckedUpdateManyWithoutUserNestedInput
    customQuestions?: UserCustomQuestionUncheckedUpdateManyWithoutUserNestedInput
    youtubeSettings?: UserYoutubeSettingsUncheckedUpdateOneWithoutUserNestedInput
    recommendYoutubes?: UserRecommendYoutubeUncheckedUpdateManyWithoutUserNestedInput
    popupSettings?: UserPopupSettingsUncheckedUpdateOneWithoutUserNestedInput
    displaySettings?: UserDisplaySettingsUncheckedUpdateOneWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    author?: AuthorUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserYoutubeSettingsCreateWithoutVideosInput = {
    id?: string
    channelId?: string | null
    displayCount?: number
    lastFetchedAt?: Date | string | null
    pickupVideo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutYoutubeSettingsInput
  }

  export type UserYoutubeSettingsUncheckedCreateWithoutVideosInput = {
    id?: string
    channelId?: string | null
    displayCount?: number
    lastFetchedAt?: Date | string | null
    pickupVideo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type UserYoutubeSettingsCreateOrConnectWithoutVideosInput = {
    where: UserYoutubeSettingsWhereUniqueInput
    create: XOR<UserYoutubeSettingsCreateWithoutVideosInput, UserYoutubeSettingsUncheckedCreateWithoutVideosInput>
  }

  export type UserYoutubeSettingsUpsertWithoutVideosInput = {
    update: XOR<UserYoutubeSettingsUpdateWithoutVideosInput, UserYoutubeSettingsUncheckedUpdateWithoutVideosInput>
    create: XOR<UserYoutubeSettingsCreateWithoutVideosInput, UserYoutubeSettingsUncheckedCreateWithoutVideosInput>
    where?: UserYoutubeSettingsWhereInput
  }

  export type UserYoutubeSettingsUpdateToOneWithWhereWithoutVideosInput = {
    where?: UserYoutubeSettingsWhereInput
    data: XOR<UserYoutubeSettingsUpdateWithoutVideosInput, UserYoutubeSettingsUncheckedUpdateWithoutVideosInput>
  }

  export type UserYoutubeSettingsUpdateWithoutVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    displayCount?: IntFieldUpdateOperationsInput | number
    lastFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupVideo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutYoutubeSettingsNestedInput
  }

  export type UserYoutubeSettingsUncheckedUpdateWithoutVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: NullableStringFieldUpdateOperationsInput | string | null
    displayCount?: IntFieldUpdateOperationsInput | number
    lastFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pickupVideo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateWithoutRecommendYoutubesInput = {
    id?: string
    email: string
    name?: string | null
    characterName?: string | null
    subname?: string | null
    bio?: string | null
    birthday?: Date | string | null
    gender?: string | null
    iconUrl?: string | null
    bannerUrl?: string | null
    handle?: string | null
    handleChangeCount?: number
    handleChangeTokens?: number
    isPremiumUser?: boolean
    role?: string
    subscriptionStatus?: string | null
    emailVerified?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    ogp?: UserOGPCreateNestedOneWithoutUserInput
    links?: UserLinkCreateNestedManyWithoutUserInput
    imageBanners?: UserImageBannerCreateNestedManyWithoutUserInput
    imageCarousels?: UserImageCarouselCreateNestedManyWithoutUserInput
    imageSidebars?: UserImageSidebarCreateNestedManyWithoutUserInput
    customQuestions?: UserCustomQuestionCreateNestedManyWithoutUserInput
    youtubeSettings?: UserYoutubeSettingsCreateNestedOneWithoutUserInput
    popupSettings?: UserPopupSettingsCreateNestedOneWithoutUserInput
    displaySettings?: UserDisplaySettingsCreateNestedOneWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    author?: AuthorCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRecommendYoutubesInput = {
    id?: string
    email: string
    name?: string | null
    characterName?: string | null
    subname?: string | null
    bio?: string | null
    birthday?: Date | string | null
    gender?: string | null
    iconUrl?: string | null
    bannerUrl?: string | null
    handle?: string | null
    handleChangeCount?: number
    handleChangeTokens?: number
    isPremiumUser?: boolean
    role?: string
    subscriptionStatus?: string | null
    emailVerified?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    ogp?: UserOGPUncheckedCreateNestedOneWithoutUserInput
    links?: UserLinkUncheckedCreateNestedManyWithoutUserInput
    imageBanners?: UserImageBannerUncheckedCreateNestedManyWithoutUserInput
    imageCarousels?: UserImageCarouselUncheckedCreateNestedManyWithoutUserInput
    imageSidebars?: UserImageSidebarUncheckedCreateNestedManyWithoutUserInput
    customQuestions?: UserCustomQuestionUncheckedCreateNestedManyWithoutUserInput
    youtubeSettings?: UserYoutubeSettingsUncheckedCreateNestedOneWithoutUserInput
    popupSettings?: UserPopupSettingsUncheckedCreateNestedOneWithoutUserInput
    displaySettings?: UserDisplaySettingsUncheckedCreateNestedOneWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    author?: AuthorUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRecommendYoutubesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecommendYoutubesInput, UserUncheckedCreateWithoutRecommendYoutubesInput>
  }

  export type UserUpsertWithoutRecommendYoutubesInput = {
    update: XOR<UserUpdateWithoutRecommendYoutubesInput, UserUncheckedUpdateWithoutRecommendYoutubesInput>
    create: XOR<UserCreateWithoutRecommendYoutubesInput, UserUncheckedCreateWithoutRecommendYoutubesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRecommendYoutubesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRecommendYoutubesInput, UserUncheckedUpdateWithoutRecommendYoutubesInput>
  }

  export type UserUpdateWithoutRecommendYoutubesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    characterName?: NullableStringFieldUpdateOperationsInput | string | null
    subname?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    handleChangeCount?: IntFieldUpdateOperationsInput | number
    handleChangeTokens?: IntFieldUpdateOperationsInput | number
    isPremiumUser?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    ogp?: UserOGPUpdateOneWithoutUserNestedInput
    links?: UserLinkUpdateManyWithoutUserNestedInput
    imageBanners?: UserImageBannerUpdateManyWithoutUserNestedInput
    imageCarousels?: UserImageCarouselUpdateManyWithoutUserNestedInput
    imageSidebars?: UserImageSidebarUpdateManyWithoutUserNestedInput
    customQuestions?: UserCustomQuestionUpdateManyWithoutUserNestedInput
    youtubeSettings?: UserYoutubeSettingsUpdateOneWithoutUserNestedInput
    popupSettings?: UserPopupSettingsUpdateOneWithoutUserNestedInput
    displaySettings?: UserDisplaySettingsUpdateOneWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    author?: AuthorUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRecommendYoutubesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    characterName?: NullableStringFieldUpdateOperationsInput | string | null
    subname?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    handleChangeCount?: IntFieldUpdateOperationsInput | number
    handleChangeTokens?: IntFieldUpdateOperationsInput | number
    isPremiumUser?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    ogp?: UserOGPUncheckedUpdateOneWithoutUserNestedInput
    links?: UserLinkUncheckedUpdateManyWithoutUserNestedInput
    imageBanners?: UserImageBannerUncheckedUpdateManyWithoutUserNestedInput
    imageCarousels?: UserImageCarouselUncheckedUpdateManyWithoutUserNestedInput
    imageSidebars?: UserImageSidebarUncheckedUpdateManyWithoutUserNestedInput
    customQuestions?: UserCustomQuestionUncheckedUpdateManyWithoutUserNestedInput
    youtubeSettings?: UserYoutubeSettingsUncheckedUpdateOneWithoutUserNestedInput
    popupSettings?: UserPopupSettingsUncheckedUpdateOneWithoutUserNestedInput
    displaySettings?: UserDisplaySettingsUncheckedUpdateOneWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    author?: AuthorUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPopupSettingsInput = {
    id?: string
    email: string
    name?: string | null
    characterName?: string | null
    subname?: string | null
    bio?: string | null
    birthday?: Date | string | null
    gender?: string | null
    iconUrl?: string | null
    bannerUrl?: string | null
    handle?: string | null
    handleChangeCount?: number
    handleChangeTokens?: number
    isPremiumUser?: boolean
    role?: string
    subscriptionStatus?: string | null
    emailVerified?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    ogp?: UserOGPCreateNestedOneWithoutUserInput
    links?: UserLinkCreateNestedManyWithoutUserInput
    imageBanners?: UserImageBannerCreateNestedManyWithoutUserInput
    imageCarousels?: UserImageCarouselCreateNestedManyWithoutUserInput
    imageSidebars?: UserImageSidebarCreateNestedManyWithoutUserInput
    customQuestions?: UserCustomQuestionCreateNestedManyWithoutUserInput
    youtubeSettings?: UserYoutubeSettingsCreateNestedOneWithoutUserInput
    recommendYoutubes?: UserRecommendYoutubeCreateNestedManyWithoutUserInput
    displaySettings?: UserDisplaySettingsCreateNestedOneWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    author?: AuthorCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPopupSettingsInput = {
    id?: string
    email: string
    name?: string | null
    characterName?: string | null
    subname?: string | null
    bio?: string | null
    birthday?: Date | string | null
    gender?: string | null
    iconUrl?: string | null
    bannerUrl?: string | null
    handle?: string | null
    handleChangeCount?: number
    handleChangeTokens?: number
    isPremiumUser?: boolean
    role?: string
    subscriptionStatus?: string | null
    emailVerified?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    ogp?: UserOGPUncheckedCreateNestedOneWithoutUserInput
    links?: UserLinkUncheckedCreateNestedManyWithoutUserInput
    imageBanners?: UserImageBannerUncheckedCreateNestedManyWithoutUserInput
    imageCarousels?: UserImageCarouselUncheckedCreateNestedManyWithoutUserInput
    imageSidebars?: UserImageSidebarUncheckedCreateNestedManyWithoutUserInput
    customQuestions?: UserCustomQuestionUncheckedCreateNestedManyWithoutUserInput
    youtubeSettings?: UserYoutubeSettingsUncheckedCreateNestedOneWithoutUserInput
    recommendYoutubes?: UserRecommendYoutubeUncheckedCreateNestedManyWithoutUserInput
    displaySettings?: UserDisplaySettingsUncheckedCreateNestedOneWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    author?: AuthorUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPopupSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPopupSettingsInput, UserUncheckedCreateWithoutPopupSettingsInput>
  }

  export type UserUpsertWithoutPopupSettingsInput = {
    update: XOR<UserUpdateWithoutPopupSettingsInput, UserUncheckedUpdateWithoutPopupSettingsInput>
    create: XOR<UserCreateWithoutPopupSettingsInput, UserUncheckedCreateWithoutPopupSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPopupSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPopupSettingsInput, UserUncheckedUpdateWithoutPopupSettingsInput>
  }

  export type UserUpdateWithoutPopupSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    characterName?: NullableStringFieldUpdateOperationsInput | string | null
    subname?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    handleChangeCount?: IntFieldUpdateOperationsInput | number
    handleChangeTokens?: IntFieldUpdateOperationsInput | number
    isPremiumUser?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    ogp?: UserOGPUpdateOneWithoutUserNestedInput
    links?: UserLinkUpdateManyWithoutUserNestedInput
    imageBanners?: UserImageBannerUpdateManyWithoutUserNestedInput
    imageCarousels?: UserImageCarouselUpdateManyWithoutUserNestedInput
    imageSidebars?: UserImageSidebarUpdateManyWithoutUserNestedInput
    customQuestions?: UserCustomQuestionUpdateManyWithoutUserNestedInput
    youtubeSettings?: UserYoutubeSettingsUpdateOneWithoutUserNestedInput
    recommendYoutubes?: UserRecommendYoutubeUpdateManyWithoutUserNestedInput
    displaySettings?: UserDisplaySettingsUpdateOneWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    author?: AuthorUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPopupSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    characterName?: NullableStringFieldUpdateOperationsInput | string | null
    subname?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    handleChangeCount?: IntFieldUpdateOperationsInput | number
    handleChangeTokens?: IntFieldUpdateOperationsInput | number
    isPremiumUser?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    ogp?: UserOGPUncheckedUpdateOneWithoutUserNestedInput
    links?: UserLinkUncheckedUpdateManyWithoutUserNestedInput
    imageBanners?: UserImageBannerUncheckedUpdateManyWithoutUserNestedInput
    imageCarousels?: UserImageCarouselUncheckedUpdateManyWithoutUserNestedInput
    imageSidebars?: UserImageSidebarUncheckedUpdateManyWithoutUserNestedInput
    customQuestions?: UserCustomQuestionUncheckedUpdateManyWithoutUserNestedInput
    youtubeSettings?: UserYoutubeSettingsUncheckedUpdateOneWithoutUserNestedInput
    recommendYoutubes?: UserRecommendYoutubeUncheckedUpdateManyWithoutUserNestedInput
    displaySettings?: UserDisplaySettingsUncheckedUpdateOneWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    author?: AuthorUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutOgpInput = {
    id?: string
    email: string
    name?: string | null
    characterName?: string | null
    subname?: string | null
    bio?: string | null
    birthday?: Date | string | null
    gender?: string | null
    iconUrl?: string | null
    bannerUrl?: string | null
    handle?: string | null
    handleChangeCount?: number
    handleChangeTokens?: number
    isPremiumUser?: boolean
    role?: string
    subscriptionStatus?: string | null
    emailVerified?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    links?: UserLinkCreateNestedManyWithoutUserInput
    imageBanners?: UserImageBannerCreateNestedManyWithoutUserInput
    imageCarousels?: UserImageCarouselCreateNestedManyWithoutUserInput
    imageSidebars?: UserImageSidebarCreateNestedManyWithoutUserInput
    customQuestions?: UserCustomQuestionCreateNestedManyWithoutUserInput
    youtubeSettings?: UserYoutubeSettingsCreateNestedOneWithoutUserInput
    recommendYoutubes?: UserRecommendYoutubeCreateNestedManyWithoutUserInput
    popupSettings?: UserPopupSettingsCreateNestedOneWithoutUserInput
    displaySettings?: UserDisplaySettingsCreateNestedOneWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    author?: AuthorCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOgpInput = {
    id?: string
    email: string
    name?: string | null
    characterName?: string | null
    subname?: string | null
    bio?: string | null
    birthday?: Date | string | null
    gender?: string | null
    iconUrl?: string | null
    bannerUrl?: string | null
    handle?: string | null
    handleChangeCount?: number
    handleChangeTokens?: number
    isPremiumUser?: boolean
    role?: string
    subscriptionStatus?: string | null
    emailVerified?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    links?: UserLinkUncheckedCreateNestedManyWithoutUserInput
    imageBanners?: UserImageBannerUncheckedCreateNestedManyWithoutUserInput
    imageCarousels?: UserImageCarouselUncheckedCreateNestedManyWithoutUserInput
    imageSidebars?: UserImageSidebarUncheckedCreateNestedManyWithoutUserInput
    customQuestions?: UserCustomQuestionUncheckedCreateNestedManyWithoutUserInput
    youtubeSettings?: UserYoutubeSettingsUncheckedCreateNestedOneWithoutUserInput
    recommendYoutubes?: UserRecommendYoutubeUncheckedCreateNestedManyWithoutUserInput
    popupSettings?: UserPopupSettingsUncheckedCreateNestedOneWithoutUserInput
    displaySettings?: UserDisplaySettingsUncheckedCreateNestedOneWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    author?: AuthorUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOgpInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOgpInput, UserUncheckedCreateWithoutOgpInput>
  }

  export type UserUpsertWithoutOgpInput = {
    update: XOR<UserUpdateWithoutOgpInput, UserUncheckedUpdateWithoutOgpInput>
    create: XOR<UserCreateWithoutOgpInput, UserUncheckedCreateWithoutOgpInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOgpInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOgpInput, UserUncheckedUpdateWithoutOgpInput>
  }

  export type UserUpdateWithoutOgpInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    characterName?: NullableStringFieldUpdateOperationsInput | string | null
    subname?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    handleChangeCount?: IntFieldUpdateOperationsInput | number
    handleChangeTokens?: IntFieldUpdateOperationsInput | number
    isPremiumUser?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    links?: UserLinkUpdateManyWithoutUserNestedInput
    imageBanners?: UserImageBannerUpdateManyWithoutUserNestedInput
    imageCarousels?: UserImageCarouselUpdateManyWithoutUserNestedInput
    imageSidebars?: UserImageSidebarUpdateManyWithoutUserNestedInput
    customQuestions?: UserCustomQuestionUpdateManyWithoutUserNestedInput
    youtubeSettings?: UserYoutubeSettingsUpdateOneWithoutUserNestedInput
    recommendYoutubes?: UserRecommendYoutubeUpdateManyWithoutUserNestedInput
    popupSettings?: UserPopupSettingsUpdateOneWithoutUserNestedInput
    displaySettings?: UserDisplaySettingsUpdateOneWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    author?: AuthorUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOgpInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    characterName?: NullableStringFieldUpdateOperationsInput | string | null
    subname?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    handleChangeCount?: IntFieldUpdateOperationsInput | number
    handleChangeTokens?: IntFieldUpdateOperationsInput | number
    isPremiumUser?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    links?: UserLinkUncheckedUpdateManyWithoutUserNestedInput
    imageBanners?: UserImageBannerUncheckedUpdateManyWithoutUserNestedInput
    imageCarousels?: UserImageCarouselUncheckedUpdateManyWithoutUserNestedInput
    imageSidebars?: UserImageSidebarUncheckedUpdateManyWithoutUserNestedInput
    customQuestions?: UserCustomQuestionUncheckedUpdateManyWithoutUserNestedInput
    youtubeSettings?: UserYoutubeSettingsUncheckedUpdateOneWithoutUserNestedInput
    recommendYoutubes?: UserRecommendYoutubeUncheckedUpdateManyWithoutUserNestedInput
    popupSettings?: UserPopupSettingsUncheckedUpdateOneWithoutUserNestedInput
    displaySettings?: UserDisplaySettingsUncheckedUpdateOneWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    author?: AuthorUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCustomQuestionsInput = {
    id?: string
    email: string
    name?: string | null
    characterName?: string | null
    subname?: string | null
    bio?: string | null
    birthday?: Date | string | null
    gender?: string | null
    iconUrl?: string | null
    bannerUrl?: string | null
    handle?: string | null
    handleChangeCount?: number
    handleChangeTokens?: number
    isPremiumUser?: boolean
    role?: string
    subscriptionStatus?: string | null
    emailVerified?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    ogp?: UserOGPCreateNestedOneWithoutUserInput
    links?: UserLinkCreateNestedManyWithoutUserInput
    imageBanners?: UserImageBannerCreateNestedManyWithoutUserInput
    imageCarousels?: UserImageCarouselCreateNestedManyWithoutUserInput
    imageSidebars?: UserImageSidebarCreateNestedManyWithoutUserInput
    youtubeSettings?: UserYoutubeSettingsCreateNestedOneWithoutUserInput
    recommendYoutubes?: UserRecommendYoutubeCreateNestedManyWithoutUserInput
    popupSettings?: UserPopupSettingsCreateNestedOneWithoutUserInput
    displaySettings?: UserDisplaySettingsCreateNestedOneWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    author?: AuthorCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCustomQuestionsInput = {
    id?: string
    email: string
    name?: string | null
    characterName?: string | null
    subname?: string | null
    bio?: string | null
    birthday?: Date | string | null
    gender?: string | null
    iconUrl?: string | null
    bannerUrl?: string | null
    handle?: string | null
    handleChangeCount?: number
    handleChangeTokens?: number
    isPremiumUser?: boolean
    role?: string
    subscriptionStatus?: string | null
    emailVerified?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    ogp?: UserOGPUncheckedCreateNestedOneWithoutUserInput
    links?: UserLinkUncheckedCreateNestedManyWithoutUserInput
    imageBanners?: UserImageBannerUncheckedCreateNestedManyWithoutUserInput
    imageCarousels?: UserImageCarouselUncheckedCreateNestedManyWithoutUserInput
    imageSidebars?: UserImageSidebarUncheckedCreateNestedManyWithoutUserInput
    youtubeSettings?: UserYoutubeSettingsUncheckedCreateNestedOneWithoutUserInput
    recommendYoutubes?: UserRecommendYoutubeUncheckedCreateNestedManyWithoutUserInput
    popupSettings?: UserPopupSettingsUncheckedCreateNestedOneWithoutUserInput
    displaySettings?: UserDisplaySettingsUncheckedCreateNestedOneWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    author?: AuthorUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCustomQuestionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCustomQuestionsInput, UserUncheckedCreateWithoutCustomQuestionsInput>
  }

  export type UserUpsertWithoutCustomQuestionsInput = {
    update: XOR<UserUpdateWithoutCustomQuestionsInput, UserUncheckedUpdateWithoutCustomQuestionsInput>
    create: XOR<UserCreateWithoutCustomQuestionsInput, UserUncheckedCreateWithoutCustomQuestionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCustomQuestionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCustomQuestionsInput, UserUncheckedUpdateWithoutCustomQuestionsInput>
  }

  export type UserUpdateWithoutCustomQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    characterName?: NullableStringFieldUpdateOperationsInput | string | null
    subname?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    handleChangeCount?: IntFieldUpdateOperationsInput | number
    handleChangeTokens?: IntFieldUpdateOperationsInput | number
    isPremiumUser?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    ogp?: UserOGPUpdateOneWithoutUserNestedInput
    links?: UserLinkUpdateManyWithoutUserNestedInput
    imageBanners?: UserImageBannerUpdateManyWithoutUserNestedInput
    imageCarousels?: UserImageCarouselUpdateManyWithoutUserNestedInput
    imageSidebars?: UserImageSidebarUpdateManyWithoutUserNestedInput
    youtubeSettings?: UserYoutubeSettingsUpdateOneWithoutUserNestedInput
    recommendYoutubes?: UserRecommendYoutubeUpdateManyWithoutUserNestedInput
    popupSettings?: UserPopupSettingsUpdateOneWithoutUserNestedInput
    displaySettings?: UserDisplaySettingsUpdateOneWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    author?: AuthorUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCustomQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    characterName?: NullableStringFieldUpdateOperationsInput | string | null
    subname?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    handleChangeCount?: IntFieldUpdateOperationsInput | number
    handleChangeTokens?: IntFieldUpdateOperationsInput | number
    isPremiumUser?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    ogp?: UserOGPUncheckedUpdateOneWithoutUserNestedInput
    links?: UserLinkUncheckedUpdateManyWithoutUserNestedInput
    imageBanners?: UserImageBannerUncheckedUpdateManyWithoutUserNestedInput
    imageCarousels?: UserImageCarouselUncheckedUpdateManyWithoutUserNestedInput
    imageSidebars?: UserImageSidebarUncheckedUpdateManyWithoutUserNestedInput
    youtubeSettings?: UserYoutubeSettingsUncheckedUpdateOneWithoutUserNestedInput
    recommendYoutubes?: UserRecommendYoutubeUncheckedUpdateManyWithoutUserNestedInput
    popupSettings?: UserPopupSettingsUncheckedUpdateOneWithoutUserNestedInput
    displaySettings?: UserDisplaySettingsUncheckedUpdateOneWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    author?: AuthorUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutImageCarouselsInput = {
    id?: string
    email: string
    name?: string | null
    characterName?: string | null
    subname?: string | null
    bio?: string | null
    birthday?: Date | string | null
    gender?: string | null
    iconUrl?: string | null
    bannerUrl?: string | null
    handle?: string | null
    handleChangeCount?: number
    handleChangeTokens?: number
    isPremiumUser?: boolean
    role?: string
    subscriptionStatus?: string | null
    emailVerified?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    ogp?: UserOGPCreateNestedOneWithoutUserInput
    links?: UserLinkCreateNestedManyWithoutUserInput
    imageBanners?: UserImageBannerCreateNestedManyWithoutUserInput
    imageSidebars?: UserImageSidebarCreateNestedManyWithoutUserInput
    customQuestions?: UserCustomQuestionCreateNestedManyWithoutUserInput
    youtubeSettings?: UserYoutubeSettingsCreateNestedOneWithoutUserInput
    recommendYoutubes?: UserRecommendYoutubeCreateNestedManyWithoutUserInput
    popupSettings?: UserPopupSettingsCreateNestedOneWithoutUserInput
    displaySettings?: UserDisplaySettingsCreateNestedOneWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    author?: AuthorCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutImageCarouselsInput = {
    id?: string
    email: string
    name?: string | null
    characterName?: string | null
    subname?: string | null
    bio?: string | null
    birthday?: Date | string | null
    gender?: string | null
    iconUrl?: string | null
    bannerUrl?: string | null
    handle?: string | null
    handleChangeCount?: number
    handleChangeTokens?: number
    isPremiumUser?: boolean
    role?: string
    subscriptionStatus?: string | null
    emailVerified?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    ogp?: UserOGPUncheckedCreateNestedOneWithoutUserInput
    links?: UserLinkUncheckedCreateNestedManyWithoutUserInput
    imageBanners?: UserImageBannerUncheckedCreateNestedManyWithoutUserInput
    imageSidebars?: UserImageSidebarUncheckedCreateNestedManyWithoutUserInput
    customQuestions?: UserCustomQuestionUncheckedCreateNestedManyWithoutUserInput
    youtubeSettings?: UserYoutubeSettingsUncheckedCreateNestedOneWithoutUserInput
    recommendYoutubes?: UserRecommendYoutubeUncheckedCreateNestedManyWithoutUserInput
    popupSettings?: UserPopupSettingsUncheckedCreateNestedOneWithoutUserInput
    displaySettings?: UserDisplaySettingsUncheckedCreateNestedOneWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    author?: AuthorUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutImageCarouselsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutImageCarouselsInput, UserUncheckedCreateWithoutImageCarouselsInput>
  }

  export type UserUpsertWithoutImageCarouselsInput = {
    update: XOR<UserUpdateWithoutImageCarouselsInput, UserUncheckedUpdateWithoutImageCarouselsInput>
    create: XOR<UserCreateWithoutImageCarouselsInput, UserUncheckedCreateWithoutImageCarouselsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutImageCarouselsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutImageCarouselsInput, UserUncheckedUpdateWithoutImageCarouselsInput>
  }

  export type UserUpdateWithoutImageCarouselsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    characterName?: NullableStringFieldUpdateOperationsInput | string | null
    subname?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    handleChangeCount?: IntFieldUpdateOperationsInput | number
    handleChangeTokens?: IntFieldUpdateOperationsInput | number
    isPremiumUser?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    ogp?: UserOGPUpdateOneWithoutUserNestedInput
    links?: UserLinkUpdateManyWithoutUserNestedInput
    imageBanners?: UserImageBannerUpdateManyWithoutUserNestedInput
    imageSidebars?: UserImageSidebarUpdateManyWithoutUserNestedInput
    customQuestions?: UserCustomQuestionUpdateManyWithoutUserNestedInput
    youtubeSettings?: UserYoutubeSettingsUpdateOneWithoutUserNestedInput
    recommendYoutubes?: UserRecommendYoutubeUpdateManyWithoutUserNestedInput
    popupSettings?: UserPopupSettingsUpdateOneWithoutUserNestedInput
    displaySettings?: UserDisplaySettingsUpdateOneWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    author?: AuthorUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutImageCarouselsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    characterName?: NullableStringFieldUpdateOperationsInput | string | null
    subname?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    handleChangeCount?: IntFieldUpdateOperationsInput | number
    handleChangeTokens?: IntFieldUpdateOperationsInput | number
    isPremiumUser?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    ogp?: UserOGPUncheckedUpdateOneWithoutUserNestedInput
    links?: UserLinkUncheckedUpdateManyWithoutUserNestedInput
    imageBanners?: UserImageBannerUncheckedUpdateManyWithoutUserNestedInput
    imageSidebars?: UserImageSidebarUncheckedUpdateManyWithoutUserNestedInput
    customQuestions?: UserCustomQuestionUncheckedUpdateManyWithoutUserNestedInput
    youtubeSettings?: UserYoutubeSettingsUncheckedUpdateOneWithoutUserNestedInput
    recommendYoutubes?: UserRecommendYoutubeUncheckedUpdateManyWithoutUserNestedInput
    popupSettings?: UserPopupSettingsUncheckedUpdateOneWithoutUserNestedInput
    displaySettings?: UserDisplaySettingsUncheckedUpdateOneWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    author?: AuthorUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutImageSidebarsInput = {
    id?: string
    email: string
    name?: string | null
    characterName?: string | null
    subname?: string | null
    bio?: string | null
    birthday?: Date | string | null
    gender?: string | null
    iconUrl?: string | null
    bannerUrl?: string | null
    handle?: string | null
    handleChangeCount?: number
    handleChangeTokens?: number
    isPremiumUser?: boolean
    role?: string
    subscriptionStatus?: string | null
    emailVerified?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    ogp?: UserOGPCreateNestedOneWithoutUserInput
    links?: UserLinkCreateNestedManyWithoutUserInput
    imageBanners?: UserImageBannerCreateNestedManyWithoutUserInput
    imageCarousels?: UserImageCarouselCreateNestedManyWithoutUserInput
    customQuestions?: UserCustomQuestionCreateNestedManyWithoutUserInput
    youtubeSettings?: UserYoutubeSettingsCreateNestedOneWithoutUserInput
    recommendYoutubes?: UserRecommendYoutubeCreateNestedManyWithoutUserInput
    popupSettings?: UserPopupSettingsCreateNestedOneWithoutUserInput
    displaySettings?: UserDisplaySettingsCreateNestedOneWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    author?: AuthorCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutImageSidebarsInput = {
    id?: string
    email: string
    name?: string | null
    characterName?: string | null
    subname?: string | null
    bio?: string | null
    birthday?: Date | string | null
    gender?: string | null
    iconUrl?: string | null
    bannerUrl?: string | null
    handle?: string | null
    handleChangeCount?: number
    handleChangeTokens?: number
    isPremiumUser?: boolean
    role?: string
    subscriptionStatus?: string | null
    emailVerified?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    ogp?: UserOGPUncheckedCreateNestedOneWithoutUserInput
    links?: UserLinkUncheckedCreateNestedManyWithoutUserInput
    imageBanners?: UserImageBannerUncheckedCreateNestedManyWithoutUserInput
    imageCarousels?: UserImageCarouselUncheckedCreateNestedManyWithoutUserInput
    customQuestions?: UserCustomQuestionUncheckedCreateNestedManyWithoutUserInput
    youtubeSettings?: UserYoutubeSettingsUncheckedCreateNestedOneWithoutUserInput
    recommendYoutubes?: UserRecommendYoutubeUncheckedCreateNestedManyWithoutUserInput
    popupSettings?: UserPopupSettingsUncheckedCreateNestedOneWithoutUserInput
    displaySettings?: UserDisplaySettingsUncheckedCreateNestedOneWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    author?: AuthorUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutImageSidebarsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutImageSidebarsInput, UserUncheckedCreateWithoutImageSidebarsInput>
  }

  export type UserUpsertWithoutImageSidebarsInput = {
    update: XOR<UserUpdateWithoutImageSidebarsInput, UserUncheckedUpdateWithoutImageSidebarsInput>
    create: XOR<UserCreateWithoutImageSidebarsInput, UserUncheckedCreateWithoutImageSidebarsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutImageSidebarsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutImageSidebarsInput, UserUncheckedUpdateWithoutImageSidebarsInput>
  }

  export type UserUpdateWithoutImageSidebarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    characterName?: NullableStringFieldUpdateOperationsInput | string | null
    subname?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    handleChangeCount?: IntFieldUpdateOperationsInput | number
    handleChangeTokens?: IntFieldUpdateOperationsInput | number
    isPremiumUser?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    ogp?: UserOGPUpdateOneWithoutUserNestedInput
    links?: UserLinkUpdateManyWithoutUserNestedInput
    imageBanners?: UserImageBannerUpdateManyWithoutUserNestedInput
    imageCarousels?: UserImageCarouselUpdateManyWithoutUserNestedInput
    customQuestions?: UserCustomQuestionUpdateManyWithoutUserNestedInput
    youtubeSettings?: UserYoutubeSettingsUpdateOneWithoutUserNestedInput
    recommendYoutubes?: UserRecommendYoutubeUpdateManyWithoutUserNestedInput
    popupSettings?: UserPopupSettingsUpdateOneWithoutUserNestedInput
    displaySettings?: UserDisplaySettingsUpdateOneWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    author?: AuthorUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutImageSidebarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    characterName?: NullableStringFieldUpdateOperationsInput | string | null
    subname?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    handleChangeCount?: IntFieldUpdateOperationsInput | number
    handleChangeTokens?: IntFieldUpdateOperationsInput | number
    isPremiumUser?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    ogp?: UserOGPUncheckedUpdateOneWithoutUserNestedInput
    links?: UserLinkUncheckedUpdateManyWithoutUserNestedInput
    imageBanners?: UserImageBannerUncheckedUpdateManyWithoutUserNestedInput
    imageCarousels?: UserImageCarouselUncheckedUpdateManyWithoutUserNestedInput
    customQuestions?: UserCustomQuestionUncheckedUpdateManyWithoutUserNestedInput
    youtubeSettings?: UserYoutubeSettingsUncheckedUpdateOneWithoutUserNestedInput
    recommendYoutubes?: UserRecommendYoutubeUncheckedUpdateManyWithoutUserNestedInput
    popupSettings?: UserPopupSettingsUncheckedUpdateOneWithoutUserNestedInput
    displaySettings?: UserDisplaySettingsUncheckedUpdateOneWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    author?: AuthorUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDisplaySettingsInput = {
    id?: string
    email: string
    name?: string | null
    characterName?: string | null
    subname?: string | null
    bio?: string | null
    birthday?: Date | string | null
    gender?: string | null
    iconUrl?: string | null
    bannerUrl?: string | null
    handle?: string | null
    handleChangeCount?: number
    handleChangeTokens?: number
    isPremiumUser?: boolean
    role?: string
    subscriptionStatus?: string | null
    emailVerified?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    ogp?: UserOGPCreateNestedOneWithoutUserInput
    links?: UserLinkCreateNestedManyWithoutUserInput
    imageBanners?: UserImageBannerCreateNestedManyWithoutUserInput
    imageCarousels?: UserImageCarouselCreateNestedManyWithoutUserInput
    imageSidebars?: UserImageSidebarCreateNestedManyWithoutUserInput
    customQuestions?: UserCustomQuestionCreateNestedManyWithoutUserInput
    youtubeSettings?: UserYoutubeSettingsCreateNestedOneWithoutUserInput
    recommendYoutubes?: UserRecommendYoutubeCreateNestedManyWithoutUserInput
    popupSettings?: UserPopupSettingsCreateNestedOneWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    author?: AuthorCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDisplaySettingsInput = {
    id?: string
    email: string
    name?: string | null
    characterName?: string | null
    subname?: string | null
    bio?: string | null
    birthday?: Date | string | null
    gender?: string | null
    iconUrl?: string | null
    bannerUrl?: string | null
    handle?: string | null
    handleChangeCount?: number
    handleChangeTokens?: number
    isPremiumUser?: boolean
    role?: string
    subscriptionStatus?: string | null
    emailVerified?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    ogp?: UserOGPUncheckedCreateNestedOneWithoutUserInput
    links?: UserLinkUncheckedCreateNestedManyWithoutUserInput
    imageBanners?: UserImageBannerUncheckedCreateNestedManyWithoutUserInput
    imageCarousels?: UserImageCarouselUncheckedCreateNestedManyWithoutUserInput
    imageSidebars?: UserImageSidebarUncheckedCreateNestedManyWithoutUserInput
    customQuestions?: UserCustomQuestionUncheckedCreateNestedManyWithoutUserInput
    youtubeSettings?: UserYoutubeSettingsUncheckedCreateNestedOneWithoutUserInput
    recommendYoutubes?: UserRecommendYoutubeUncheckedCreateNestedManyWithoutUserInput
    popupSettings?: UserPopupSettingsUncheckedCreateNestedOneWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    author?: AuthorUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDisplaySettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDisplaySettingsInput, UserUncheckedCreateWithoutDisplaySettingsInput>
  }

  export type UserUpsertWithoutDisplaySettingsInput = {
    update: XOR<UserUpdateWithoutDisplaySettingsInput, UserUncheckedUpdateWithoutDisplaySettingsInput>
    create: XOR<UserCreateWithoutDisplaySettingsInput, UserUncheckedCreateWithoutDisplaySettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDisplaySettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDisplaySettingsInput, UserUncheckedUpdateWithoutDisplaySettingsInput>
  }

  export type UserUpdateWithoutDisplaySettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    characterName?: NullableStringFieldUpdateOperationsInput | string | null
    subname?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    handleChangeCount?: IntFieldUpdateOperationsInput | number
    handleChangeTokens?: IntFieldUpdateOperationsInput | number
    isPremiumUser?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    ogp?: UserOGPUpdateOneWithoutUserNestedInput
    links?: UserLinkUpdateManyWithoutUserNestedInput
    imageBanners?: UserImageBannerUpdateManyWithoutUserNestedInput
    imageCarousels?: UserImageCarouselUpdateManyWithoutUserNestedInput
    imageSidebars?: UserImageSidebarUpdateManyWithoutUserNestedInput
    customQuestions?: UserCustomQuestionUpdateManyWithoutUserNestedInput
    youtubeSettings?: UserYoutubeSettingsUpdateOneWithoutUserNestedInput
    recommendYoutubes?: UserRecommendYoutubeUpdateManyWithoutUserNestedInput
    popupSettings?: UserPopupSettingsUpdateOneWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    author?: AuthorUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDisplaySettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    characterName?: NullableStringFieldUpdateOperationsInput | string | null
    subname?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    handleChangeCount?: IntFieldUpdateOperationsInput | number
    handleChangeTokens?: IntFieldUpdateOperationsInput | number
    isPremiumUser?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    ogp?: UserOGPUncheckedUpdateOneWithoutUserNestedInput
    links?: UserLinkUncheckedUpdateManyWithoutUserNestedInput
    imageBanners?: UserImageBannerUncheckedUpdateManyWithoutUserNestedInput
    imageCarousels?: UserImageCarouselUncheckedUpdateManyWithoutUserNestedInput
    imageSidebars?: UserImageSidebarUncheckedUpdateManyWithoutUserNestedInput
    customQuestions?: UserCustomQuestionUncheckedUpdateManyWithoutUserNestedInput
    youtubeSettings?: UserYoutubeSettingsUncheckedUpdateOneWithoutUserNestedInput
    recommendYoutubes?: UserRecommendYoutubeUncheckedUpdateManyWithoutUserNestedInput
    popupSettings?: UserPopupSettingsUncheckedUpdateOneWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    author?: AuthorUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ServiceIconCreateWithoutServiceInput = {
    id?: string
    name: string
    fileName: string
    filePath: string
    style: $Enums.IconStyle
    colorScheme: $Enums.IconColor
    description?: string | null
    isActive?: boolean
    sortOrder?: number
    uploadedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    links?: UserLinkCreateNestedManyWithoutIconInput
  }

  export type ServiceIconUncheckedCreateWithoutServiceInput = {
    id?: string
    name: string
    fileName: string
    filePath: string
    style: $Enums.IconStyle
    colorScheme: $Enums.IconColor
    description?: string | null
    isActive?: boolean
    sortOrder?: number
    uploadedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    links?: UserLinkUncheckedCreateNestedManyWithoutIconInput
  }

  export type ServiceIconCreateOrConnectWithoutServiceInput = {
    where: ServiceIconWhereUniqueInput
    create: XOR<ServiceIconCreateWithoutServiceInput, ServiceIconUncheckedCreateWithoutServiceInput>
  }

  export type ServiceIconCreateManyServiceInputEnvelope = {
    data: ServiceIconCreateManyServiceInput | ServiceIconCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type UserLinkCreateWithoutServiceInput = {
    id?: string
    url: string
    title?: string | null
    description?: string | null
    sortOrder?: number
    isActive?: boolean
    useOriginalIcon?: boolean
    originalIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLinksInput
    icon?: ServiceIconCreateNestedOneWithoutLinksInput
  }

  export type UserLinkUncheckedCreateWithoutServiceInput = {
    id?: string
    url: string
    title?: string | null
    description?: string | null
    sortOrder?: number
    isActive?: boolean
    useOriginalIcon?: boolean
    originalIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    iconId?: string | null
  }

  export type UserLinkCreateOrConnectWithoutServiceInput = {
    where: UserLinkWhereUniqueInput
    create: XOR<UserLinkCreateWithoutServiceInput, UserLinkUncheckedCreateWithoutServiceInput>
  }

  export type UserLinkCreateManyServiceInputEnvelope = {
    data: UserLinkCreateManyServiceInput | UserLinkCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ServiceIconUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceIconWhereUniqueInput
    update: XOR<ServiceIconUpdateWithoutServiceInput, ServiceIconUncheckedUpdateWithoutServiceInput>
    create: XOR<ServiceIconCreateWithoutServiceInput, ServiceIconUncheckedCreateWithoutServiceInput>
  }

  export type ServiceIconUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceIconWhereUniqueInput
    data: XOR<ServiceIconUpdateWithoutServiceInput, ServiceIconUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceIconUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceIconScalarWhereInput
    data: XOR<ServiceIconUpdateManyMutationInput, ServiceIconUncheckedUpdateManyWithoutServiceInput>
  }

  export type ServiceIconScalarWhereInput = {
    AND?: ServiceIconScalarWhereInput | ServiceIconScalarWhereInput[]
    OR?: ServiceIconScalarWhereInput[]
    NOT?: ServiceIconScalarWhereInput | ServiceIconScalarWhereInput[]
    id?: StringFilter<"ServiceIcon"> | string
    name?: StringFilter<"ServiceIcon"> | string
    fileName?: StringFilter<"ServiceIcon"> | string
    filePath?: StringFilter<"ServiceIcon"> | string
    style?: EnumIconStyleFilter<"ServiceIcon"> | $Enums.IconStyle
    colorScheme?: EnumIconColorFilter<"ServiceIcon"> | $Enums.IconColor
    description?: StringNullableFilter<"ServiceIcon"> | string | null
    isActive?: BoolFilter<"ServiceIcon"> | boolean
    sortOrder?: IntFilter<"ServiceIcon"> | number
    uploadedBy?: StringNullableFilter<"ServiceIcon"> | string | null
    createdAt?: DateTimeFilter<"ServiceIcon"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceIcon"> | Date | string
    serviceId?: StringFilter<"ServiceIcon"> | string
  }

  export type UserLinkUpsertWithWhereUniqueWithoutServiceInput = {
    where: UserLinkWhereUniqueInput
    update: XOR<UserLinkUpdateWithoutServiceInput, UserLinkUncheckedUpdateWithoutServiceInput>
    create: XOR<UserLinkCreateWithoutServiceInput, UserLinkUncheckedCreateWithoutServiceInput>
  }

  export type UserLinkUpdateWithWhereUniqueWithoutServiceInput = {
    where: UserLinkWhereUniqueInput
    data: XOR<UserLinkUpdateWithoutServiceInput, UserLinkUncheckedUpdateWithoutServiceInput>
  }

  export type UserLinkUpdateManyWithWhereWithoutServiceInput = {
    where: UserLinkScalarWhereInput
    data: XOR<UserLinkUpdateManyMutationInput, UserLinkUncheckedUpdateManyWithoutServiceInput>
  }

  export type LinkServiceCreateWithoutIconsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    baseUrl?: string | null
    allowOriginalIcon?: boolean
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    links?: UserLinkCreateNestedManyWithoutServiceInput
  }

  export type LinkServiceUncheckedCreateWithoutIconsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    baseUrl?: string | null
    allowOriginalIcon?: boolean
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    links?: UserLinkUncheckedCreateNestedManyWithoutServiceInput
  }

  export type LinkServiceCreateOrConnectWithoutIconsInput = {
    where: LinkServiceWhereUniqueInput
    create: XOR<LinkServiceCreateWithoutIconsInput, LinkServiceUncheckedCreateWithoutIconsInput>
  }

  export type UserLinkCreateWithoutIconInput = {
    id?: string
    url: string
    title?: string | null
    description?: string | null
    sortOrder?: number
    isActive?: boolean
    useOriginalIcon?: boolean
    originalIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLinksInput
    service: LinkServiceCreateNestedOneWithoutLinksInput
  }

  export type UserLinkUncheckedCreateWithoutIconInput = {
    id?: string
    url: string
    title?: string | null
    description?: string | null
    sortOrder?: number
    isActive?: boolean
    useOriginalIcon?: boolean
    originalIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    serviceId: string
  }

  export type UserLinkCreateOrConnectWithoutIconInput = {
    where: UserLinkWhereUniqueInput
    create: XOR<UserLinkCreateWithoutIconInput, UserLinkUncheckedCreateWithoutIconInput>
  }

  export type UserLinkCreateManyIconInputEnvelope = {
    data: UserLinkCreateManyIconInput | UserLinkCreateManyIconInput[]
    skipDuplicates?: boolean
  }

  export type LinkServiceUpsertWithoutIconsInput = {
    update: XOR<LinkServiceUpdateWithoutIconsInput, LinkServiceUncheckedUpdateWithoutIconsInput>
    create: XOR<LinkServiceCreateWithoutIconsInput, LinkServiceUncheckedCreateWithoutIconsInput>
    where?: LinkServiceWhereInput
  }

  export type LinkServiceUpdateToOneWithWhereWithoutIconsInput = {
    where?: LinkServiceWhereInput
    data: XOR<LinkServiceUpdateWithoutIconsInput, LinkServiceUncheckedUpdateWithoutIconsInput>
  }

  export type LinkServiceUpdateWithoutIconsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    allowOriginalIcon?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    links?: UserLinkUpdateManyWithoutServiceNestedInput
  }

  export type LinkServiceUncheckedUpdateWithoutIconsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    allowOriginalIcon?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    links?: UserLinkUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type UserLinkUpsertWithWhereUniqueWithoutIconInput = {
    where: UserLinkWhereUniqueInput
    update: XOR<UserLinkUpdateWithoutIconInput, UserLinkUncheckedUpdateWithoutIconInput>
    create: XOR<UserLinkCreateWithoutIconInput, UserLinkUncheckedCreateWithoutIconInput>
  }

  export type UserLinkUpdateWithWhereUniqueWithoutIconInput = {
    where: UserLinkWhereUniqueInput
    data: XOR<UserLinkUpdateWithoutIconInput, UserLinkUncheckedUpdateWithoutIconInput>
  }

  export type UserLinkUpdateManyWithWhereWithoutIconInput = {
    where: UserLinkScalarWhereInput
    data: XOR<UserLinkUpdateManyMutationInput, UserLinkUncheckedUpdateManyWithoutIconInput>
  }

  export type UserCreateWithoutAuthorInput = {
    id?: string
    email: string
    name?: string | null
    characterName?: string | null
    subname?: string | null
    bio?: string | null
    birthday?: Date | string | null
    gender?: string | null
    iconUrl?: string | null
    bannerUrl?: string | null
    handle?: string | null
    handleChangeCount?: number
    handleChangeTokens?: number
    isPremiumUser?: boolean
    role?: string
    subscriptionStatus?: string | null
    emailVerified?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    ogp?: UserOGPCreateNestedOneWithoutUserInput
    links?: UserLinkCreateNestedManyWithoutUserInput
    imageBanners?: UserImageBannerCreateNestedManyWithoutUserInput
    imageCarousels?: UserImageCarouselCreateNestedManyWithoutUserInput
    imageSidebars?: UserImageSidebarCreateNestedManyWithoutUserInput
    customQuestions?: UserCustomQuestionCreateNestedManyWithoutUserInput
    youtubeSettings?: UserYoutubeSettingsCreateNestedOneWithoutUserInput
    recommendYoutubes?: UserRecommendYoutubeCreateNestedManyWithoutUserInput
    popupSettings?: UserPopupSettingsCreateNestedOneWithoutUserInput
    displaySettings?: UserDisplaySettingsCreateNestedOneWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuthorInput = {
    id?: string
    email: string
    name?: string | null
    characterName?: string | null
    subname?: string | null
    bio?: string | null
    birthday?: Date | string | null
    gender?: string | null
    iconUrl?: string | null
    bannerUrl?: string | null
    handle?: string | null
    handleChangeCount?: number
    handleChangeTokens?: number
    isPremiumUser?: boolean
    role?: string
    subscriptionStatus?: string | null
    emailVerified?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    ogp?: UserOGPUncheckedCreateNestedOneWithoutUserInput
    links?: UserLinkUncheckedCreateNestedManyWithoutUserInput
    imageBanners?: UserImageBannerUncheckedCreateNestedManyWithoutUserInput
    imageCarousels?: UserImageCarouselUncheckedCreateNestedManyWithoutUserInput
    imageSidebars?: UserImageSidebarUncheckedCreateNestedManyWithoutUserInput
    customQuestions?: UserCustomQuestionUncheckedCreateNestedManyWithoutUserInput
    youtubeSettings?: UserYoutubeSettingsUncheckedCreateNestedOneWithoutUserInput
    recommendYoutubes?: UserRecommendYoutubeUncheckedCreateNestedManyWithoutUserInput
    popupSettings?: UserPopupSettingsUncheckedCreateNestedOneWithoutUserInput
    displaySettings?: UserDisplaySettingsUncheckedCreateNestedOneWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuthorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuthorInput, UserUncheckedCreateWithoutAuthorInput>
  }

  export type ArticleCreateWithoutAuthorInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    featuredImage?: string | null
    status?: $Enums.ArticleStatus
    viewCount?: number
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ArticleCategoryCreateNestedManyWithoutArticleInput
    tags?: ArticleTagCreateNestedManyWithoutArticleInput
    comments?: CommentCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutAuthorInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    featuredImage?: string | null
    status?: $Enums.ArticleStatus
    viewCount?: number
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: ArticleCategoryUncheckedCreateNestedManyWithoutArticleInput
    tags?: ArticleTagUncheckedCreateNestedManyWithoutArticleInput
    comments?: CommentUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutAuthorInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutAuthorInput, ArticleUncheckedCreateWithoutAuthorInput>
  }

  export type ArticleCreateManyAuthorInputEnvelope = {
    data: ArticleCreateManyAuthorInput | ArticleCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAuthorInput = {
    update: XOR<UserUpdateWithoutAuthorInput, UserUncheckedUpdateWithoutAuthorInput>
    create: XOR<UserCreateWithoutAuthorInput, UserUncheckedCreateWithoutAuthorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuthorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuthorInput, UserUncheckedUpdateWithoutAuthorInput>
  }

  export type UserUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    characterName?: NullableStringFieldUpdateOperationsInput | string | null
    subname?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    handleChangeCount?: IntFieldUpdateOperationsInput | number
    handleChangeTokens?: IntFieldUpdateOperationsInput | number
    isPremiumUser?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    ogp?: UserOGPUpdateOneWithoutUserNestedInput
    links?: UserLinkUpdateManyWithoutUserNestedInput
    imageBanners?: UserImageBannerUpdateManyWithoutUserNestedInput
    imageCarousels?: UserImageCarouselUpdateManyWithoutUserNestedInput
    imageSidebars?: UserImageSidebarUpdateManyWithoutUserNestedInput
    customQuestions?: UserCustomQuestionUpdateManyWithoutUserNestedInput
    youtubeSettings?: UserYoutubeSettingsUpdateOneWithoutUserNestedInput
    recommendYoutubes?: UserRecommendYoutubeUpdateManyWithoutUserNestedInput
    popupSettings?: UserPopupSettingsUpdateOneWithoutUserNestedInput
    displaySettings?: UserDisplaySettingsUpdateOneWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    characterName?: NullableStringFieldUpdateOperationsInput | string | null
    subname?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    handleChangeCount?: IntFieldUpdateOperationsInput | number
    handleChangeTokens?: IntFieldUpdateOperationsInput | number
    isPremiumUser?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    ogp?: UserOGPUncheckedUpdateOneWithoutUserNestedInput
    links?: UserLinkUncheckedUpdateManyWithoutUserNestedInput
    imageBanners?: UserImageBannerUncheckedUpdateManyWithoutUserNestedInput
    imageCarousels?: UserImageCarouselUncheckedUpdateManyWithoutUserNestedInput
    imageSidebars?: UserImageSidebarUncheckedUpdateManyWithoutUserNestedInput
    customQuestions?: UserCustomQuestionUncheckedUpdateManyWithoutUserNestedInput
    youtubeSettings?: UserYoutubeSettingsUncheckedUpdateOneWithoutUserNestedInput
    recommendYoutubes?: UserRecommendYoutubeUncheckedUpdateManyWithoutUserNestedInput
    popupSettings?: UserPopupSettingsUncheckedUpdateOneWithoutUserNestedInput
    displaySettings?: UserDisplaySettingsUncheckedUpdateOneWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ArticleUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ArticleWhereUniqueInput
    update: XOR<ArticleUpdateWithoutAuthorInput, ArticleUncheckedUpdateWithoutAuthorInput>
    create: XOR<ArticleCreateWithoutAuthorInput, ArticleUncheckedCreateWithoutAuthorInput>
  }

  export type ArticleUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ArticleWhereUniqueInput
    data: XOR<ArticleUpdateWithoutAuthorInput, ArticleUncheckedUpdateWithoutAuthorInput>
  }

  export type ArticleUpdateManyWithWhereWithoutAuthorInput = {
    where: ArticleScalarWhereInput
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyWithoutAuthorInput>
  }

  export type ArticleScalarWhereInput = {
    AND?: ArticleScalarWhereInput | ArticleScalarWhereInput[]
    OR?: ArticleScalarWhereInput[]
    NOT?: ArticleScalarWhereInput | ArticleScalarWhereInput[]
    id?: StringFilter<"Article"> | string
    title?: StringFilter<"Article"> | string
    slug?: StringFilter<"Article"> | string
    content?: StringFilter<"Article"> | string
    excerpt?: StringNullableFilter<"Article"> | string | null
    featuredImage?: StringNullableFilter<"Article"> | string | null
    status?: EnumArticleStatusFilter<"Article"> | $Enums.ArticleStatus
    viewCount?: IntFilter<"Article"> | number
    publishedAt?: DateTimeNullableFilter<"Article"> | Date | string | null
    createdAt?: DateTimeFilter<"Article"> | Date | string
    updatedAt?: DateTimeFilter<"Article"> | Date | string
    authorId?: StringFilter<"Article"> | string
  }

  export type CategoryCreateWithoutChildrenInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    articles?: ArticleCategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutChildrenInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    articles?: ArticleCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutChildrenInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
  }

  export type CategoryCreateWithoutParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CategoryCreateNestedManyWithoutParentInput
    articles?: ArticleCategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    articles?: ArticleCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutParentInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryCreateManyParentInputEnvelope = {
    data: CategoryCreateManyParentInput | CategoryCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type ArticleCategoryCreateWithoutCategoryInput = {
    article: ArticleCreateNestedOneWithoutCategoriesInput
  }

  export type ArticleCategoryUncheckedCreateWithoutCategoryInput = {
    articleId: string
  }

  export type ArticleCategoryCreateOrConnectWithoutCategoryInput = {
    where: ArticleCategoryWhereUniqueInput
    create: XOR<ArticleCategoryCreateWithoutCategoryInput, ArticleCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type ArticleCategoryCreateManyCategoryInputEnvelope = {
    data: ArticleCategoryCreateManyCategoryInput | ArticleCategoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutChildrenInput = {
    update: XOR<CategoryUpdateWithoutChildrenInput, CategoryUncheckedUpdateWithoutChildrenInput>
    create: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutChildrenInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutChildrenInput, CategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type CategoryUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    articles?: ArticleCategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: ArticleCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUpsertWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
  }

  export type CategoryUpdateManyWithWhereWithoutParentInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutParentInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    parentId?: StringNullableFilter<"Category"> | string | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
  }

  export type ArticleCategoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ArticleCategoryWhereUniqueInput
    update: XOR<ArticleCategoryUpdateWithoutCategoryInput, ArticleCategoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<ArticleCategoryCreateWithoutCategoryInput, ArticleCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type ArticleCategoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ArticleCategoryWhereUniqueInput
    data: XOR<ArticleCategoryUpdateWithoutCategoryInput, ArticleCategoryUncheckedUpdateWithoutCategoryInput>
  }

  export type ArticleCategoryUpdateManyWithWhereWithoutCategoryInput = {
    where: ArticleCategoryScalarWhereInput
    data: XOR<ArticleCategoryUpdateManyMutationInput, ArticleCategoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ArticleCategoryScalarWhereInput = {
    AND?: ArticleCategoryScalarWhereInput | ArticleCategoryScalarWhereInput[]
    OR?: ArticleCategoryScalarWhereInput[]
    NOT?: ArticleCategoryScalarWhereInput | ArticleCategoryScalarWhereInput[]
    articleId?: StringFilter<"ArticleCategory"> | string
    categoryId?: StringFilter<"ArticleCategory"> | string
  }

  export type ArticleTagCreateWithoutTagInput = {
    article: ArticleCreateNestedOneWithoutTagsInput
  }

  export type ArticleTagUncheckedCreateWithoutTagInput = {
    articleId: string
  }

  export type ArticleTagCreateOrConnectWithoutTagInput = {
    where: ArticleTagWhereUniqueInput
    create: XOR<ArticleTagCreateWithoutTagInput, ArticleTagUncheckedCreateWithoutTagInput>
  }

  export type ArticleTagCreateManyTagInputEnvelope = {
    data: ArticleTagCreateManyTagInput | ArticleTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type ArticleTagUpsertWithWhereUniqueWithoutTagInput = {
    where: ArticleTagWhereUniqueInput
    update: XOR<ArticleTagUpdateWithoutTagInput, ArticleTagUncheckedUpdateWithoutTagInput>
    create: XOR<ArticleTagCreateWithoutTagInput, ArticleTagUncheckedCreateWithoutTagInput>
  }

  export type ArticleTagUpdateWithWhereUniqueWithoutTagInput = {
    where: ArticleTagWhereUniqueInput
    data: XOR<ArticleTagUpdateWithoutTagInput, ArticleTagUncheckedUpdateWithoutTagInput>
  }

  export type ArticleTagUpdateManyWithWhereWithoutTagInput = {
    where: ArticleTagScalarWhereInput
    data: XOR<ArticleTagUpdateManyMutationInput, ArticleTagUncheckedUpdateManyWithoutTagInput>
  }

  export type ArticleTagScalarWhereInput = {
    AND?: ArticleTagScalarWhereInput | ArticleTagScalarWhereInput[]
    OR?: ArticleTagScalarWhereInput[]
    NOT?: ArticleTagScalarWhereInput | ArticleTagScalarWhereInput[]
    articleId?: StringFilter<"ArticleTag"> | string
    tagId?: StringFilter<"ArticleTag"> | string
  }

  export type AuthorCreateWithoutArticlesInput = {
    id?: string
    bio?: string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAuthorInput
  }

  export type AuthorUncheckedCreateWithoutArticlesInput = {
    id?: string
    bio?: string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type AuthorCreateOrConnectWithoutArticlesInput = {
    where: AuthorWhereUniqueInput
    create: XOR<AuthorCreateWithoutArticlesInput, AuthorUncheckedCreateWithoutArticlesInput>
  }

  export type ArticleCategoryCreateWithoutArticleInput = {
    category: CategoryCreateNestedOneWithoutArticlesInput
  }

  export type ArticleCategoryUncheckedCreateWithoutArticleInput = {
    categoryId: string
  }

  export type ArticleCategoryCreateOrConnectWithoutArticleInput = {
    where: ArticleCategoryWhereUniqueInput
    create: XOR<ArticleCategoryCreateWithoutArticleInput, ArticleCategoryUncheckedCreateWithoutArticleInput>
  }

  export type ArticleCategoryCreateManyArticleInputEnvelope = {
    data: ArticleCategoryCreateManyArticleInput | ArticleCategoryCreateManyArticleInput[]
    skipDuplicates?: boolean
  }

  export type ArticleTagCreateWithoutArticleInput = {
    tag: TagCreateNestedOneWithoutArticlesInput
  }

  export type ArticleTagUncheckedCreateWithoutArticleInput = {
    tagId: string
  }

  export type ArticleTagCreateOrConnectWithoutArticleInput = {
    where: ArticleTagWhereUniqueInput
    create: XOR<ArticleTagCreateWithoutArticleInput, ArticleTagUncheckedCreateWithoutArticleInput>
  }

  export type ArticleTagCreateManyArticleInputEnvelope = {
    data: ArticleTagCreateManyArticleInput | ArticleTagCreateManyArticleInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutArticleInput = {
    id?: string
    content: string
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: CommentCreateNestedOneWithoutChildrenInput
    children?: CommentCreateNestedManyWithoutParentInput
    user?: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutArticleInput = {
    id?: string
    content: string
    parentId?: string | null
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    children?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutArticleInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutArticleInput, CommentUncheckedCreateWithoutArticleInput>
  }

  export type CommentCreateManyArticleInputEnvelope = {
    data: CommentCreateManyArticleInput | CommentCreateManyArticleInput[]
    skipDuplicates?: boolean
  }

  export type AuthorUpsertWithoutArticlesInput = {
    update: XOR<AuthorUpdateWithoutArticlesInput, AuthorUncheckedUpdateWithoutArticlesInput>
    create: XOR<AuthorCreateWithoutArticlesInput, AuthorUncheckedCreateWithoutArticlesInput>
    where?: AuthorWhereInput
  }

  export type AuthorUpdateToOneWithWhereWithoutArticlesInput = {
    where?: AuthorWhereInput
    data: XOR<AuthorUpdateWithoutArticlesInput, AuthorUncheckedUpdateWithoutArticlesInput>
  }

  export type AuthorUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuthorNestedInput
  }

  export type AuthorUncheckedUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ArticleCategoryUpsertWithWhereUniqueWithoutArticleInput = {
    where: ArticleCategoryWhereUniqueInput
    update: XOR<ArticleCategoryUpdateWithoutArticleInput, ArticleCategoryUncheckedUpdateWithoutArticleInput>
    create: XOR<ArticleCategoryCreateWithoutArticleInput, ArticleCategoryUncheckedCreateWithoutArticleInput>
  }

  export type ArticleCategoryUpdateWithWhereUniqueWithoutArticleInput = {
    where: ArticleCategoryWhereUniqueInput
    data: XOR<ArticleCategoryUpdateWithoutArticleInput, ArticleCategoryUncheckedUpdateWithoutArticleInput>
  }

  export type ArticleCategoryUpdateManyWithWhereWithoutArticleInput = {
    where: ArticleCategoryScalarWhereInput
    data: XOR<ArticleCategoryUpdateManyMutationInput, ArticleCategoryUncheckedUpdateManyWithoutArticleInput>
  }

  export type ArticleTagUpsertWithWhereUniqueWithoutArticleInput = {
    where: ArticleTagWhereUniqueInput
    update: XOR<ArticleTagUpdateWithoutArticleInput, ArticleTagUncheckedUpdateWithoutArticleInput>
    create: XOR<ArticleTagCreateWithoutArticleInput, ArticleTagUncheckedCreateWithoutArticleInput>
  }

  export type ArticleTagUpdateWithWhereUniqueWithoutArticleInput = {
    where: ArticleTagWhereUniqueInput
    data: XOR<ArticleTagUpdateWithoutArticleInput, ArticleTagUncheckedUpdateWithoutArticleInput>
  }

  export type ArticleTagUpdateManyWithWhereWithoutArticleInput = {
    where: ArticleTagScalarWhereInput
    data: XOR<ArticleTagUpdateManyMutationInput, ArticleTagUncheckedUpdateManyWithoutArticleInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutArticleInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutArticleInput, CommentUncheckedUpdateWithoutArticleInput>
    create: XOR<CommentCreateWithoutArticleInput, CommentUncheckedCreateWithoutArticleInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutArticleInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutArticleInput, CommentUncheckedUpdateWithoutArticleInput>
  }

  export type CommentUpdateManyWithWhereWithoutArticleInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutArticleInput>
  }

  export type ArticleCreateWithoutCategoriesInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    featuredImage?: string | null
    status?: $Enums.ArticleStatus
    viewCount?: number
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: AuthorCreateNestedOneWithoutArticlesInput
    tags?: ArticleTagCreateNestedManyWithoutArticleInput
    comments?: CommentCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutCategoriesInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    featuredImage?: string | null
    status?: $Enums.ArticleStatus
    viewCount?: number
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    tags?: ArticleTagUncheckedCreateNestedManyWithoutArticleInput
    comments?: CommentUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutCategoriesInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutCategoriesInput, ArticleUncheckedCreateWithoutCategoriesInput>
  }

  export type CategoryCreateWithoutArticlesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
  }

  export type CategoryUncheckedCreateWithoutArticlesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
  }

  export type CategoryCreateOrConnectWithoutArticlesInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutArticlesInput, CategoryUncheckedCreateWithoutArticlesInput>
  }

  export type ArticleUpsertWithoutCategoriesInput = {
    update: XOR<ArticleUpdateWithoutCategoriesInput, ArticleUncheckedUpdateWithoutCategoriesInput>
    create: XOR<ArticleCreateWithoutCategoriesInput, ArticleUncheckedCreateWithoutCategoriesInput>
    where?: ArticleWhereInput
  }

  export type ArticleUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: ArticleWhereInput
    data: XOR<ArticleUpdateWithoutCategoriesInput, ArticleUncheckedUpdateWithoutCategoriesInput>
  }

  export type ArticleUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumArticleStatusFieldUpdateOperationsInput | $Enums.ArticleStatus
    viewCount?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: AuthorUpdateOneRequiredWithoutArticlesNestedInput
    tags?: ArticleTagUpdateManyWithoutArticleNestedInput
    comments?: CommentUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumArticleStatusFieldUpdateOperationsInput | $Enums.ArticleStatus
    viewCount?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    tags?: ArticleTagUncheckedUpdateManyWithoutArticleNestedInput
    comments?: CommentUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type CategoryUpsertWithoutArticlesInput = {
    update: XOR<CategoryUpdateWithoutArticlesInput, CategoryUncheckedUpdateWithoutArticlesInput>
    create: XOR<CategoryCreateWithoutArticlesInput, CategoryUncheckedCreateWithoutArticlesInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutArticlesInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutArticlesInput, CategoryUncheckedUpdateWithoutArticlesInput>
  }

  export type CategoryUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
  }

  export type CategoryUncheckedUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ArticleCreateWithoutTagsInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    featuredImage?: string | null
    status?: $Enums.ArticleStatus
    viewCount?: number
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: AuthorCreateNestedOneWithoutArticlesInput
    categories?: ArticleCategoryCreateNestedManyWithoutArticleInput
    comments?: CommentCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutTagsInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    featuredImage?: string | null
    status?: $Enums.ArticleStatus
    viewCount?: number
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    categories?: ArticleCategoryUncheckedCreateNestedManyWithoutArticleInput
    comments?: CommentUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutTagsInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutTagsInput, ArticleUncheckedCreateWithoutTagsInput>
  }

  export type TagCreateWithoutArticlesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUncheckedCreateWithoutArticlesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagCreateOrConnectWithoutArticlesInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutArticlesInput, TagUncheckedCreateWithoutArticlesInput>
  }

  export type ArticleUpsertWithoutTagsInput = {
    update: XOR<ArticleUpdateWithoutTagsInput, ArticleUncheckedUpdateWithoutTagsInput>
    create: XOR<ArticleCreateWithoutTagsInput, ArticleUncheckedCreateWithoutTagsInput>
    where?: ArticleWhereInput
  }

  export type ArticleUpdateToOneWithWhereWithoutTagsInput = {
    where?: ArticleWhereInput
    data: XOR<ArticleUpdateWithoutTagsInput, ArticleUncheckedUpdateWithoutTagsInput>
  }

  export type ArticleUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumArticleStatusFieldUpdateOperationsInput | $Enums.ArticleStatus
    viewCount?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: AuthorUpdateOneRequiredWithoutArticlesNestedInput
    categories?: ArticleCategoryUpdateManyWithoutArticleNestedInput
    comments?: CommentUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumArticleStatusFieldUpdateOperationsInput | $Enums.ArticleStatus
    viewCount?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    categories?: ArticleCategoryUncheckedUpdateManyWithoutArticleNestedInput
    comments?: CommentUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type TagUpsertWithoutArticlesInput = {
    update: XOR<TagUpdateWithoutArticlesInput, TagUncheckedUpdateWithoutArticlesInput>
    create: XOR<TagCreateWithoutArticlesInput, TagUncheckedCreateWithoutArticlesInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutArticlesInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutArticlesInput, TagUncheckedUpdateWithoutArticlesInput>
  }

  export type TagUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateWithoutChildrenInput = {
    id?: string
    content: string
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: CommentCreateNestedOneWithoutChildrenInput
    article: ArticleCreateNestedOneWithoutCommentsInput
    user?: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutChildrenInput = {
    id?: string
    content: string
    parentId?: string | null
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    articleId: string
    userId?: string | null
  }

  export type CommentCreateOrConnectWithoutChildrenInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutChildrenInput, CommentUncheckedCreateWithoutChildrenInput>
  }

  export type CommentCreateWithoutParentInput = {
    id?: string
    content: string
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CommentCreateNestedManyWithoutParentInput
    article: ArticleCreateNestedOneWithoutCommentsInput
    user?: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutParentInput = {
    id?: string
    content: string
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    articleId: string
    userId?: string | null
    children?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutParentInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
  }

  export type CommentCreateManyParentInputEnvelope = {
    data: CommentCreateManyParentInput | CommentCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type ArticleCreateWithoutCommentsInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    featuredImage?: string | null
    status?: $Enums.ArticleStatus
    viewCount?: number
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: AuthorCreateNestedOneWithoutArticlesInput
    categories?: ArticleCategoryCreateNestedManyWithoutArticleInput
    tags?: ArticleTagCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutCommentsInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    featuredImage?: string | null
    status?: $Enums.ArticleStatus
    viewCount?: number
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authorId: string
    categories?: ArticleCategoryUncheckedCreateNestedManyWithoutArticleInput
    tags?: ArticleTagUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutCommentsInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutCommentsInput, ArticleUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommentsInput = {
    id?: string
    email: string
    name?: string | null
    characterName?: string | null
    subname?: string | null
    bio?: string | null
    birthday?: Date | string | null
    gender?: string | null
    iconUrl?: string | null
    bannerUrl?: string | null
    handle?: string | null
    handleChangeCount?: number
    handleChangeTokens?: number
    isPremiumUser?: boolean
    role?: string
    subscriptionStatus?: string | null
    emailVerified?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    ogp?: UserOGPCreateNestedOneWithoutUserInput
    links?: UserLinkCreateNestedManyWithoutUserInput
    imageBanners?: UserImageBannerCreateNestedManyWithoutUserInput
    imageCarousels?: UserImageCarouselCreateNestedManyWithoutUserInput
    imageSidebars?: UserImageSidebarCreateNestedManyWithoutUserInput
    customQuestions?: UserCustomQuestionCreateNestedManyWithoutUserInput
    youtubeSettings?: UserYoutubeSettingsCreateNestedOneWithoutUserInput
    recommendYoutubes?: UserRecommendYoutubeCreateNestedManyWithoutUserInput
    popupSettings?: UserPopupSettingsCreateNestedOneWithoutUserInput
    displaySettings?: UserDisplaySettingsCreateNestedOneWithoutUserInput
    notificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    author?: AuthorCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string
    email: string
    name?: string | null
    characterName?: string | null
    subname?: string | null
    bio?: string | null
    birthday?: Date | string | null
    gender?: string | null
    iconUrl?: string | null
    bannerUrl?: string | null
    handle?: string | null
    handleChangeCount?: number
    handleChangeTokens?: number
    isPremiumUser?: boolean
    role?: string
    subscriptionStatus?: string | null
    emailVerified?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    ogp?: UserOGPUncheckedCreateNestedOneWithoutUserInput
    links?: UserLinkUncheckedCreateNestedManyWithoutUserInput
    imageBanners?: UserImageBannerUncheckedCreateNestedManyWithoutUserInput
    imageCarousels?: UserImageCarouselUncheckedCreateNestedManyWithoutUserInput
    imageSidebars?: UserImageSidebarUncheckedCreateNestedManyWithoutUserInput
    customQuestions?: UserCustomQuestionUncheckedCreateNestedManyWithoutUserInput
    youtubeSettings?: UserYoutubeSettingsUncheckedCreateNestedOneWithoutUserInput
    recommendYoutubes?: UserRecommendYoutubeUncheckedCreateNestedManyWithoutUserInput
    popupSettings?: UserPopupSettingsUncheckedCreateNestedOneWithoutUserInput
    displaySettings?: UserDisplaySettingsUncheckedCreateNestedOneWithoutUserInput
    notificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    author?: AuthorUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type CommentUpsertWithoutChildrenInput = {
    update: XOR<CommentUpdateWithoutChildrenInput, CommentUncheckedUpdateWithoutChildrenInput>
    create: XOR<CommentCreateWithoutChildrenInput, CommentUncheckedCreateWithoutChildrenInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutChildrenInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutChildrenInput, CommentUncheckedUpdateWithoutChildrenInput>
  }

  export type CommentUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: CommentUpdateOneWithoutChildrenNestedInput
    article?: ArticleUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articleId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentUpsertWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutParentInput, CommentUncheckedUpdateWithoutParentInput>
    create: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutParentInput, CommentUncheckedUpdateWithoutParentInput>
  }

  export type CommentUpdateManyWithWhereWithoutParentInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutParentInput>
  }

  export type ArticleUpsertWithoutCommentsInput = {
    update: XOR<ArticleUpdateWithoutCommentsInput, ArticleUncheckedUpdateWithoutCommentsInput>
    create: XOR<ArticleCreateWithoutCommentsInput, ArticleUncheckedCreateWithoutCommentsInput>
    where?: ArticleWhereInput
  }

  export type ArticleUpdateToOneWithWhereWithoutCommentsInput = {
    where?: ArticleWhereInput
    data: XOR<ArticleUpdateWithoutCommentsInput, ArticleUncheckedUpdateWithoutCommentsInput>
  }

  export type ArticleUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumArticleStatusFieldUpdateOperationsInput | $Enums.ArticleStatus
    viewCount?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: AuthorUpdateOneRequiredWithoutArticlesNestedInput
    categories?: ArticleCategoryUpdateManyWithoutArticleNestedInput
    tags?: ArticleTagUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumArticleStatusFieldUpdateOperationsInput | $Enums.ArticleStatus
    viewCount?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    categories?: ArticleCategoryUncheckedUpdateManyWithoutArticleNestedInput
    tags?: ArticleTagUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    characterName?: NullableStringFieldUpdateOperationsInput | string | null
    subname?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    handleChangeCount?: IntFieldUpdateOperationsInput | number
    handleChangeTokens?: IntFieldUpdateOperationsInput | number
    isPremiumUser?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    ogp?: UserOGPUpdateOneWithoutUserNestedInput
    links?: UserLinkUpdateManyWithoutUserNestedInput
    imageBanners?: UserImageBannerUpdateManyWithoutUserNestedInput
    imageCarousels?: UserImageCarouselUpdateManyWithoutUserNestedInput
    imageSidebars?: UserImageSidebarUpdateManyWithoutUserNestedInput
    customQuestions?: UserCustomQuestionUpdateManyWithoutUserNestedInput
    youtubeSettings?: UserYoutubeSettingsUpdateOneWithoutUserNestedInput
    recommendYoutubes?: UserRecommendYoutubeUpdateManyWithoutUserNestedInput
    popupSettings?: UserPopupSettingsUpdateOneWithoutUserNestedInput
    displaySettings?: UserDisplaySettingsUpdateOneWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    author?: AuthorUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    characterName?: NullableStringFieldUpdateOperationsInput | string | null
    subname?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bannerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    handle?: NullableStringFieldUpdateOperationsInput | string | null
    handleChangeCount?: IntFieldUpdateOperationsInput | number
    handleChangeTokens?: IntFieldUpdateOperationsInput | number
    isPremiumUser?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    ogp?: UserOGPUncheckedUpdateOneWithoutUserNestedInput
    links?: UserLinkUncheckedUpdateManyWithoutUserNestedInput
    imageBanners?: UserImageBannerUncheckedUpdateManyWithoutUserNestedInput
    imageCarousels?: UserImageCarouselUncheckedUpdateManyWithoutUserNestedInput
    imageSidebars?: UserImageSidebarUncheckedUpdateManyWithoutUserNestedInput
    customQuestions?: UserCustomQuestionUncheckedUpdateManyWithoutUserNestedInput
    youtubeSettings?: UserYoutubeSettingsUncheckedUpdateOneWithoutUserNestedInput
    recommendYoutubes?: UserRecommendYoutubeUncheckedUpdateManyWithoutUserNestedInput
    popupSettings?: UserPopupSettingsUncheckedUpdateOneWithoutUserNestedInput
    displaySettings?: UserDisplaySettingsUncheckedUpdateOneWithoutUserNestedInput
    notificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    author?: AuthorUncheckedUpdateOneWithoutUserNestedInput
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type UserLinkCreateManyUserInput = {
    id?: string
    url: string
    title?: string | null
    description?: string | null
    sortOrder?: number
    isActive?: boolean
    useOriginalIcon?: boolean
    originalIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceId: string
    iconId?: string | null
  }

  export type UserImageBannerCreateManyUserInput = {
    id?: string
    url?: string | null
    imgUrl: string
    alt?: string | null
    sortOrder?: number
  }

  export type UserImageCarouselCreateManyUserInput = {
    id?: string
    url?: string | null
    imgUrl: string
    alt?: string | null
    sortOrder?: number
  }

  export type UserImageSidebarCreateManyUserInput = {
    id?: string
    url?: string | null
    imgUrl: string
    alt?: string | null
    sortOrder?: number
  }

  export type UserCustomQuestionCreateManyUserInput = {
    id?: string
    question: string
    answer: string
    sortOrder?: number
  }

  export type UserRecommendYoutubeCreateManyUserInput = {
    id?: string
    url: string
    thumbnailUrl?: string | null
    title?: string | null
    description?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyUserInput = {
    id?: string
    content: string
    parentId?: string | null
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    articleId: string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLinkUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    useOriginalIcon?: BoolFieldUpdateOperationsInput | boolean
    originalIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: LinkServiceUpdateOneRequiredWithoutLinksNestedInput
    icon?: ServiceIconUpdateOneWithoutLinksNestedInput
  }

  export type UserLinkUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    useOriginalIcon?: BoolFieldUpdateOperationsInput | boolean
    originalIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceId?: StringFieldUpdateOperationsInput | string
    iconId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserLinkUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    useOriginalIcon?: BoolFieldUpdateOperationsInput | boolean
    originalIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceId?: StringFieldUpdateOperationsInput | string
    iconId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserImageBannerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    imgUrl?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type UserImageBannerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    imgUrl?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type UserImageBannerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    imgUrl?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type UserImageCarouselUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    imgUrl?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type UserImageCarouselUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    imgUrl?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type UserImageCarouselUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    imgUrl?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type UserImageSidebarUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    imgUrl?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type UserImageSidebarUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    imgUrl?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type UserImageSidebarUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    imgUrl?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type UserCustomQuestionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type UserCustomQuestionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type UserCustomQuestionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type UserRecommendYoutubeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRecommendYoutubeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRecommendYoutubeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: CommentUpdateOneWithoutChildrenNestedInput
    children?: CommentUpdateManyWithoutParentNestedInput
    article?: ArticleUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articleId?: StringFieldUpdateOperationsInput | string
    children?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articleId?: StringFieldUpdateOperationsInput | string
  }

  export type UserYoutubeVideoCreateManySettingsInput = {
    id?: string
    url: string
    thumbnailUrl?: string | null
    title?: string | null
    description?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserYoutubeVideoUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserYoutubeVideoUncheckedUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserYoutubeVideoUncheckedUpdateManyWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceIconCreateManyServiceInput = {
    id?: string
    name: string
    fileName: string
    filePath: string
    style: $Enums.IconStyle
    colorScheme: $Enums.IconColor
    description?: string | null
    isActive?: boolean
    sortOrder?: number
    uploadedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserLinkCreateManyServiceInput = {
    id?: string
    url: string
    title?: string | null
    description?: string | null
    sortOrder?: number
    isActive?: boolean
    useOriginalIcon?: boolean
    originalIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    iconId?: string | null
  }

  export type ServiceIconUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    style?: EnumIconStyleFieldUpdateOperationsInput | $Enums.IconStyle
    colorScheme?: EnumIconColorFieldUpdateOperationsInput | $Enums.IconColor
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    links?: UserLinkUpdateManyWithoutIconNestedInput
  }

  export type ServiceIconUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    style?: EnumIconStyleFieldUpdateOperationsInput | $Enums.IconStyle
    colorScheme?: EnumIconColorFieldUpdateOperationsInput | $Enums.IconColor
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    links?: UserLinkUncheckedUpdateManyWithoutIconNestedInput
  }

  export type ServiceIconUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    style?: EnumIconStyleFieldUpdateOperationsInput | $Enums.IconStyle
    colorScheme?: EnumIconColorFieldUpdateOperationsInput | $Enums.IconColor
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserLinkUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    useOriginalIcon?: BoolFieldUpdateOperationsInput | boolean
    originalIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLinksNestedInput
    icon?: ServiceIconUpdateOneWithoutLinksNestedInput
  }

  export type UserLinkUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    useOriginalIcon?: BoolFieldUpdateOperationsInput | boolean
    originalIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    iconId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserLinkUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    useOriginalIcon?: BoolFieldUpdateOperationsInput | boolean
    originalIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    iconId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserLinkCreateManyIconInput = {
    id?: string
    url: string
    title?: string | null
    description?: string | null
    sortOrder?: number
    isActive?: boolean
    useOriginalIcon?: boolean
    originalIconUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    serviceId: string
  }

  export type UserLinkUpdateWithoutIconInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    useOriginalIcon?: BoolFieldUpdateOperationsInput | boolean
    originalIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLinksNestedInput
    service?: LinkServiceUpdateOneRequiredWithoutLinksNestedInput
  }

  export type UserLinkUncheckedUpdateWithoutIconInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    useOriginalIcon?: BoolFieldUpdateOperationsInput | boolean
    originalIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type UserLinkUncheckedUpdateManyWithoutIconInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    useOriginalIcon?: BoolFieldUpdateOperationsInput | boolean
    originalIconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type ArticleCreateManyAuthorInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    featuredImage?: string | null
    status?: $Enums.ArticleStatus
    viewCount?: number
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArticleUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumArticleStatusFieldUpdateOperationsInput | $Enums.ArticleStatus
    viewCount?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ArticleCategoryUpdateManyWithoutArticleNestedInput
    tags?: ArticleTagUpdateManyWithoutArticleNestedInput
    comments?: CommentUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumArticleStatusFieldUpdateOperationsInput | $Enums.ArticleStatus
    viewCount?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: ArticleCategoryUncheckedUpdateManyWithoutArticleNestedInput
    tags?: ArticleTagUncheckedUpdateManyWithoutArticleNestedInput
    comments?: CommentUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    featuredImage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumArticleStatusFieldUpdateOperationsInput | $Enums.ArticleStatus
    viewCount?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateManyParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArticleCategoryCreateManyCategoryInput = {
    articleId: string
  }

  export type CategoryUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUpdateManyWithoutParentNestedInput
    articles?: ArticleCategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    articles?: ArticleCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleCategoryUpdateWithoutCategoryInput = {
    article?: ArticleUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type ArticleCategoryUncheckedUpdateWithoutCategoryInput = {
    articleId?: StringFieldUpdateOperationsInput | string
  }

  export type ArticleCategoryUncheckedUpdateManyWithoutCategoryInput = {
    articleId?: StringFieldUpdateOperationsInput | string
  }

  export type ArticleTagCreateManyTagInput = {
    articleId: string
  }

  export type ArticleTagUpdateWithoutTagInput = {
    article?: ArticleUpdateOneRequiredWithoutTagsNestedInput
  }

  export type ArticleTagUncheckedUpdateWithoutTagInput = {
    articleId?: StringFieldUpdateOperationsInput | string
  }

  export type ArticleTagUncheckedUpdateManyWithoutTagInput = {
    articleId?: StringFieldUpdateOperationsInput | string
  }

  export type ArticleCategoryCreateManyArticleInput = {
    categoryId: string
  }

  export type ArticleTagCreateManyArticleInput = {
    tagId: string
  }

  export type CommentCreateManyArticleInput = {
    id?: string
    content: string
    parentId?: string | null
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
  }

  export type ArticleCategoryUpdateWithoutArticleInput = {
    category?: CategoryUpdateOneRequiredWithoutArticlesNestedInput
  }

  export type ArticleCategoryUncheckedUpdateWithoutArticleInput = {
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type ArticleCategoryUncheckedUpdateManyWithoutArticleInput = {
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type ArticleTagUpdateWithoutArticleInput = {
    tag?: TagUpdateOneRequiredWithoutArticlesNestedInput
  }

  export type ArticleTagUncheckedUpdateWithoutArticleInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type ArticleTagUncheckedUpdateManyWithoutArticleInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: CommentUpdateOneWithoutChildrenNestedInput
    children?: CommentUpdateManyWithoutParentNestedInput
    user?: UserUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentCreateManyParentInput = {
    id?: string
    content: string
    isApproved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    articleId: string
    userId?: string | null
  }

  export type CommentUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CommentUpdateManyWithoutParentNestedInput
    article?: ArticleUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articleId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articleId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}